
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Anime
 * 
 */
export type Anime = $Result.DefaultSelection<Prisma.$AnimePayload>
/**
 * Model Anime_Authors
 * 
 */
export type Anime_Authors = $Result.DefaultSelection<Prisma.$Anime_AuthorsPayload>
/**
 * Model Bookmarks
 * 
 */
export type Bookmarks = $Result.DefaultSelection<Prisma.$BookmarksPayload>
/**
 * Model Comments
 * 
 */
export type Comments = $Result.DefaultSelection<Prisma.$CommentsPayload>
/**
 * Model ContentGroup
 * 
 */
export type ContentGroup = $Result.DefaultSelection<Prisma.$ContentGroupPayload>
/**
 * Model ContentGroupMedia
 * 
 */
export type ContentGroupMedia = $Result.DefaultSelection<Prisma.$ContentGroupMediaPayload>
/**
 * Model ContentUnit
 * 
 */
export type ContentUnit = $Result.DefaultSelection<Prisma.$ContentUnitPayload>
/**
 * Model Disliked_Content
 * 
 */
export type Disliked_Content = $Result.DefaultSelection<Prisma.$Disliked_ContentPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model FileShares
 * 
 */
export type FileShares = $Result.DefaultSelection<Prisma.$FileSharesPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model FolderShares
 * 
 */
export type FolderShares = $Result.DefaultSelection<Prisma.$FolderSharesPayload>
/**
 * Model Liked_Content
 * 
 */
export type Liked_Content = $Result.DefaultSelection<Prisma.$Liked_ContentPayload>
/**
 * Model Manga
 * 
 */
export type Manga = $Result.DefaultSelection<Prisma.$MangaPayload>
/**
 * Model Movies
 * 
 */
export type Movies = $Result.DefaultSelection<Prisma.$MoviesPayload>
/**
 * Model Polls
 * 
 */
export type Polls = $Result.DefaultSelection<Prisma.$PollsPayload>
/**
 * Model Reviews
 * 
 */
export type Reviews = $Result.DefaultSelection<Prisma.$ReviewsPayload>
/**
 * Model Shopping_Cart
 * 
 */
export type Shopping_Cart = $Result.DefaultSelection<Prisma.$Shopping_CartPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Subscription_Tiers
 * 
 */
export type Subscription_Tiers = $Result.DefaultSelection<Prisma.$Subscription_TiersPayload>
/**
 * Model TitleTranslation
 * 
 */
export type TitleTranslation = $Result.DefaultSelection<Prisma.$TitleTranslationPayload>
/**
 * Model User_Activity
 * 
 */
export type User_Activity = $Result.DefaultSelection<Prisma.$User_ActivityPayload>
/**
 * Model User_Bookmarks
 * 
 */
export type User_Bookmarks = $Result.DefaultSelection<Prisma.$User_BookmarksPayload>
/**
 * Model User_Ratings
 * 
 */
export type User_Ratings = $Result.DefaultSelection<Prisma.$User_RatingsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Videos
 * 
 */
export type Videos = $Result.DefaultSelection<Prisma.$VideosPayload>
/**
 * Model Website_Variables
 * 
 */
export type Website_Variables = $Result.DefaultSelection<Prisma.$Website_VariablesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FileType: {
  FILE: 'FILE',
  FOLDER: 'FOLDER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const AccessLevel: {
  READ: 'READ',
  WRITE: 'WRITE',
  ADMIN: 'ADMIN'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const AccountType: {
  INDIVIDUAL: 'INDIVIDUAL',
  STUDIO: 'STUDIO',
  ADMIN: 'ADMIN'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const AgeRating: {
  G: 'G',
  PG: 'PG',
  PG13: 'PG13',
  R: 'R',
  NC17: 'NC17',
  MA: 'MA'
};

export type AgeRating = (typeof AgeRating)[keyof typeof AgeRating]


export const MediaGenre: {
  ACTION: 'ACTION',
  ADVENTURE: 'ADVENTURE',
  COMEDY: 'COMEDY',
  DRAMA: 'DRAMA',
  FANTASY: 'FANTASY',
  HORROR: 'HORROR',
  MYSTERY: 'MYSTERY',
  ROMANCE: 'ROMANCE',
  SCI_FI: 'SCI_FI',
  SLICE_OF_LIFE: 'SLICE_OF_LIFE',
  SPORTS: 'SPORTS',
  SUPERNATURAL: 'SUPERNATURAL',
  THRILLER: 'THRILLER',
  MECHA: 'MECHA',
  HISTORICAL: 'HISTORICAL',
  MUSIC: 'MUSIC',
  PSYCHOLOGICAL: 'PSYCHOLOGICAL',
  SCHOOL: 'SCHOOL',
  SHOUNEN: 'SHOUNEN',
  SHOUJO: 'SHOUJO',
  SEINEN: 'SEINEN',
  JOSEI: 'JOSEI',
  ISEKAI: 'ISEKAI',
  MILITARY: 'MILITARY',
  VAMPIRE: 'VAMPIRE',
  DEMONS: 'DEMONS',
  MAGIC: 'MAGIC',
  PARODY: 'PARODY',
  MARTIAL_ARTS: 'MARTIAL_ARTS',
  GAME: 'GAME',
  HAREM: 'HAREM',
  YAOI: 'YAOI',
  YURI: 'YURI',
  TRAGEDY: 'TRAGEDY',
  CRIME: 'CRIME',
  WESTERN: 'WESTERN',
  BIOGRAPHY: 'BIOGRAPHY',
  DOCUMENTARY: 'DOCUMENTARY',
  FAMILY: 'FAMILY',
  KIDS: 'KIDS',
  ARTS: 'ARTS',
  ANIME: 'ANIME',
  SUPERHERO: 'SUPERHERO',
  FOLKLORE: 'FOLKLORE',
  ECOLOGICAL: 'ECOLOGICAL',
  ALTERNATIVE: 'ALTERNATIVE',
  LITRPG: 'LITRPG',
  CYBERPUNK: 'CYBERPUNK',
  STEAMPUNK: 'STEAMPUNK',
  GOTHIC: 'GOTHIC',
  POST_APOCALYPTIC: 'POST_APOCALYPTIC',
  HIGH_FANTASY: 'HIGH_FANTASY',
  LOW_FANTASY: 'LOW_FANTASY',
  ARTSY: 'ARTSY',
  AUTOBIOGRAPHY: 'AUTOBIOGRAPHY',
  SLASHER: 'SLASHER',
  SUSPENSE: 'SUSPENSE',
  ROMANTIC_COMEDY: 'ROMANTIC_COMEDY',
  FANFICTION: 'FANFICTION',
  COZY_MYSTERY: 'COZY_MYSTERY',
  BODY_HORROR: 'BODY_HORROR',
  ADULT_ANIMATION: 'ADULT_ANIMATION',
  POLITICAL: 'POLITICAL',
  SCIENCE_FANTASY: 'SCIENCE_FANTASY',
  ANARCHY: 'ANARCHY',
  APOCALYPTIC: 'APOCALYPTIC',
  ZOMBIE: 'ZOMBIE',
  VILLAIN: 'VILLAIN',
  MUSIC_DRAMA: 'MUSIC_DRAMA',
  FANTASY_ROMANCE: 'FANTASY_ROMANCE',
  HISTORICAL_FICTION: 'HISTORICAL_FICTION',
  SHAPESHIFTER: 'SHAPESHIFTER',
  SWORD_AND_SORCERY: 'SWORD_AND_SORCERY',
  GUILTY_PLEASURE: 'GUILTY_PLEASURE',
  ECO_FICTION: 'ECO_FICTION',
  RELIGIOUS: 'RELIGIOUS',
  EXPLORATION: 'EXPLORATION',
  WAR_DRAMA: 'WAR_DRAMA',
  ROAD_MOVIE: 'ROAD_MOVIE',
  POLICE_PROCEDURAL: 'POLICE_PROCEDURAL',
  ANIMATED_COMEDY: 'ANIMATED_COMEDY',
  LOVE_TRIANGLE: 'LOVE_TRIANGLE',
  PSYCHIC: 'PSYCHIC',
  FANTASY_ADVENTURE: 'FANTASY_ADVENTURE',
  DARK_FANTASY: 'DARK_FANTASY',
  TERROR: 'TERROR',
  WITCHCRAFT: 'WITCHCRAFT',
  SURVIVAL: 'SURVIVAL',
  UTOPIA: 'UTOPIA',
  DYSTOPIA: 'DYSTOPIA',
  GENDER_BENDER: 'GENDER_BENDER',
  TIME_TRAVEL: 'TIME_TRAVEL',
  HIGH_SCHOOL: 'HIGH_SCHOOL',
  WAR_FANTASY: 'WAR_FANTASY',
  RAPE_REVENUE: 'RAPE_REVENUE',
  MYSTICAL_REALISM: 'MYSTICAL_REALISM',
  WUXIA: 'WUXIA',
  MYTHOLOGY: 'MYTHOLOGY',
  FRAGMENTED_NARRATIVE: 'FRAGMENTED_NARRATIVE',
  DANCE: 'DANCE',
  FANTASY_MYSTERY: 'FANTASY_MYSTERY',
  INDIE: 'INDIE',
  FOLK: 'FOLK',
  ZANY: 'ZANY',
  MONSTER: 'MONSTER',
  ALIEN: 'ALIEN',
  SPY: 'SPY',
  COOKING: 'COOKING',
  ESCAPE_ROOM: 'ESCAPE_ROOM',
  SURVIVAL_HORROR: 'SURVIVAL_HORROR',
  CULT_FAVORITE: 'CULT_FAVORITE',
  DOCUMENTARY_FICTION: 'DOCUMENTARY_FICTION',
  UNRELIABLE_NARRATOR: 'UNRELIABLE_NARRATOR',
  RANDOMIZED: 'RANDOMIZED',
  EXTREME_SPORTS: 'EXTREME_SPORTS',
  DARK_COMEDY: 'DARK_COMEDY',
  TRAVEL: 'TRAVEL',
  VINTAGE: 'VINTAGE',
  FARM_LIFE: 'FARM_LIFE',
  NATURE: 'NATURE',
  HEROIC_FANTASY: 'HEROIC_FANTASY',
  LOVE_HATE: 'LOVE_HATE',
  SLEEPY: 'SLEEPY',
  POLITICAL_DRAMA: 'POLITICAL_DRAMA',
  PARANORMAL_ROMANCE: 'PARANORMAL_ROMANCE',
  LOVE_HURTS: 'LOVE_HURTS',
  GLOBAL: 'GLOBAL',
  TRAILER: 'TRAILER'
};

export type MediaGenre = (typeof MediaGenre)[keyof typeof MediaGenre]


export const MediaType: {
  ANIME: 'ANIME',
  MOVIE: 'MOVIE',
  MANGA: 'MANGA',
  VIDEO: 'VIDEO',
  POLL: 'POLL',
  STORE: 'STORE',
  STORAGE: 'STORAGE'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const navItems: {
  OVERVIEW: 'OVERVIEW',
  DRIVE: 'DRIVE',
  VIDEOS: 'VIDEOS',
  ANIME: 'ANIME',
  MANGA: 'MANGA',
  MOVIES: 'MOVIES',
  STORE: 'STORE',
  POLLS: 'POLLS',
  STATS: 'STATS',
  SETTINGS: 'SETTINGS'
};

export type navItems = (typeof navItems)[keyof typeof navItems]

}

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type AgeRating = $Enums.AgeRating

export const AgeRating: typeof $Enums.AgeRating

export type MediaGenre = $Enums.MediaGenre

export const MediaGenre: typeof $Enums.MediaGenre

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type navItems = $Enums.navItems

export const navItems: typeof $Enums.navItems

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Anime
 * const anime = await prisma.anime.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Anime
   * const anime = await prisma.anime.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.anime`: Exposes CRUD operations for the **Anime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anime
    * const anime = await prisma.anime.findMany()
    * ```
    */
  get anime(): Prisma.AnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anime_Authors`: Exposes CRUD operations for the **Anime_Authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anime_Authors
    * const anime_Authors = await prisma.anime_Authors.findMany()
    * ```
    */
  get anime_Authors(): Prisma.Anime_AuthorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmarks`: Exposes CRUD operations for the **Bookmarks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmarks.findMany()
    * ```
    */
  get bookmarks(): Prisma.BookmarksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentGroup`: Exposes CRUD operations for the **ContentGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentGroups
    * const contentGroups = await prisma.contentGroup.findMany()
    * ```
    */
  get contentGroup(): Prisma.ContentGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentGroupMedia`: Exposes CRUD operations for the **ContentGroupMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentGroupMedias
    * const contentGroupMedias = await prisma.contentGroupMedia.findMany()
    * ```
    */
  get contentGroupMedia(): Prisma.ContentGroupMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentUnit`: Exposes CRUD operations for the **ContentUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentUnits
    * const contentUnits = await prisma.contentUnit.findMany()
    * ```
    */
  get contentUnit(): Prisma.ContentUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disliked_Content`: Exposes CRUD operations for the **Disliked_Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disliked_Contents
    * const disliked_Contents = await prisma.disliked_Content.findMany()
    * ```
    */
  get disliked_Content(): Prisma.Disliked_ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileShares`: Exposes CRUD operations for the **FileShares** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileShares
    * const fileShares = await prisma.fileShares.findMany()
    * ```
    */
  get fileShares(): Prisma.FileSharesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folderShares`: Exposes CRUD operations for the **FolderShares** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FolderShares
    * const folderShares = await prisma.folderShares.findMany()
    * ```
    */
  get folderShares(): Prisma.FolderSharesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liked_Content`: Exposes CRUD operations for the **Liked_Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liked_Contents
    * const liked_Contents = await prisma.liked_Content.findMany()
    * ```
    */
  get liked_Content(): Prisma.Liked_ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manga`: Exposes CRUD operations for the **Manga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manga
    * const manga = await prisma.manga.findMany()
    * ```
    */
  get manga(): Prisma.MangaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movies`: Exposes CRUD operations for the **Movies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movies.findMany()
    * ```
    */
  get movies(): Prisma.MoviesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.polls`: Exposes CRUD operations for the **Polls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Polls
    * const polls = await prisma.polls.findMany()
    * ```
    */
  get polls(): Prisma.PollsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **Reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.ReviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopping_Cart`: Exposes CRUD operations for the **Shopping_Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shopping_Carts
    * const shopping_Carts = await prisma.shopping_Cart.findMany()
    * ```
    */
  get shopping_Cart(): Prisma.Shopping_CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription_Tiers`: Exposes CRUD operations for the **Subscription_Tiers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscription_Tiers
    * const subscription_Tiers = await prisma.subscription_Tiers.findMany()
    * ```
    */
  get subscription_Tiers(): Prisma.Subscription_TiersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.titleTranslation`: Exposes CRUD operations for the **TitleTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TitleTranslations
    * const titleTranslations = await prisma.titleTranslation.findMany()
    * ```
    */
  get titleTranslation(): Prisma.TitleTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_Activity`: Exposes CRUD operations for the **User_Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Activities
    * const user_Activities = await prisma.user_Activity.findMany()
    * ```
    */
  get user_Activity(): Prisma.User_ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_Bookmarks`: Exposes CRUD operations for the **User_Bookmarks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Bookmarks
    * const user_Bookmarks = await prisma.user_Bookmarks.findMany()
    * ```
    */
  get user_Bookmarks(): Prisma.User_BookmarksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_Ratings`: Exposes CRUD operations for the **User_Ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Ratings
    * const user_Ratings = await prisma.user_Ratings.findMany()
    * ```
    */
  get user_Ratings(): Prisma.User_RatingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videos`: Exposes CRUD operations for the **Videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.videos.findMany()
    * ```
    */
  get videos(): Prisma.VideosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.website_Variables`: Exposes CRUD operations for the **Website_Variables** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Website_Variables
    * const website_Variables = await prisma.website_Variables.findMany()
    * ```
    */
  get website_Variables(): Prisma.Website_VariablesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Anime: 'Anime',
    Anime_Authors: 'Anime_Authors',
    Bookmarks: 'Bookmarks',
    Comments: 'Comments',
    ContentGroup: 'ContentGroup',
    ContentGroupMedia: 'ContentGroupMedia',
    ContentUnit: 'ContentUnit',
    Disliked_Content: 'Disliked_Content',
    File: 'File',
    FileShares: 'FileShares',
    Folder: 'Folder',
    FolderShares: 'FolderShares',
    Liked_Content: 'Liked_Content',
    Manga: 'Manga',
    Movies: 'Movies',
    Polls: 'Polls',
    Reviews: 'Reviews',
    Shopping_Cart: 'Shopping_Cart',
    Store: 'Store',
    Subscription_Tiers: 'Subscription_Tiers',
    TitleTranslation: 'TitleTranslation',
    User_Activity: 'User_Activity',
    User_Bookmarks: 'User_Bookmarks',
    User_Ratings: 'User_Ratings',
    Users: 'Users',
    Videos: 'Videos',
    Website_Variables: 'Website_Variables'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "anime" | "anime_Authors" | "bookmarks" | "comments" | "contentGroup" | "contentGroupMedia" | "contentUnit" | "disliked_Content" | "file" | "fileShares" | "folder" | "folderShares" | "liked_Content" | "manga" | "movies" | "polls" | "reviews" | "shopping_Cart" | "store" | "subscription_Tiers" | "titleTranslation" | "user_Activity" | "user_Bookmarks" | "user_Ratings" | "users" | "videos" | "website_Variables"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Anime: {
        payload: Prisma.$AnimePayload<ExtArgs>
        fields: Prisma.AnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          findFirst: {
            args: Prisma.AnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          findMany: {
            args: Prisma.AnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          create: {
            args: Prisma.AnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          createMany: {
            args: Prisma.AnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          delete: {
            args: Prisma.AnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          update: {
            args: Prisma.AnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          deleteMany: {
            args: Prisma.AnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          upsert: {
            args: Prisma.AnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          aggregate: {
            args: Prisma.AnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnime>
          }
          groupBy: {
            args: Prisma.AnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimeCountArgs<ExtArgs>
            result: $Utils.Optional<AnimeCountAggregateOutputType> | number
          }
        }
      }
      Anime_Authors: {
        payload: Prisma.$Anime_AuthorsPayload<ExtArgs>
        fields: Prisma.Anime_AuthorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Anime_AuthorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Anime_AuthorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          findFirst: {
            args: Prisma.Anime_AuthorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Anime_AuthorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          findMany: {
            args: Prisma.Anime_AuthorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>[]
          }
          create: {
            args: Prisma.Anime_AuthorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          createMany: {
            args: Prisma.Anime_AuthorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Anime_AuthorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>[]
          }
          delete: {
            args: Prisma.Anime_AuthorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          update: {
            args: Prisma.Anime_AuthorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          deleteMany: {
            args: Prisma.Anime_AuthorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Anime_AuthorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Anime_AuthorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>[]
          }
          upsert: {
            args: Prisma.Anime_AuthorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Anime_AuthorsPayload>
          }
          aggregate: {
            args: Prisma.Anime_AuthorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnime_Authors>
          }
          groupBy: {
            args: Prisma.Anime_AuthorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Anime_AuthorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Anime_AuthorsCountArgs<ExtArgs>
            result: $Utils.Optional<Anime_AuthorsCountAggregateOutputType> | number
          }
        }
      }
      Bookmarks: {
        payload: Prisma.$BookmarksPayload<ExtArgs>
        fields: Prisma.BookmarksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          findFirst: {
            args: Prisma.BookmarksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          findMany: {
            args: Prisma.BookmarksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>[]
          }
          create: {
            args: Prisma.BookmarksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          createMany: {
            args: Prisma.BookmarksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>[]
          }
          delete: {
            args: Prisma.BookmarksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          update: {
            args: Prisma.BookmarksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          deleteMany: {
            args: Prisma.BookmarksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookmarksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>[]
          }
          upsert: {
            args: Prisma.BookmarksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarksPayload>
          }
          aggregate: {
            args: Prisma.BookmarksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmarks>
          }
          groupBy: {
            args: Prisma.BookmarksGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarksGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarksCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarksCountAggregateOutputType> | number
          }
        }
      }
      Comments: {
        payload: Prisma.$CommentsPayload<ExtArgs>
        fields: Prisma.CommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findFirst: {
            args: Prisma.CommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findMany: {
            args: Prisma.CommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          create: {
            args: Prisma.CommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          createMany: {
            args: Prisma.CommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          delete: {
            args: Prisma.CommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          update: {
            args: Prisma.CommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          deleteMany: {
            args: Prisma.CommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          upsert: {
            args: Prisma.CommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      ContentGroup: {
        payload: Prisma.$ContentGroupPayload<ExtArgs>
        fields: Prisma.ContentGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          findFirst: {
            args: Prisma.ContentGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          findMany: {
            args: Prisma.ContentGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>[]
          }
          create: {
            args: Prisma.ContentGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          createMany: {
            args: Prisma.ContentGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>[]
          }
          delete: {
            args: Prisma.ContentGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          update: {
            args: Prisma.ContentGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          deleteMany: {
            args: Prisma.ContentGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>[]
          }
          upsert: {
            args: Prisma.ContentGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupPayload>
          }
          aggregate: {
            args: Prisma.ContentGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentGroup>
          }
          groupBy: {
            args: Prisma.ContentGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupCountAggregateOutputType> | number
          }
        }
      }
      ContentGroupMedia: {
        payload: Prisma.$ContentGroupMediaPayload<ExtArgs>
        fields: Prisma.ContentGroupMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentGroupMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentGroupMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          findFirst: {
            args: Prisma.ContentGroupMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentGroupMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          findMany: {
            args: Prisma.ContentGroupMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>[]
          }
          create: {
            args: Prisma.ContentGroupMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          createMany: {
            args: Prisma.ContentGroupMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentGroupMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>[]
          }
          delete: {
            args: Prisma.ContentGroupMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          update: {
            args: Prisma.ContentGroupMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          deleteMany: {
            args: Prisma.ContentGroupMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentGroupMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentGroupMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>[]
          }
          upsert: {
            args: Prisma.ContentGroupMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGroupMediaPayload>
          }
          aggregate: {
            args: Prisma.ContentGroupMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentGroupMedia>
          }
          groupBy: {
            args: Prisma.ContentGroupMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentGroupMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupMediaCountAggregateOutputType> | number
          }
        }
      }
      ContentUnit: {
        payload: Prisma.$ContentUnitPayload<ExtArgs>
        fields: Prisma.ContentUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          findFirst: {
            args: Prisma.ContentUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          findMany: {
            args: Prisma.ContentUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          create: {
            args: Prisma.ContentUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          createMany: {
            args: Prisma.ContentUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          delete: {
            args: Prisma.ContentUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          update: {
            args: Prisma.ContentUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          deleteMany: {
            args: Prisma.ContentUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>[]
          }
          upsert: {
            args: Prisma.ContentUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentUnitPayload>
          }
          aggregate: {
            args: Prisma.ContentUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentUnit>
          }
          groupBy: {
            args: Prisma.ContentUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentUnitCountArgs<ExtArgs>
            result: $Utils.Optional<ContentUnitCountAggregateOutputType> | number
          }
        }
      }
      Disliked_Content: {
        payload: Prisma.$Disliked_ContentPayload<ExtArgs>
        fields: Prisma.Disliked_ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Disliked_ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Disliked_ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          findFirst: {
            args: Prisma.Disliked_ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Disliked_ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          findMany: {
            args: Prisma.Disliked_ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>[]
          }
          create: {
            args: Prisma.Disliked_ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          createMany: {
            args: Prisma.Disliked_ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Disliked_ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>[]
          }
          delete: {
            args: Prisma.Disliked_ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          update: {
            args: Prisma.Disliked_ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          deleteMany: {
            args: Prisma.Disliked_ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Disliked_ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Disliked_ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>[]
          }
          upsert: {
            args: Prisma.Disliked_ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Disliked_ContentPayload>
          }
          aggregate: {
            args: Prisma.Disliked_ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisliked_Content>
          }
          groupBy: {
            args: Prisma.Disliked_ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Disliked_ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Disliked_ContentCountArgs<ExtArgs>
            result: $Utils.Optional<Disliked_ContentCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      FileShares: {
        payload: Prisma.$FileSharesPayload<ExtArgs>
        fields: Prisma.FileSharesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileSharesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileSharesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          findFirst: {
            args: Prisma.FileSharesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileSharesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          findMany: {
            args: Prisma.FileSharesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>[]
          }
          create: {
            args: Prisma.FileSharesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          createMany: {
            args: Prisma.FileSharesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileSharesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>[]
          }
          delete: {
            args: Prisma.FileSharesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          update: {
            args: Prisma.FileSharesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          deleteMany: {
            args: Prisma.FileSharesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileSharesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileSharesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>[]
          }
          upsert: {
            args: Prisma.FileSharesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSharesPayload>
          }
          aggregate: {
            args: Prisma.FileSharesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileShares>
          }
          groupBy: {
            args: Prisma.FileSharesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileSharesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileSharesCountArgs<ExtArgs>
            result: $Utils.Optional<FileSharesCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      FolderShares: {
        payload: Prisma.$FolderSharesPayload<ExtArgs>
        fields: Prisma.FolderSharesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderSharesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderSharesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          findFirst: {
            args: Prisma.FolderSharesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderSharesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          findMany: {
            args: Prisma.FolderSharesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>[]
          }
          create: {
            args: Prisma.FolderSharesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          createMany: {
            args: Prisma.FolderSharesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderSharesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>[]
          }
          delete: {
            args: Prisma.FolderSharesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          update: {
            args: Prisma.FolderSharesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          deleteMany: {
            args: Prisma.FolderSharesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderSharesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderSharesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>[]
          }
          upsert: {
            args: Prisma.FolderSharesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderSharesPayload>
          }
          aggregate: {
            args: Prisma.FolderSharesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolderShares>
          }
          groupBy: {
            args: Prisma.FolderSharesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderSharesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderSharesCountArgs<ExtArgs>
            result: $Utils.Optional<FolderSharesCountAggregateOutputType> | number
          }
        }
      }
      Liked_Content: {
        payload: Prisma.$Liked_ContentPayload<ExtArgs>
        fields: Prisma.Liked_ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Liked_ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Liked_ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          findFirst: {
            args: Prisma.Liked_ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Liked_ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          findMany: {
            args: Prisma.Liked_ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>[]
          }
          create: {
            args: Prisma.Liked_ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          createMany: {
            args: Prisma.Liked_ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Liked_ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>[]
          }
          delete: {
            args: Prisma.Liked_ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          update: {
            args: Prisma.Liked_ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          deleteMany: {
            args: Prisma.Liked_ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Liked_ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Liked_ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>[]
          }
          upsert: {
            args: Prisma.Liked_ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Liked_ContentPayload>
          }
          aggregate: {
            args: Prisma.Liked_ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiked_Content>
          }
          groupBy: {
            args: Prisma.Liked_ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Liked_ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Liked_ContentCountArgs<ExtArgs>
            result: $Utils.Optional<Liked_ContentCountAggregateOutputType> | number
          }
        }
      }
      Manga: {
        payload: Prisma.$MangaPayload<ExtArgs>
        fields: Prisma.MangaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MangaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MangaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          findFirst: {
            args: Prisma.MangaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MangaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          findMany: {
            args: Prisma.MangaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>[]
          }
          create: {
            args: Prisma.MangaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          createMany: {
            args: Prisma.MangaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MangaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>[]
          }
          delete: {
            args: Prisma.MangaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          update: {
            args: Prisma.MangaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          deleteMany: {
            args: Prisma.MangaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MangaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MangaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>[]
          }
          upsert: {
            args: Prisma.MangaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MangaPayload>
          }
          aggregate: {
            args: Prisma.MangaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManga>
          }
          groupBy: {
            args: Prisma.MangaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MangaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MangaCountArgs<ExtArgs>
            result: $Utils.Optional<MangaCountAggregateOutputType> | number
          }
        }
      }
      Movies: {
        payload: Prisma.$MoviesPayload<ExtArgs>
        fields: Prisma.MoviesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoviesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoviesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          findFirst: {
            args: Prisma.MoviesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoviesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          findMany: {
            args: Prisma.MoviesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>[]
          }
          create: {
            args: Prisma.MoviesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          createMany: {
            args: Prisma.MoviesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoviesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>[]
          }
          delete: {
            args: Prisma.MoviesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          update: {
            args: Prisma.MoviesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          deleteMany: {
            args: Prisma.MoviesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoviesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoviesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>[]
          }
          upsert: {
            args: Prisma.MoviesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviesPayload>
          }
          aggregate: {
            args: Prisma.MoviesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovies>
          }
          groupBy: {
            args: Prisma.MoviesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoviesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoviesCountArgs<ExtArgs>
            result: $Utils.Optional<MoviesCountAggregateOutputType> | number
          }
        }
      }
      Polls: {
        payload: Prisma.$PollsPayload<ExtArgs>
        fields: Prisma.PollsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          findFirst: {
            args: Prisma.PollsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          findMany: {
            args: Prisma.PollsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>[]
          }
          create: {
            args: Prisma.PollsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          createMany: {
            args: Prisma.PollsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>[]
          }
          delete: {
            args: Prisma.PollsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          update: {
            args: Prisma.PollsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          deleteMany: {
            args: Prisma.PollsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PollsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>[]
          }
          upsert: {
            args: Prisma.PollsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollsPayload>
          }
          aggregate: {
            args: Prisma.PollsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolls>
          }
          groupBy: {
            args: Prisma.PollsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollsCountArgs<ExtArgs>
            result: $Utils.Optional<PollsCountAggregateOutputType> | number
          }
        }
      }
      Reviews: {
        payload: Prisma.$ReviewsPayload<ExtArgs>
        fields: Prisma.ReviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findFirst: {
            args: Prisma.ReviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          findMany: {
            args: Prisma.ReviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          create: {
            args: Prisma.ReviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          createMany: {
            args: Prisma.ReviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          delete: {
            args: Prisma.ReviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          update: {
            args: Prisma.ReviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          deleteMany: {
            args: Prisma.ReviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>[]
          }
          upsert: {
            args: Prisma.ReviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.ReviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      Shopping_Cart: {
        payload: Prisma.$Shopping_CartPayload<ExtArgs>
        fields: Prisma.Shopping_CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Shopping_CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Shopping_CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          findFirst: {
            args: Prisma.Shopping_CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Shopping_CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          findMany: {
            args: Prisma.Shopping_CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>[]
          }
          create: {
            args: Prisma.Shopping_CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          createMany: {
            args: Prisma.Shopping_CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Shopping_CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>[]
          }
          delete: {
            args: Prisma.Shopping_CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          update: {
            args: Prisma.Shopping_CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          deleteMany: {
            args: Prisma.Shopping_CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Shopping_CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Shopping_CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>[]
          }
          upsert: {
            args: Prisma.Shopping_CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Shopping_CartPayload>
          }
          aggregate: {
            args: Prisma.Shopping_CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopping_Cart>
          }
          groupBy: {
            args: Prisma.Shopping_CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shopping_CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.Shopping_CartCountArgs<ExtArgs>
            result: $Utils.Optional<Shopping_CartCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Subscription_Tiers: {
        payload: Prisma.$Subscription_TiersPayload<ExtArgs>
        fields: Prisma.Subscription_TiersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Subscription_TiersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Subscription_TiersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          findFirst: {
            args: Prisma.Subscription_TiersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Subscription_TiersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          findMany: {
            args: Prisma.Subscription_TiersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>[]
          }
          create: {
            args: Prisma.Subscription_TiersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          createMany: {
            args: Prisma.Subscription_TiersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Subscription_TiersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>[]
          }
          delete: {
            args: Prisma.Subscription_TiersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          update: {
            args: Prisma.Subscription_TiersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          deleteMany: {
            args: Prisma.Subscription_TiersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Subscription_TiersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Subscription_TiersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>[]
          }
          upsert: {
            args: Prisma.Subscription_TiersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Subscription_TiersPayload>
          }
          aggregate: {
            args: Prisma.Subscription_TiersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription_Tiers>
          }
          groupBy: {
            args: Prisma.Subscription_TiersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Subscription_TiersGroupByOutputType>[]
          }
          count: {
            args: Prisma.Subscription_TiersCountArgs<ExtArgs>
            result: $Utils.Optional<Subscription_TiersCountAggregateOutputType> | number
          }
        }
      }
      TitleTranslation: {
        payload: Prisma.$TitleTranslationPayload<ExtArgs>
        fields: Prisma.TitleTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TitleTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TitleTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          findFirst: {
            args: Prisma.TitleTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TitleTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          findMany: {
            args: Prisma.TitleTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>[]
          }
          create: {
            args: Prisma.TitleTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          createMany: {
            args: Prisma.TitleTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TitleTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>[]
          }
          delete: {
            args: Prisma.TitleTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          update: {
            args: Prisma.TitleTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          deleteMany: {
            args: Prisma.TitleTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TitleTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TitleTranslationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>[]
          }
          upsert: {
            args: Prisma.TitleTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TitleTranslationPayload>
          }
          aggregate: {
            args: Prisma.TitleTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTitleTranslation>
          }
          groupBy: {
            args: Prisma.TitleTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TitleTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TitleTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TitleTranslationCountAggregateOutputType> | number
          }
        }
      }
      User_Activity: {
        payload: Prisma.$User_ActivityPayload<ExtArgs>
        fields: Prisma.User_ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.User_ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.User_ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          findFirst: {
            args: Prisma.User_ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.User_ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          findMany: {
            args: Prisma.User_ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>[]
          }
          create: {
            args: Prisma.User_ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          createMany: {
            args: Prisma.User_ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.User_ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>[]
          }
          delete: {
            args: Prisma.User_ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          update: {
            args: Prisma.User_ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          deleteMany: {
            args: Prisma.User_ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.User_ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.User_ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>[]
          }
          upsert: {
            args: Prisma.User_ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_ActivityPayload>
          }
          aggregate: {
            args: Prisma.User_ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_Activity>
          }
          groupBy: {
            args: Prisma.User_ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.User_ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<User_ActivityCountAggregateOutputType> | number
          }
        }
      }
      User_Bookmarks: {
        payload: Prisma.$User_BookmarksPayload<ExtArgs>
        fields: Prisma.User_BookmarksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.User_BookmarksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.User_BookmarksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          findFirst: {
            args: Prisma.User_BookmarksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.User_BookmarksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          findMany: {
            args: Prisma.User_BookmarksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>[]
          }
          create: {
            args: Prisma.User_BookmarksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          createMany: {
            args: Prisma.User_BookmarksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.User_BookmarksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>[]
          }
          delete: {
            args: Prisma.User_BookmarksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          update: {
            args: Prisma.User_BookmarksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          deleteMany: {
            args: Prisma.User_BookmarksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.User_BookmarksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.User_BookmarksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>[]
          }
          upsert: {
            args: Prisma.User_BookmarksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_BookmarksPayload>
          }
          aggregate: {
            args: Prisma.User_BookmarksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_Bookmarks>
          }
          groupBy: {
            args: Prisma.User_BookmarksGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_BookmarksGroupByOutputType>[]
          }
          count: {
            args: Prisma.User_BookmarksCountArgs<ExtArgs>
            result: $Utils.Optional<User_BookmarksCountAggregateOutputType> | number
          }
        }
      }
      User_Ratings: {
        payload: Prisma.$User_RatingsPayload<ExtArgs>
        fields: Prisma.User_RatingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.User_RatingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.User_RatingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          findFirst: {
            args: Prisma.User_RatingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.User_RatingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          findMany: {
            args: Prisma.User_RatingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>[]
          }
          create: {
            args: Prisma.User_RatingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          createMany: {
            args: Prisma.User_RatingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.User_RatingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>[]
          }
          delete: {
            args: Prisma.User_RatingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          update: {
            args: Prisma.User_RatingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          deleteMany: {
            args: Prisma.User_RatingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.User_RatingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.User_RatingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>[]
          }
          upsert: {
            args: Prisma.User_RatingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$User_RatingsPayload>
          }
          aggregate: {
            args: Prisma.User_RatingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_Ratings>
          }
          groupBy: {
            args: Prisma.User_RatingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_RatingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.User_RatingsCountArgs<ExtArgs>
            result: $Utils.Optional<User_RatingsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Videos: {
        payload: Prisma.$VideosPayload<ExtArgs>
        fields: Prisma.VideosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          findFirst: {
            args: Prisma.VideosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          findMany: {
            args: Prisma.VideosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>[]
          }
          create: {
            args: Prisma.VideosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          createMany: {
            args: Prisma.VideosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>[]
          }
          delete: {
            args: Prisma.VideosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          update: {
            args: Prisma.VideosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          deleteMany: {
            args: Prisma.VideosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>[]
          }
          upsert: {
            args: Prisma.VideosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideosPayload>
          }
          aggregate: {
            args: Prisma.VideosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideos>
          }
          groupBy: {
            args: Prisma.VideosGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideosGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideosCountArgs<ExtArgs>
            result: $Utils.Optional<VideosCountAggregateOutputType> | number
          }
        }
      }
      Website_Variables: {
        payload: Prisma.$Website_VariablesPayload<ExtArgs>
        fields: Prisma.Website_VariablesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Website_VariablesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Website_VariablesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          findFirst: {
            args: Prisma.Website_VariablesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Website_VariablesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          findMany: {
            args: Prisma.Website_VariablesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>[]
          }
          create: {
            args: Prisma.Website_VariablesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          createMany: {
            args: Prisma.Website_VariablesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Website_VariablesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>[]
          }
          delete: {
            args: Prisma.Website_VariablesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          update: {
            args: Prisma.Website_VariablesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          deleteMany: {
            args: Prisma.Website_VariablesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Website_VariablesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Website_VariablesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>[]
          }
          upsert: {
            args: Prisma.Website_VariablesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Website_VariablesPayload>
          }
          aggregate: {
            args: Prisma.Website_VariablesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsite_Variables>
          }
          groupBy: {
            args: Prisma.Website_VariablesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Website_VariablesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Website_VariablesCountArgs<ExtArgs>
            result: $Utils.Optional<Website_VariablesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    anime?: AnimeOmit
    anime_Authors?: Anime_AuthorsOmit
    bookmarks?: BookmarksOmit
    comments?: CommentsOmit
    contentGroup?: ContentGroupOmit
    contentGroupMedia?: ContentGroupMediaOmit
    contentUnit?: ContentUnitOmit
    disliked_Content?: Disliked_ContentOmit
    file?: FileOmit
    fileShares?: FileSharesOmit
    folder?: FolderOmit
    folderShares?: FolderSharesOmit
    liked_Content?: Liked_ContentOmit
    manga?: MangaOmit
    movies?: MoviesOmit
    polls?: PollsOmit
    reviews?: ReviewsOmit
    shopping_Cart?: Shopping_CartOmit
    store?: StoreOmit
    subscription_Tiers?: Subscription_TiersOmit
    titleTranslation?: TitleTranslationOmit
    user_Activity?: User_ActivityOmit
    user_Bookmarks?: User_BookmarksOmit
    user_Ratings?: User_RatingsOmit
    users?: UsersOmit
    videos?: VideosOmit
    website_Variables?: Website_VariablesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AnimeCountOutputType
   */

  export type AnimeCountOutputType = {
    Anime_Authors: number
    Bookmarks: number
    ContentGroupLinks: number
  }

  export type AnimeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime_Authors?: boolean | AnimeCountOutputTypeCountAnime_AuthorsArgs
    Bookmarks?: boolean | AnimeCountOutputTypeCountBookmarksArgs
    ContentGroupLinks?: boolean | AnimeCountOutputTypeCountContentGroupLinksArgs
  }

  // Custom InputTypes
  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeCountOutputType
     */
    select?: AnimeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountAnime_AuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Anime_AuthorsWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupMediaWhereInput
  }


  /**
   * Count Type ContentGroupCountOutputType
   */

  export type ContentGroupCountOutputType = {
    ContentGroupLinks: number
  }

  export type ContentGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentGroupLinks?: boolean | ContentGroupCountOutputTypeCountContentGroupLinksArgs
  }

  // Custom InputTypes
  /**
   * ContentGroupCountOutputType without action
   */
  export type ContentGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupCountOutputType
     */
    select?: ContentGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentGroupCountOutputType without action
   */
  export type ContentGroupCountOutputTypeCountContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupMediaWhereInput
  }


  /**
   * Count Type ContentGroupMediaCountOutputType
   */

  export type ContentGroupMediaCountOutputType = {
    ContentUnits: number
  }

  export type ContentGroupMediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentUnits?: boolean | ContentGroupMediaCountOutputTypeCountContentUnitsArgs
  }

  // Custom InputTypes
  /**
   * ContentGroupMediaCountOutputType without action
   */
  export type ContentGroupMediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMediaCountOutputType
     */
    select?: ContentGroupMediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentGroupMediaCountOutputType without action
   */
  export type ContentGroupMediaCountOutputTypeCountContentUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentUnitWhereInput
  }


  /**
   * Count Type ContentUnitCountOutputType
   */

  export type ContentUnitCountOutputType = {
    Comments: number
  }

  export type ContentUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comments?: boolean | ContentUnitCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ContentUnitCountOutputType without action
   */
  export type ContentUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnitCountOutputType
     */
    select?: ContentUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentUnitCountOutputType without action
   */
  export type ContentUnitCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    FileShares: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FileShares?: boolean | FileCountOutputTypeCountFileSharesArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountFileSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileSharesWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    File: number
    other_Folder: number
    FolderShares: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | FolderCountOutputTypeCountFileArgs
    other_Folder?: boolean | FolderCountOutputTypeCountOther_FolderArgs
    FolderShares?: boolean | FolderCountOutputTypeCountFolderSharesArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountOther_FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFolderSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderSharesWhereInput
  }


  /**
   * Count Type MangaCountOutputType
   */

  export type MangaCountOutputType = {
    Anime: number
    Bookmarks: number
    ContentGroupLinks: number
  }

  export type MangaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | MangaCountOutputTypeCountAnimeArgs
    Bookmarks?: boolean | MangaCountOutputTypeCountBookmarksArgs
    ContentGroupLinks?: boolean | MangaCountOutputTypeCountContentGroupLinksArgs
  }

  // Custom InputTypes
  /**
   * MangaCountOutputType without action
   */
  export type MangaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MangaCountOutputType
     */
    select?: MangaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MangaCountOutputType without action
   */
  export type MangaCountOutputTypeCountAnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
  }

  /**
   * MangaCountOutputType without action
   */
  export type MangaCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
  }

  /**
   * MangaCountOutputType without action
   */
  export type MangaCountOutputTypeCountContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupMediaWhereInput
  }


  /**
   * Count Type MoviesCountOutputType
   */

  export type MoviesCountOutputType = {
    Bookmarks: number
    ContentGroupLinks: number
  }

  export type MoviesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookmarks?: boolean | MoviesCountOutputTypeCountBookmarksArgs
    ContentGroupLinks?: boolean | MoviesCountOutputTypeCountContentGroupLinksArgs
  }

  // Custom InputTypes
  /**
   * MoviesCountOutputType without action
   */
  export type MoviesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoviesCountOutputType
     */
    select?: MoviesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoviesCountOutputType without action
   */
  export type MoviesCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
  }

  /**
   * MoviesCountOutputType without action
   */
  export type MoviesCountOutputTypeCountContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupMediaWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    Shopping_Cart: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shopping_Cart?: boolean | StoreCountOutputTypeCountShopping_CartArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountShopping_CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Shopping_CartWhereInput
  }


  /**
   * Count Type Subscription_TiersCountOutputType
   */

  export type Subscription_TiersCountOutputType = {
    Users: number
  }

  export type Subscription_TiersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Subscription_TiersCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * Subscription_TiersCountOutputType without action
   */
  export type Subscription_TiersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_TiersCountOutputType
     */
    select?: Subscription_TiersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Subscription_TiersCountOutputType without action
   */
  export type Subscription_TiersCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Anime: number
    Anime_Authors: number
    Bookmarks: number
    Comments: number
    Disliked_Content: number
    File: number
    FileShares: number
    Folder: number
    FolderShares: number
    Liked_Content: number
    Manga: number
    Movies: number
    Polls: number
    Reviews: number
    Shopping_Cart: number
    Store: number
    User_Activity: number
    User_Bookmarks: number
    User_Ratings: number
    Videos: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | UsersCountOutputTypeCountAnimeArgs
    Anime_Authors?: boolean | UsersCountOutputTypeCountAnime_AuthorsArgs
    Bookmarks?: boolean | UsersCountOutputTypeCountBookmarksArgs
    Comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    Disliked_Content?: boolean | UsersCountOutputTypeCountDisliked_ContentArgs
    File?: boolean | UsersCountOutputTypeCountFileArgs
    FileShares?: boolean | UsersCountOutputTypeCountFileSharesArgs
    Folder?: boolean | UsersCountOutputTypeCountFolderArgs
    FolderShares?: boolean | UsersCountOutputTypeCountFolderSharesArgs
    Liked_Content?: boolean | UsersCountOutputTypeCountLiked_ContentArgs
    Manga?: boolean | UsersCountOutputTypeCountMangaArgs
    Movies?: boolean | UsersCountOutputTypeCountMoviesArgs
    Polls?: boolean | UsersCountOutputTypeCountPollsArgs
    Reviews?: boolean | UsersCountOutputTypeCountReviewsArgs
    Shopping_Cart?: boolean | UsersCountOutputTypeCountShopping_CartArgs
    Store?: boolean | UsersCountOutputTypeCountStoreArgs
    User_Activity?: boolean | UsersCountOutputTypeCountUser_ActivityArgs
    User_Bookmarks?: boolean | UsersCountOutputTypeCountUser_BookmarksArgs
    User_Ratings?: boolean | UsersCountOutputTypeCountUser_RatingsArgs
    Videos?: boolean | UsersCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnime_AuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Anime_AuthorsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDisliked_ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Disliked_ContentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFileSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileSharesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFolderSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderSharesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLiked_ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Liked_ContentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMangaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MangaWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoviesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountShopping_CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Shopping_CartWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_ActivityWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_BookmarksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_RatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_RatingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideosWhereInput
  }


  /**
   * Count Type VideosCountOutputType
   */

  export type VideosCountOutputType = {
    Anime: number
    Bookmarks: number
    Comments: number
  }

  export type VideosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | VideosCountOutputTypeCountAnimeArgs
    Bookmarks?: boolean | VideosCountOutputTypeCountBookmarksArgs
    Comments?: boolean | VideosCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideosCountOutputType
     */
    select?: VideosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeCountAnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
  }

  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
  }

  /**
   * VideosCountOutputType without action
   */
  export type VideosCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Anime
   */

  export type AggregateAnime = {
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  export type AnimeAvgAggregateOutputType = {
    likes: number | null
    dislikes: number | null
    activity: number | null
    average_rating: number | null
    anime_ratings: number | null
  }

  export type AnimeSumAggregateOutputType = {
    likes: bigint | null
    dislikes: bigint | null
    activity: number | null
    average_rating: number | null
    anime_ratings: number | null
  }

  export type AnimeMinAggregateOutputType = {
    animeid: string | null
    description: string | null
    trailerid: string | null
    upload_date: Date | null
    release_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
    activity: number | null
    authorid: string | null
    average_rating: number | null
    anime_ratings: number | null
    age_rating: $Enums.AgeRating | null
    mangaid: string | null
    title: string | null
    type: $Enums.MediaType | null
    anime_key_visual: string | null
    visible: boolean | null
  }

  export type AnimeMaxAggregateOutputType = {
    animeid: string | null
    description: string | null
    trailerid: string | null
    upload_date: Date | null
    release_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
    activity: number | null
    authorid: string | null
    average_rating: number | null
    anime_ratings: number | null
    age_rating: $Enums.AgeRating | null
    mangaid: string | null
    title: string | null
    type: $Enums.MediaType | null
    anime_key_visual: string | null
    visible: boolean | null
  }

  export type AnimeCountAggregateOutputType = {
    animeid: number
    description: number
    trailerid: number
    upload_date: number
    release_date: number
    likes: number
    dislikes: number
    activity: number
    authorid: number
    average_rating: number
    anime_ratings: number
    age_rating: number
    mangaid: number
    title: number
    type: number
    MediaGenre: number
    anime_key_visual: number
    visible: number
    _all: number
  }


  export type AnimeAvgAggregateInputType = {
    likes?: true
    dislikes?: true
    activity?: true
    average_rating?: true
    anime_ratings?: true
  }

  export type AnimeSumAggregateInputType = {
    likes?: true
    dislikes?: true
    activity?: true
    average_rating?: true
    anime_ratings?: true
  }

  export type AnimeMinAggregateInputType = {
    animeid?: true
    description?: true
    trailerid?: true
    upload_date?: true
    release_date?: true
    likes?: true
    dislikes?: true
    activity?: true
    authorid?: true
    average_rating?: true
    anime_ratings?: true
    age_rating?: true
    mangaid?: true
    title?: true
    type?: true
    anime_key_visual?: true
    visible?: true
  }

  export type AnimeMaxAggregateInputType = {
    animeid?: true
    description?: true
    trailerid?: true
    upload_date?: true
    release_date?: true
    likes?: true
    dislikes?: true
    activity?: true
    authorid?: true
    average_rating?: true
    anime_ratings?: true
    age_rating?: true
    mangaid?: true
    title?: true
    type?: true
    anime_key_visual?: true
    visible?: true
  }

  export type AnimeCountAggregateInputType = {
    animeid?: true
    description?: true
    trailerid?: true
    upload_date?: true
    release_date?: true
    likes?: true
    dislikes?: true
    activity?: true
    authorid?: true
    average_rating?: true
    anime_ratings?: true
    age_rating?: true
    mangaid?: true
    title?: true
    type?: true
    MediaGenre?: true
    anime_key_visual?: true
    visible?: true
    _all?: true
  }

  export type AnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime to aggregate.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anime
    **/
    _count?: true | AnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimeMaxAggregateInputType
  }

  export type GetAnimeAggregateType<T extends AnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnime[P]>
      : GetScalarType<T[P], AggregateAnime[P]>
  }




  export type AnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithAggregationInput | AnimeOrderByWithAggregationInput[]
    by: AnimeScalarFieldEnum[] | AnimeScalarFieldEnum
    having?: AnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimeCountAggregateInputType | true
    _avg?: AnimeAvgAggregateInputType
    _sum?: AnimeSumAggregateInputType
    _min?: AnimeMinAggregateInputType
    _max?: AnimeMaxAggregateInputType
  }

  export type AnimeGroupByOutputType = {
    animeid: string
    description: string | null
    trailerid: string | null
    upload_date: Date | null
    release_date: Date
    likes: bigint
    dislikes: bigint
    activity: number
    authorid: string
    average_rating: number
    anime_ratings: number
    age_rating: $Enums.AgeRating
    mangaid: string | null
    title: string
    type: $Enums.MediaType
    MediaGenre: $Enums.MediaGenre[]
    anime_key_visual: string | null
    visible: boolean
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  type GetAnimeGroupByPayload<T extends AnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimeGroupByOutputType[P]>
            : GetScalarType<T[P], AnimeGroupByOutputType[P]>
        }
      >
    >


  export type AnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    description?: boolean
    trailerid?: boolean
    upload_date?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    activity?: boolean
    authorid?: boolean
    average_rating?: boolean
    anime_ratings?: boolean
    age_rating?: boolean
    mangaid?: boolean
    title?: boolean
    type?: boolean
    MediaGenre?: boolean
    anime_key_visual?: boolean
    visible?: boolean
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Anime_Authors?: boolean | Anime$Anime_AuthorsArgs<ExtArgs>
    Bookmarks?: boolean | Anime$BookmarksArgs<ExtArgs>
    ContentGroupLinks?: boolean | Anime$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | AnimeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    description?: boolean
    trailerid?: boolean
    upload_date?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    activity?: boolean
    authorid?: boolean
    average_rating?: boolean
    anime_ratings?: boolean
    age_rating?: boolean
    mangaid?: boolean
    title?: boolean
    type?: boolean
    MediaGenre?: boolean
    anime_key_visual?: boolean
    visible?: boolean
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    description?: boolean
    trailerid?: boolean
    upload_date?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    activity?: boolean
    authorid?: boolean
    average_rating?: boolean
    anime_ratings?: boolean
    age_rating?: boolean
    mangaid?: boolean
    title?: boolean
    type?: boolean
    MediaGenre?: boolean
    anime_key_visual?: boolean
    visible?: boolean
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectScalar = {
    animeid?: boolean
    description?: boolean
    trailerid?: boolean
    upload_date?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    activity?: boolean
    authorid?: boolean
    average_rating?: boolean
    anime_ratings?: boolean
    age_rating?: boolean
    mangaid?: boolean
    title?: boolean
    type?: boolean
    MediaGenre?: boolean
    anime_key_visual?: boolean
    visible?: boolean
  }

  export type AnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeid" | "description" | "trailerid" | "upload_date" | "release_date" | "likes" | "dislikes" | "activity" | "authorid" | "average_rating" | "anime_ratings" | "age_rating" | "mangaid" | "title" | "type" | "MediaGenre" | "anime_key_visual" | "visible", ExtArgs["result"]["anime"]>
  export type AnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Anime_Authors?: boolean | Anime$Anime_AuthorsArgs<ExtArgs>
    Bookmarks?: boolean | Anime$BookmarksArgs<ExtArgs>
    ContentGroupLinks?: boolean | Anime$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | AnimeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type AnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Manga?: boolean | Anime$MangaArgs<ExtArgs>
    Videos?: boolean | Anime$VideosArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $AnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Anime"
    objects: {
      Manga: Prisma.$MangaPayload<ExtArgs> | null
      Videos: Prisma.$VideosPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs>
      Anime_Authors: Prisma.$Anime_AuthorsPayload<ExtArgs>[]
      Bookmarks: Prisma.$BookmarksPayload<ExtArgs>[]
      ContentGroupLinks: Prisma.$ContentGroupMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      animeid: string
      description: string | null
      trailerid: string | null
      upload_date: Date | null
      release_date: Date
      likes: bigint
      dislikes: bigint
      activity: number
      authorid: string
      average_rating: number
      anime_ratings: number
      age_rating: $Enums.AgeRating
      mangaid: string | null
      title: string
      type: $Enums.MediaType
      MediaGenre: $Enums.MediaGenre[]
      anime_key_visual: string | null
      visible: boolean
    }, ExtArgs["result"]["anime"]>
    composites: {}
  }

  type AnimeGetPayload<S extends boolean | null | undefined | AnimeDefaultArgs> = $Result.GetResult<Prisma.$AnimePayload, S>

  type AnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimeCountAggregateInputType | true
    }

  export interface AnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anime'], meta: { name: 'Anime' } }
    /**
     * Find zero or one Anime that matches the filter.
     * @param {AnimeFindUniqueArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimeFindUniqueArgs>(args: SelectSubset<T, AnimeFindUniqueArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Anime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimeFindUniqueOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindFirstArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimeFindFirstArgs>(args?: SelectSubset<T, AnimeFindFirstArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindFirstOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anime
     * const anime = await prisma.anime.findMany()
     * 
     * // Get first 10 Anime
     * const anime = await prisma.anime.findMany({ take: 10 })
     * 
     * // Only select the `animeid`
     * const animeWithAnimeidOnly = await prisma.anime.findMany({ select: { animeid: true } })
     * 
     */
    findMany<T extends AnimeFindManyArgs>(args?: SelectSubset<T, AnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Anime.
     * @param {AnimeCreateArgs} args - Arguments to create a Anime.
     * @example
     * // Create one Anime
     * const Anime = await prisma.anime.create({
     *   data: {
     *     // ... data to create a Anime
     *   }
     * })
     * 
     */
    create<T extends AnimeCreateArgs>(args: SelectSubset<T, AnimeCreateArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Anime.
     * @param {AnimeCreateManyArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimeCreateManyArgs>(args?: SelectSubset<T, AnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anime and returns the data saved in the database.
     * @param {AnimeCreateManyAndReturnArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anime and only return the `animeid`
     * const animeWithAnimeidOnly = await prisma.anime.createManyAndReturn({
     *   select: { animeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Anime.
     * @param {AnimeDeleteArgs} args - Arguments to delete one Anime.
     * @example
     * // Delete one Anime
     * const Anime = await prisma.anime.delete({
     *   where: {
     *     // ... filter to delete one Anime
     *   }
     * })
     * 
     */
    delete<T extends AnimeDeleteArgs>(args: SelectSubset<T, AnimeDeleteArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Anime.
     * @param {AnimeUpdateArgs} args - Arguments to update one Anime.
     * @example
     * // Update one Anime
     * const anime = await prisma.anime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimeUpdateArgs>(args: SelectSubset<T, AnimeUpdateArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Anime.
     * @param {AnimeDeleteManyArgs} args - Arguments to filter Anime to delete.
     * @example
     * // Delete a few Anime
     * const { count } = await prisma.anime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimeDeleteManyArgs>(args?: SelectSubset<T, AnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anime
     * const anime = await prisma.anime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimeUpdateManyArgs>(args: SelectSubset<T, AnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime and returns the data updated in the database.
     * @param {AnimeUpdateManyAndReturnArgs} args - Arguments to update many Anime.
     * @example
     * // Update many Anime
     * const anime = await prisma.anime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Anime and only return the `animeid`
     * const animeWithAnimeidOnly = await prisma.anime.updateManyAndReturn({
     *   select: { animeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Anime.
     * @param {AnimeUpsertArgs} args - Arguments to update or create a Anime.
     * @example
     * // Update or create a Anime
     * const anime = await prisma.anime.upsert({
     *   create: {
     *     // ... data to create a Anime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anime we want to update
     *   }
     * })
     */
    upsert<T extends AnimeUpsertArgs>(args: SelectSubset<T, AnimeUpsertArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeCountArgs} args - Arguments to filter Anime to count.
     * @example
     * // Count the number of Anime
     * const count = await prisma.anime.count({
     *   where: {
     *     // ... the filter for the Anime we want to count
     *   }
     * })
    **/
    count<T extends AnimeCountArgs>(
      args?: Subset<T, AnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimeAggregateArgs>(args: Subset<T, AnimeAggregateArgs>): Prisma.PrismaPromise<GetAnimeAggregateType<T>>

    /**
     * Group by Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimeGroupByArgs['orderBy'] }
        : { orderBy?: AnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anime model
   */
  readonly fields: AnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Manga<T extends Anime$MangaArgs<ExtArgs> = {}>(args?: Subset<T, Anime$MangaArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Videos<T extends Anime$VideosArgs<ExtArgs> = {}>(args?: Subset<T, Anime$VideosArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Anime_Authors<T extends Anime$Anime_AuthorsArgs<ExtArgs> = {}>(args?: Subset<T, Anime$Anime_AuthorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bookmarks<T extends Anime$BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Anime$BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContentGroupLinks<T extends Anime$ContentGroupLinksArgs<ExtArgs> = {}>(args?: Subset<T, Anime$ContentGroupLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Anime model
   */ 
  interface AnimeFieldRefs {
    readonly animeid: FieldRef<"Anime", 'String'>
    readonly description: FieldRef<"Anime", 'String'>
    readonly trailerid: FieldRef<"Anime", 'String'>
    readonly upload_date: FieldRef<"Anime", 'DateTime'>
    readonly release_date: FieldRef<"Anime", 'DateTime'>
    readonly likes: FieldRef<"Anime", 'BigInt'>
    readonly dislikes: FieldRef<"Anime", 'BigInt'>
    readonly activity: FieldRef<"Anime", 'Int'>
    readonly authorid: FieldRef<"Anime", 'String'>
    readonly average_rating: FieldRef<"Anime", 'Float'>
    readonly anime_ratings: FieldRef<"Anime", 'Int'>
    readonly age_rating: FieldRef<"Anime", 'AgeRating'>
    readonly mangaid: FieldRef<"Anime", 'String'>
    readonly title: FieldRef<"Anime", 'String'>
    readonly type: FieldRef<"Anime", 'MediaType'>
    readonly MediaGenre: FieldRef<"Anime", 'MediaGenre[]'>
    readonly anime_key_visual: FieldRef<"Anime", 'String'>
    readonly visible: FieldRef<"Anime", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Anime findUnique
   */
  export type AnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime findUniqueOrThrow
   */
  export type AnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime findFirst
   */
  export type AnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime findFirstOrThrow
   */
  export type AnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime findMany
   */
  export type AnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime create
   */
  export type AnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Anime.
     */
    data: XOR<AnimeCreateInput, AnimeUncheckedCreateInput>
  }

  /**
   * Anime createMany
   */
  export type AnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anime.
     */
    data: AnimeCreateManyInput | AnimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Anime createManyAndReturn
   */
  export type AnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * The data used to create many Anime.
     */
    data: AnimeCreateManyInput | AnimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime update
   */
  export type AnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Anime.
     */
    data: XOR<AnimeUpdateInput, AnimeUncheckedUpdateInput>
    /**
     * Choose, which Anime to update.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime updateMany
   */
  export type AnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anime.
     */
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyInput>
    /**
     * Filter which Anime to update
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to update.
     */
    limit?: number
  }

  /**
   * Anime updateManyAndReturn
   */
  export type AnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * The data used to update Anime.
     */
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyInput>
    /**
     * Filter which Anime to update
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime upsert
   */
  export type AnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Anime to update in case it exists.
     */
    where: AnimeWhereUniqueInput
    /**
     * In case the Anime found by the `where` argument doesn't exist, create a new Anime with this data.
     */
    create: XOR<AnimeCreateInput, AnimeUncheckedCreateInput>
    /**
     * In case the Anime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimeUpdateInput, AnimeUncheckedUpdateInput>
  }

  /**
   * Anime delete
   */
  export type AnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter which Anime to delete.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime deleteMany
   */
  export type AnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime to delete
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to delete.
     */
    limit?: number
  }

  /**
   * Anime.Manga
   */
  export type Anime$MangaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    where?: MangaWhereInput
  }

  /**
   * Anime.Videos
   */
  export type Anime$VideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    where?: VideosWhereInput
  }

  /**
   * Anime.Anime_Authors
   */
  export type Anime$Anime_AuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    where?: Anime_AuthorsWhereInput
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    cursor?: Anime_AuthorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Anime_AuthorsScalarFieldEnum | Anime_AuthorsScalarFieldEnum[]
  }

  /**
   * Anime.Bookmarks
   */
  export type Anime$BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    cursor?: BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Anime.ContentGroupLinks
   */
  export type Anime$ContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    where?: ContentGroupMediaWhereInput
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    cursor?: ContentGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * Anime without action
   */
  export type AnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
  }


  /**
   * Model Anime_Authors
   */

  export type AggregateAnime_Authors = {
    _count: Anime_AuthorsCountAggregateOutputType | null
    _min: Anime_AuthorsMinAggregateOutputType | null
    _max: Anime_AuthorsMaxAggregateOutputType | null
  }

  export type Anime_AuthorsMinAggregateOutputType = {
    animeid: string | null
    authorid: string | null
  }

  export type Anime_AuthorsMaxAggregateOutputType = {
    animeid: string | null
    authorid: string | null
  }

  export type Anime_AuthorsCountAggregateOutputType = {
    animeid: number
    authorid: number
    _all: number
  }


  export type Anime_AuthorsMinAggregateInputType = {
    animeid?: true
    authorid?: true
  }

  export type Anime_AuthorsMaxAggregateInputType = {
    animeid?: true
    authorid?: true
  }

  export type Anime_AuthorsCountAggregateInputType = {
    animeid?: true
    authorid?: true
    _all?: true
  }

  export type Anime_AuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime_Authors to aggregate.
     */
    where?: Anime_AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime_Authors to fetch.
     */
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Anime_AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime_Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime_Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anime_Authors
    **/
    _count?: true | Anime_AuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Anime_AuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Anime_AuthorsMaxAggregateInputType
  }

  export type GetAnime_AuthorsAggregateType<T extends Anime_AuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnime_Authors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnime_Authors[P]>
      : GetScalarType<T[P], AggregateAnime_Authors[P]>
  }




  export type Anime_AuthorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Anime_AuthorsWhereInput
    orderBy?: Anime_AuthorsOrderByWithAggregationInput | Anime_AuthorsOrderByWithAggregationInput[]
    by: Anime_AuthorsScalarFieldEnum[] | Anime_AuthorsScalarFieldEnum
    having?: Anime_AuthorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Anime_AuthorsCountAggregateInputType | true
    _min?: Anime_AuthorsMinAggregateInputType
    _max?: Anime_AuthorsMaxAggregateInputType
  }

  export type Anime_AuthorsGroupByOutputType = {
    animeid: string
    authorid: string
    _count: Anime_AuthorsCountAggregateOutputType | null
    _min: Anime_AuthorsMinAggregateOutputType | null
    _max: Anime_AuthorsMaxAggregateOutputType | null
  }

  type GetAnime_AuthorsGroupByPayload<T extends Anime_AuthorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Anime_AuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Anime_AuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Anime_AuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], Anime_AuthorsGroupByOutputType[P]>
        }
      >
    >


  export type Anime_AuthorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    authorid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime_Authors"]>

  export type Anime_AuthorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    authorid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime_Authors"]>

  export type Anime_AuthorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeid?: boolean
    authorid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime_Authors"]>

  export type Anime_AuthorsSelectScalar = {
    animeid?: boolean
    authorid?: boolean
  }

  export type Anime_AuthorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeid" | "authorid", ExtArgs["result"]["anime_Authors"]>
  export type Anime_AuthorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Anime_AuthorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Anime_AuthorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $Anime_AuthorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Anime_Authors"
    objects: {
      Anime: Prisma.$AnimePayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeid: string
      authorid: string
    }, ExtArgs["result"]["anime_Authors"]>
    composites: {}
  }

  type Anime_AuthorsGetPayload<S extends boolean | null | undefined | Anime_AuthorsDefaultArgs> = $Result.GetResult<Prisma.$Anime_AuthorsPayload, S>

  type Anime_AuthorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Anime_AuthorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Anime_AuthorsCountAggregateInputType | true
    }

  export interface Anime_AuthorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anime_Authors'], meta: { name: 'Anime_Authors' } }
    /**
     * Find zero or one Anime_Authors that matches the filter.
     * @param {Anime_AuthorsFindUniqueArgs} args - Arguments to find a Anime_Authors
     * @example
     * // Get one Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Anime_AuthorsFindUniqueArgs>(args: SelectSubset<T, Anime_AuthorsFindUniqueArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Anime_Authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Anime_AuthorsFindUniqueOrThrowArgs} args - Arguments to find a Anime_Authors
     * @example
     * // Get one Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Anime_AuthorsFindUniqueOrThrowArgs>(args: SelectSubset<T, Anime_AuthorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime_Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsFindFirstArgs} args - Arguments to find a Anime_Authors
     * @example
     * // Get one Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Anime_AuthorsFindFirstArgs>(args?: SelectSubset<T, Anime_AuthorsFindFirstArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime_Authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsFindFirstOrThrowArgs} args - Arguments to find a Anime_Authors
     * @example
     * // Get one Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Anime_AuthorsFindFirstOrThrowArgs>(args?: SelectSubset<T, Anime_AuthorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Anime_Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findMany()
     * 
     * // Get first 10 Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.findMany({ take: 10 })
     * 
     * // Only select the `animeid`
     * const anime_AuthorsWithAnimeidOnly = await prisma.anime_Authors.findMany({ select: { animeid: true } })
     * 
     */
    findMany<T extends Anime_AuthorsFindManyArgs>(args?: SelectSubset<T, Anime_AuthorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Anime_Authors.
     * @param {Anime_AuthorsCreateArgs} args - Arguments to create a Anime_Authors.
     * @example
     * // Create one Anime_Authors
     * const Anime_Authors = await prisma.anime_Authors.create({
     *   data: {
     *     // ... data to create a Anime_Authors
     *   }
     * })
     * 
     */
    create<T extends Anime_AuthorsCreateArgs>(args: SelectSubset<T, Anime_AuthorsCreateArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Anime_Authors.
     * @param {Anime_AuthorsCreateManyArgs} args - Arguments to create many Anime_Authors.
     * @example
     * // Create many Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Anime_AuthorsCreateManyArgs>(args?: SelectSubset<T, Anime_AuthorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anime_Authors and returns the data saved in the database.
     * @param {Anime_AuthorsCreateManyAndReturnArgs} args - Arguments to create many Anime_Authors.
     * @example
     * // Create many Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anime_Authors and only return the `animeid`
     * const anime_AuthorsWithAnimeidOnly = await prisma.anime_Authors.createManyAndReturn({
     *   select: { animeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Anime_AuthorsCreateManyAndReturnArgs>(args?: SelectSubset<T, Anime_AuthorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Anime_Authors.
     * @param {Anime_AuthorsDeleteArgs} args - Arguments to delete one Anime_Authors.
     * @example
     * // Delete one Anime_Authors
     * const Anime_Authors = await prisma.anime_Authors.delete({
     *   where: {
     *     // ... filter to delete one Anime_Authors
     *   }
     * })
     * 
     */
    delete<T extends Anime_AuthorsDeleteArgs>(args: SelectSubset<T, Anime_AuthorsDeleteArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Anime_Authors.
     * @param {Anime_AuthorsUpdateArgs} args - Arguments to update one Anime_Authors.
     * @example
     * // Update one Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Anime_AuthorsUpdateArgs>(args: SelectSubset<T, Anime_AuthorsUpdateArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Anime_Authors.
     * @param {Anime_AuthorsDeleteManyArgs} args - Arguments to filter Anime_Authors to delete.
     * @example
     * // Delete a few Anime_Authors
     * const { count } = await prisma.anime_Authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Anime_AuthorsDeleteManyArgs>(args?: SelectSubset<T, Anime_AuthorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime_Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Anime_AuthorsUpdateManyArgs>(args: SelectSubset<T, Anime_AuthorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime_Authors and returns the data updated in the database.
     * @param {Anime_AuthorsUpdateManyAndReturnArgs} args - Arguments to update many Anime_Authors.
     * @example
     * // Update many Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Anime_Authors and only return the `animeid`
     * const anime_AuthorsWithAnimeidOnly = await prisma.anime_Authors.updateManyAndReturn({
     *   select: { animeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Anime_AuthorsUpdateManyAndReturnArgs>(args: SelectSubset<T, Anime_AuthorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Anime_Authors.
     * @param {Anime_AuthorsUpsertArgs} args - Arguments to update or create a Anime_Authors.
     * @example
     * // Update or create a Anime_Authors
     * const anime_Authors = await prisma.anime_Authors.upsert({
     *   create: {
     *     // ... data to create a Anime_Authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anime_Authors we want to update
     *   }
     * })
     */
    upsert<T extends Anime_AuthorsUpsertArgs>(args: SelectSubset<T, Anime_AuthorsUpsertArgs<ExtArgs>>): Prisma__Anime_AuthorsClient<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Anime_Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsCountArgs} args - Arguments to filter Anime_Authors to count.
     * @example
     * // Count the number of Anime_Authors
     * const count = await prisma.anime_Authors.count({
     *   where: {
     *     // ... the filter for the Anime_Authors we want to count
     *   }
     * })
    **/
    count<T extends Anime_AuthorsCountArgs>(
      args?: Subset<T, Anime_AuthorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Anime_AuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anime_Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Anime_AuthorsAggregateArgs>(args: Subset<T, Anime_AuthorsAggregateArgs>): Prisma.PrismaPromise<GetAnime_AuthorsAggregateType<T>>

    /**
     * Group by Anime_Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anime_AuthorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Anime_AuthorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Anime_AuthorsGroupByArgs['orderBy'] }
        : { orderBy?: Anime_AuthorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Anime_AuthorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnime_AuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anime_Authors model
   */
  readonly fields: Anime_AuthorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anime_Authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Anime_AuthorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Anime_Authors model
   */ 
  interface Anime_AuthorsFieldRefs {
    readonly animeid: FieldRef<"Anime_Authors", 'String'>
    readonly authorid: FieldRef<"Anime_Authors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Anime_Authors findUnique
   */
  export type Anime_AuthorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Anime_Authors to fetch.
     */
    where: Anime_AuthorsWhereUniqueInput
  }

  /**
   * Anime_Authors findUniqueOrThrow
   */
  export type Anime_AuthorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Anime_Authors to fetch.
     */
    where: Anime_AuthorsWhereUniqueInput
  }

  /**
   * Anime_Authors findFirst
   */
  export type Anime_AuthorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Anime_Authors to fetch.
     */
    where?: Anime_AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime_Authors to fetch.
     */
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime_Authors.
     */
    cursor?: Anime_AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime_Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime_Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime_Authors.
     */
    distinct?: Anime_AuthorsScalarFieldEnum | Anime_AuthorsScalarFieldEnum[]
  }

  /**
   * Anime_Authors findFirstOrThrow
   */
  export type Anime_AuthorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Anime_Authors to fetch.
     */
    where?: Anime_AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime_Authors to fetch.
     */
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime_Authors.
     */
    cursor?: Anime_AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime_Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime_Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime_Authors.
     */
    distinct?: Anime_AuthorsScalarFieldEnum | Anime_AuthorsScalarFieldEnum[]
  }

  /**
   * Anime_Authors findMany
   */
  export type Anime_AuthorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter, which Anime_Authors to fetch.
     */
    where?: Anime_AuthorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime_Authors to fetch.
     */
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anime_Authors.
     */
    cursor?: Anime_AuthorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime_Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime_Authors.
     */
    skip?: number
    distinct?: Anime_AuthorsScalarFieldEnum | Anime_AuthorsScalarFieldEnum[]
  }

  /**
   * Anime_Authors create
   */
  export type Anime_AuthorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Anime_Authors.
     */
    data: XOR<Anime_AuthorsCreateInput, Anime_AuthorsUncheckedCreateInput>
  }

  /**
   * Anime_Authors createMany
   */
  export type Anime_AuthorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anime_Authors.
     */
    data: Anime_AuthorsCreateManyInput | Anime_AuthorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Anime_Authors createManyAndReturn
   */
  export type Anime_AuthorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * The data used to create many Anime_Authors.
     */
    data: Anime_AuthorsCreateManyInput | Anime_AuthorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime_Authors update
   */
  export type Anime_AuthorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Anime_Authors.
     */
    data: XOR<Anime_AuthorsUpdateInput, Anime_AuthorsUncheckedUpdateInput>
    /**
     * Choose, which Anime_Authors to update.
     */
    where: Anime_AuthorsWhereUniqueInput
  }

  /**
   * Anime_Authors updateMany
   */
  export type Anime_AuthorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anime_Authors.
     */
    data: XOR<Anime_AuthorsUpdateManyMutationInput, Anime_AuthorsUncheckedUpdateManyInput>
    /**
     * Filter which Anime_Authors to update
     */
    where?: Anime_AuthorsWhereInput
    /**
     * Limit how many Anime_Authors to update.
     */
    limit?: number
  }

  /**
   * Anime_Authors updateManyAndReturn
   */
  export type Anime_AuthorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * The data used to update Anime_Authors.
     */
    data: XOR<Anime_AuthorsUpdateManyMutationInput, Anime_AuthorsUncheckedUpdateManyInput>
    /**
     * Filter which Anime_Authors to update
     */
    where?: Anime_AuthorsWhereInput
    /**
     * Limit how many Anime_Authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime_Authors upsert
   */
  export type Anime_AuthorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Anime_Authors to update in case it exists.
     */
    where: Anime_AuthorsWhereUniqueInput
    /**
     * In case the Anime_Authors found by the `where` argument doesn't exist, create a new Anime_Authors with this data.
     */
    create: XOR<Anime_AuthorsCreateInput, Anime_AuthorsUncheckedCreateInput>
    /**
     * In case the Anime_Authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Anime_AuthorsUpdateInput, Anime_AuthorsUncheckedUpdateInput>
  }

  /**
   * Anime_Authors delete
   */
  export type Anime_AuthorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    /**
     * Filter which Anime_Authors to delete.
     */
    where: Anime_AuthorsWhereUniqueInput
  }

  /**
   * Anime_Authors deleteMany
   */
  export type Anime_AuthorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime_Authors to delete
     */
    where?: Anime_AuthorsWhereInput
    /**
     * Limit how many Anime_Authors to delete.
     */
    limit?: number
  }

  /**
   * Anime_Authors without action
   */
  export type Anime_AuthorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
  }


  /**
   * Model Bookmarks
   */

  export type AggregateBookmarks = {
    _count: BookmarksCountAggregateOutputType | null
    _min: BookmarksMinAggregateOutputType | null
    _max: BookmarksMaxAggregateOutputType | null
  }

  export type BookmarksMinAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    parentid: string | null
  }

  export type BookmarksMaxAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    parentid: string | null
  }

  export type BookmarksCountAggregateOutputType = {
    userid: number
    mediatype: number
    parentid: number
    _all: number
  }


  export type BookmarksMinAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
  }

  export type BookmarksMaxAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
  }

  export type BookmarksCountAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
    _all?: true
  }

  export type BookmarksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to aggregate.
     */
    where?: BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarksMaxAggregateInputType
  }

  export type GetBookmarksAggregateType<T extends BookmarksAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmarks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmarks[P]>
      : GetScalarType<T[P], AggregateBookmarks[P]>
  }




  export type BookmarksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithAggregationInput | BookmarksOrderByWithAggregationInput[]
    by: BookmarksScalarFieldEnum[] | BookmarksScalarFieldEnum
    having?: BookmarksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarksCountAggregateInputType | true
    _min?: BookmarksMinAggregateInputType
    _max?: BookmarksMaxAggregateInputType
  }

  export type BookmarksGroupByOutputType = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
    _count: BookmarksCountAggregateOutputType | null
    _min: BookmarksMinAggregateOutputType | null
    _max: BookmarksMaxAggregateOutputType | null
  }

  type GetBookmarksGroupByPayload<T extends BookmarksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarksGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarksGroupByOutputType[P]>
        }
      >
    >


  export type BookmarksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarks"]>

  export type BookmarksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarks"]>

  export type BookmarksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarks"]>

  export type BookmarksSelectScalar = {
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
  }

  export type BookmarksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "mediatype" | "parentid", ExtArgs["result"]["bookmarks"]>
  export type BookmarksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type BookmarksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type BookmarksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | AnimeDefaultArgs<ExtArgs>
    Manga?: boolean | MangaDefaultArgs<ExtArgs>
    Movies?: boolean | MoviesDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $BookmarksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmarks"
    objects: {
      Anime: Prisma.$AnimePayload<ExtArgs>
      Manga: Prisma.$MangaPayload<ExtArgs>
      Movies: Prisma.$MoviesPayload<ExtArgs>
      Videos: Prisma.$VideosPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      mediatype: $Enums.MediaType
      parentid: string
    }, ExtArgs["result"]["bookmarks"]>
    composites: {}
  }

  type BookmarksGetPayload<S extends boolean | null | undefined | BookmarksDefaultArgs> = $Result.GetResult<Prisma.$BookmarksPayload, S>

  type BookmarksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarksCountAggregateInputType | true
    }

  export interface BookmarksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmarks'], meta: { name: 'Bookmarks' } }
    /**
     * Find zero or one Bookmarks that matches the filter.
     * @param {BookmarksFindUniqueArgs} args - Arguments to find a Bookmarks
     * @example
     * // Get one Bookmarks
     * const bookmarks = await prisma.bookmarks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarksFindUniqueArgs>(args: SelectSubset<T, BookmarksFindUniqueArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookmarks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarksFindUniqueOrThrowArgs} args - Arguments to find a Bookmarks
     * @example
     * // Get one Bookmarks
     * const bookmarks = await prisma.bookmarks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarksFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksFindFirstArgs} args - Arguments to find a Bookmarks
     * @example
     * // Get one Bookmarks
     * const bookmarks = await prisma.bookmarks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarksFindFirstArgs>(args?: SelectSubset<T, BookmarksFindFirstArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmarks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksFindFirstOrThrowArgs} args - Arguments to find a Bookmarks
     * @example
     * // Get one Bookmarks
     * const bookmarks = await prisma.bookmarks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarksFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarksFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmarks.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmarks.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const bookmarksWithUseridOnly = await prisma.bookmarks.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends BookmarksFindManyArgs>(args?: SelectSubset<T, BookmarksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookmarks.
     * @param {BookmarksCreateArgs} args - Arguments to create a Bookmarks.
     * @example
     * // Create one Bookmarks
     * const Bookmarks = await prisma.bookmarks.create({
     *   data: {
     *     // ... data to create a Bookmarks
     *   }
     * })
     * 
     */
    create<T extends BookmarksCreateArgs>(args: SelectSubset<T, BookmarksCreateArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookmarks.
     * @param {BookmarksCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmarks = await prisma.bookmarks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarksCreateManyArgs>(args?: SelectSubset<T, BookmarksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookmarks and returns the data saved in the database.
     * @param {BookmarksCreateManyAndReturnArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmarks = await prisma.bookmarks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookmarks and only return the `userid`
     * const bookmarksWithUseridOnly = await prisma.bookmarks.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarksCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bookmarks.
     * @param {BookmarksDeleteArgs} args - Arguments to delete one Bookmarks.
     * @example
     * // Delete one Bookmarks
     * const Bookmarks = await prisma.bookmarks.delete({
     *   where: {
     *     // ... filter to delete one Bookmarks
     *   }
     * })
     * 
     */
    delete<T extends BookmarksDeleteArgs>(args: SelectSubset<T, BookmarksDeleteArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookmarks.
     * @param {BookmarksUpdateArgs} args - Arguments to update one Bookmarks.
     * @example
     * // Update one Bookmarks
     * const bookmarks = await prisma.bookmarks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarksUpdateArgs>(args: SelectSubset<T, BookmarksUpdateArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarksDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmarks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarksDeleteManyArgs>(args?: SelectSubset<T, BookmarksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmarks = await prisma.bookmarks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarksUpdateManyArgs>(args: SelectSubset<T, BookmarksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks and returns the data updated in the database.
     * @param {BookmarksUpdateManyAndReturnArgs} args - Arguments to update many Bookmarks.
     * @example
     * // Update many Bookmarks
     * const bookmarks = await prisma.bookmarks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookmarks and only return the `userid`
     * const bookmarksWithUseridOnly = await prisma.bookmarks.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookmarksUpdateManyAndReturnArgs>(args: SelectSubset<T, BookmarksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bookmarks.
     * @param {BookmarksUpsertArgs} args - Arguments to update or create a Bookmarks.
     * @example
     * // Update or create a Bookmarks
     * const bookmarks = await prisma.bookmarks.upsert({
     *   create: {
     *     // ... data to create a Bookmarks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmarks we want to update
     *   }
     * })
     */
    upsert<T extends BookmarksUpsertArgs>(args: SelectSubset<T, BookmarksUpsertArgs<ExtArgs>>): Prisma__BookmarksClient<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmarks.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarksCountArgs>(
      args?: Subset<T, BookmarksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarksAggregateArgs>(args: Subset<T, BookmarksAggregateArgs>): Prisma.PrismaPromise<GetBookmarksAggregateType<T>>

    /**
     * Group by Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarksGroupByArgs['orderBy'] }
        : { orderBy?: BookmarksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmarks model
   */
  readonly fields: BookmarksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmarks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Manga<T extends MangaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MangaDefaultArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Movies<T extends MoviesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoviesDefaultArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Videos<T extends VideosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideosDefaultArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmarks model
   */ 
  interface BookmarksFieldRefs {
    readonly userid: FieldRef<"Bookmarks", 'String'>
    readonly mediatype: FieldRef<"Bookmarks", 'MediaType'>
    readonly parentid: FieldRef<"Bookmarks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bookmarks findUnique
   */
  export type BookmarksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where: BookmarksWhereUniqueInput
  }

  /**
   * Bookmarks findUniqueOrThrow
   */
  export type BookmarksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where: BookmarksWhereUniqueInput
  }

  /**
   * Bookmarks findFirst
   */
  export type BookmarksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Bookmarks findFirstOrThrow
   */
  export type BookmarksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Bookmarks findMany
   */
  export type BookmarksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Bookmarks create
   */
  export type BookmarksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmarks.
     */
    data: XOR<BookmarksCreateInput, BookmarksUncheckedCreateInput>
  }

  /**
   * Bookmarks createMany
   */
  export type BookmarksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarksCreateManyInput | BookmarksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmarks createManyAndReturn
   */
  export type BookmarksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarksCreateManyInput | BookmarksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmarks update
   */
  export type BookmarksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmarks.
     */
    data: XOR<BookmarksUpdateInput, BookmarksUncheckedUpdateInput>
    /**
     * Choose, which Bookmarks to update.
     */
    where: BookmarksWhereUniqueInput
  }

  /**
   * Bookmarks updateMany
   */
  export type BookmarksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarksWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
  }

  /**
   * Bookmarks updateManyAndReturn
   */
  export type BookmarksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarksWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmarks upsert
   */
  export type BookmarksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmarks to update in case it exists.
     */
    where: BookmarksWhereUniqueInput
    /**
     * In case the Bookmarks found by the `where` argument doesn't exist, create a new Bookmarks with this data.
     */
    create: XOR<BookmarksCreateInput, BookmarksUncheckedCreateInput>
    /**
     * In case the Bookmarks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarksUpdateInput, BookmarksUncheckedUpdateInput>
  }

  /**
   * Bookmarks delete
   */
  export type BookmarksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    /**
     * Filter which Bookmarks to delete.
     */
    where: BookmarksWhereUniqueInput
  }

  /**
   * Bookmarks deleteMany
   */
  export type BookmarksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarksWhereInput
    /**
     * Limit how many Bookmarks to delete.
     */
    limit?: number
  }

  /**
   * Bookmarks without action
   */
  export type BookmarksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
  }


  /**
   * Model Comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    commentid: number | null
    mediatime: number | null
    parent_comment_id: number | null
    likes: number | null
    dislikes: number | null
  }

  export type CommentsSumAggregateOutputType = {
    commentid: number | null
    mediatime: number | null
    parent_comment_id: number | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type CommentsMinAggregateOutputType = {
    commentid: number | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    mediatime: number | null
    userid: string | null
    comment_text: string | null
    comment_date: Date | null
    parent_comment_id: number | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type CommentsMaxAggregateOutputType = {
    commentid: number | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    mediatime: number | null
    userid: string | null
    comment_text: string | null
    comment_date: Date | null
    parent_comment_id: number | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type CommentsCountAggregateOutputType = {
    commentid: number
    parentid: number
    mediatype: number
    mediatime: number
    userid: number
    comment_text: number
    comment_date: number
    parent_comment_id: number
    likes: number
    dislikes: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    commentid?: true
    mediatime?: true
    parent_comment_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentsSumAggregateInputType = {
    commentid?: true
    mediatime?: true
    parent_comment_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentsMinAggregateInputType = {
    commentid?: true
    parentid?: true
    mediatype?: true
    mediatime?: true
    userid?: true
    comment_text?: true
    comment_date?: true
    parent_comment_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentsMaxAggregateInputType = {
    commentid?: true
    parentid?: true
    mediatype?: true
    mediatime?: true
    userid?: true
    comment_text?: true
    comment_date?: true
    parent_comment_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentsCountAggregateInputType = {
    commentid?: true
    parentid?: true
    mediatype?: true
    mediatime?: true
    userid?: true
    comment_text?: true
    comment_date?: true
    parent_comment_id?: true
    likes?: true
    dislikes?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to aggregate.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithAggregationInput | CommentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: CommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    commentid: number
    parentid: string
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text: string
    comment_date: Date
    parent_comment_id: number | null
    likes: bigint
    dislikes: bigint
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type CommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commentid?: boolean
    parentid?: boolean
    mediatype?: boolean
    mediatime?: boolean
    userid?: boolean
    comment_text?: boolean
    comment_date?: boolean
    parent_comment_id?: boolean
    likes?: boolean
    dislikes?: boolean
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commentid?: boolean
    parentid?: boolean
    mediatype?: boolean
    mediatime?: boolean
    userid?: boolean
    comment_text?: boolean
    comment_date?: boolean
    parent_comment_id?: boolean
    likes?: boolean
    dislikes?: boolean
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commentid?: boolean
    parentid?: boolean
    mediatype?: boolean
    mediatime?: boolean
    userid?: boolean
    comment_text?: boolean
    comment_date?: boolean
    parent_comment_id?: boolean
    likes?: boolean
    dislikes?: boolean
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectScalar = {
    commentid?: boolean
    parentid?: boolean
    mediatype?: boolean
    mediatime?: boolean
    userid?: boolean
    comment_text?: boolean
    comment_date?: boolean
    parent_comment_id?: boolean
    likes?: boolean
    dislikes?: boolean
  }

  export type CommentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"commentid" | "parentid" | "mediatype" | "mediatime" | "userid" | "comment_text" | "comment_date" | "parent_comment_id" | "likes" | "dislikes", ExtArgs["result"]["comments"]>
  export type CommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type CommentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type CommentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentUnit?: boolean | ContentUnitDefaultArgs<ExtArgs>
    Videos?: boolean | VideosDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comments"
    objects: {
      ContentUnit: Prisma.$ContentUnitPayload<ExtArgs>
      Videos: Prisma.$VideosPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      commentid: number
      parentid: string
      mediatype: $Enums.MediaType
      mediatime: number
      userid: string
      comment_text: string
      comment_date: Date
      parent_comment_id: number | null
      likes: bigint
      dislikes: bigint
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type CommentsGetPayload<S extends boolean | null | undefined | CommentsDefaultArgs> = $Result.GetResult<Prisma.$CommentsPayload, S>

  type CommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface CommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comments'], meta: { name: 'Comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentsFindUniqueArgs>(args: SelectSubset<T, CommentsFindUniqueArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentsFindFirstArgs>(args?: SelectSubset<T, CommentsFindFirstArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `commentid`
     * const commentsWithCommentidOnly = await prisma.comments.findMany({ select: { commentid: true } })
     * 
     */
    findMany<T extends CommentsFindManyArgs>(args?: SelectSubset<T, CommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends CommentsCreateArgs>(args: SelectSubset<T, CommentsCreateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentsCreateManyArgs>(args?: SelectSubset<T, CommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `commentid`
     * const commentsWithCommentidOnly = await prisma.comments.createManyAndReturn({
     *   select: { commentid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentsCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends CommentsDeleteArgs>(args: SelectSubset<T, CommentsDeleteArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentsUpdateArgs>(args: SelectSubset<T, CommentsUpdateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentsDeleteManyArgs>(args?: SelectSubset<T, CommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentsUpdateManyArgs>(args: SelectSubset<T, CommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `commentid`
     * const commentsWithCommentidOnly = await prisma.comments.updateManyAndReturn({
     *   select: { commentid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentsUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends CommentsUpsertArgs>(args: SelectSubset<T, CommentsUpsertArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comments model
   */
  readonly fields: CommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ContentUnit<T extends ContentUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnitDefaultArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Videos<T extends VideosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideosDefaultArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comments model
   */ 
  interface CommentsFieldRefs {
    readonly commentid: FieldRef<"Comments", 'Int'>
    readonly parentid: FieldRef<"Comments", 'String'>
    readonly mediatype: FieldRef<"Comments", 'MediaType'>
    readonly mediatime: FieldRef<"Comments", 'Int'>
    readonly userid: FieldRef<"Comments", 'String'>
    readonly comment_text: FieldRef<"Comments", 'String'>
    readonly comment_date: FieldRef<"Comments", 'DateTime'>
    readonly parent_comment_id: FieldRef<"Comments", 'Int'>
    readonly likes: FieldRef<"Comments", 'BigInt'>
    readonly dislikes: FieldRef<"Comments", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findUniqueOrThrow
   */
  export type CommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findFirstOrThrow
   */
  export type CommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments create
   */
  export type CommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Comments.
     */
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }

  /**
   * Comments createMany
   */
  export type CommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comments createManyAndReturn
   */
  export type CommentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comments update
   */
  export type CommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Comments.
     */
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comments updateManyAndReturn
   */
  export type CommentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Comments to update in case it exists.
     */
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
     */
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }

  /**
   * Comments delete
   */
  export type CommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter which Comments to delete.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comments without action
   */
  export type CommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
  }


  /**
   * Model ContentGroup
   */

  export type AggregateContentGroup = {
    _count: ContentGroupCountAggregateOutputType | null
    _avg: ContentGroupAvgAggregateOutputType | null
    _sum: ContentGroupSumAggregateOutputType | null
    _min: ContentGroupMinAggregateOutputType | null
    _max: ContentGroupMaxAggregateOutputType | null
  }

  export type ContentGroupAvgAggregateOutputType = {
    season_number: number | null
  }

  export type ContentGroupSumAggregateOutputType = {
    season_number: number | null
  }

  export type ContentGroupMinAggregateOutputType = {
    seasonid: string | null
    season_number: number | null
    release_date: Date | null
    visible: boolean | null
    season_path: string | null
  }

  export type ContentGroupMaxAggregateOutputType = {
    seasonid: string | null
    season_number: number | null
    release_date: Date | null
    visible: boolean | null
    season_path: string | null
  }

  export type ContentGroupCountAggregateOutputType = {
    seasonid: number
    season_number: number
    release_date: number
    visible: number
    season_path: number
    _all: number
  }


  export type ContentGroupAvgAggregateInputType = {
    season_number?: true
  }

  export type ContentGroupSumAggregateInputType = {
    season_number?: true
  }

  export type ContentGroupMinAggregateInputType = {
    seasonid?: true
    season_number?: true
    release_date?: true
    visible?: true
    season_path?: true
  }

  export type ContentGroupMaxAggregateInputType = {
    seasonid?: true
    season_number?: true
    release_date?: true
    visible?: true
    season_path?: true
  }

  export type ContentGroupCountAggregateInputType = {
    seasonid?: true
    season_number?: true
    release_date?: true
    visible?: true
    season_path?: true
    _all?: true
  }

  export type ContentGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGroup to aggregate.
     */
    where?: ContentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroups to fetch.
     */
    orderBy?: ContentGroupOrderByWithRelationInput | ContentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentGroups
    **/
    _count?: true | ContentGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentGroupMaxAggregateInputType
  }

  export type GetContentGroupAggregateType<T extends ContentGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateContentGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentGroup[P]>
      : GetScalarType<T[P], AggregateContentGroup[P]>
  }




  export type ContentGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupWhereInput
    orderBy?: ContentGroupOrderByWithAggregationInput | ContentGroupOrderByWithAggregationInput[]
    by: ContentGroupScalarFieldEnum[] | ContentGroupScalarFieldEnum
    having?: ContentGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentGroupCountAggregateInputType | true
    _avg?: ContentGroupAvgAggregateInputType
    _sum?: ContentGroupSumAggregateInputType
    _min?: ContentGroupMinAggregateInputType
    _max?: ContentGroupMaxAggregateInputType
  }

  export type ContentGroupGroupByOutputType = {
    seasonid: string
    season_number: number
    release_date: Date
    visible: boolean
    season_path: string
    _count: ContentGroupCountAggregateOutputType | null
    _avg: ContentGroupAvgAggregateOutputType | null
    _sum: ContentGroupSumAggregateOutputType | null
    _min: ContentGroupMinAggregateOutputType | null
    _max: ContentGroupMaxAggregateOutputType | null
  }

  type GetContentGroupGroupByPayload<T extends ContentGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupGroupByOutputType[P]>
        }
      >
    >


  export type ContentGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seasonid?: boolean
    season_number?: boolean
    release_date?: boolean
    visible?: boolean
    season_path?: boolean
    ContentGroupLinks?: boolean | ContentGroup$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | ContentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentGroup"]>

  export type ContentGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seasonid?: boolean
    season_number?: boolean
    release_date?: boolean
    visible?: boolean
    season_path?: boolean
  }, ExtArgs["result"]["contentGroup"]>

  export type ContentGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seasonid?: boolean
    season_number?: boolean
    release_date?: boolean
    visible?: boolean
    season_path?: boolean
  }, ExtArgs["result"]["contentGroup"]>

  export type ContentGroupSelectScalar = {
    seasonid?: boolean
    season_number?: boolean
    release_date?: boolean
    visible?: boolean
    season_path?: boolean
  }

  export type ContentGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seasonid" | "season_number" | "release_date" | "visible" | "season_path", ExtArgs["result"]["contentGroup"]>
  export type ContentGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentGroupLinks?: boolean | ContentGroup$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | ContentGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentGroup"
    objects: {
      ContentGroupLinks: Prisma.$ContentGroupMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      seasonid: string
      season_number: number
      release_date: Date
      visible: boolean
      season_path: string
    }, ExtArgs["result"]["contentGroup"]>
    composites: {}
  }

  type ContentGroupGetPayload<S extends boolean | null | undefined | ContentGroupDefaultArgs> = $Result.GetResult<Prisma.$ContentGroupPayload, S>

  type ContentGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentGroupCountAggregateInputType | true
    }

  export interface ContentGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentGroup'], meta: { name: 'ContentGroup' } }
    /**
     * Find zero or one ContentGroup that matches the filter.
     * @param {ContentGroupFindUniqueArgs} args - Arguments to find a ContentGroup
     * @example
     * // Get one ContentGroup
     * const contentGroup = await prisma.contentGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentGroupFindUniqueArgs>(args: SelectSubset<T, ContentGroupFindUniqueArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentGroupFindUniqueOrThrowArgs} args - Arguments to find a ContentGroup
     * @example
     * // Get one ContentGroup
     * const contentGroup = await prisma.contentGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupFindFirstArgs} args - Arguments to find a ContentGroup
     * @example
     * // Get one ContentGroup
     * const contentGroup = await prisma.contentGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentGroupFindFirstArgs>(args?: SelectSubset<T, ContentGroupFindFirstArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupFindFirstOrThrowArgs} args - Arguments to find a ContentGroup
     * @example
     * // Get one ContentGroup
     * const contentGroup = await prisma.contentGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentGroups
     * const contentGroups = await prisma.contentGroup.findMany()
     * 
     * // Get first 10 ContentGroups
     * const contentGroups = await prisma.contentGroup.findMany({ take: 10 })
     * 
     * // Only select the `seasonid`
     * const contentGroupWithSeasonidOnly = await prisma.contentGroup.findMany({ select: { seasonid: true } })
     * 
     */
    findMany<T extends ContentGroupFindManyArgs>(args?: SelectSubset<T, ContentGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentGroup.
     * @param {ContentGroupCreateArgs} args - Arguments to create a ContentGroup.
     * @example
     * // Create one ContentGroup
     * const ContentGroup = await prisma.contentGroup.create({
     *   data: {
     *     // ... data to create a ContentGroup
     *   }
     * })
     * 
     */
    create<T extends ContentGroupCreateArgs>(args: SelectSubset<T, ContentGroupCreateArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentGroups.
     * @param {ContentGroupCreateManyArgs} args - Arguments to create many ContentGroups.
     * @example
     * // Create many ContentGroups
     * const contentGroup = await prisma.contentGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentGroupCreateManyArgs>(args?: SelectSubset<T, ContentGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentGroups and returns the data saved in the database.
     * @param {ContentGroupCreateManyAndReturnArgs} args - Arguments to create many ContentGroups.
     * @example
     * // Create many ContentGroups
     * const contentGroup = await prisma.contentGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentGroups and only return the `seasonid`
     * const contentGroupWithSeasonidOnly = await prisma.contentGroup.createManyAndReturn({
     *   select: { seasonid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentGroup.
     * @param {ContentGroupDeleteArgs} args - Arguments to delete one ContentGroup.
     * @example
     * // Delete one ContentGroup
     * const ContentGroup = await prisma.contentGroup.delete({
     *   where: {
     *     // ... filter to delete one ContentGroup
     *   }
     * })
     * 
     */
    delete<T extends ContentGroupDeleteArgs>(args: SelectSubset<T, ContentGroupDeleteArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentGroup.
     * @param {ContentGroupUpdateArgs} args - Arguments to update one ContentGroup.
     * @example
     * // Update one ContentGroup
     * const contentGroup = await prisma.contentGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentGroupUpdateArgs>(args: SelectSubset<T, ContentGroupUpdateArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentGroups.
     * @param {ContentGroupDeleteManyArgs} args - Arguments to filter ContentGroups to delete.
     * @example
     * // Delete a few ContentGroups
     * const { count } = await prisma.contentGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentGroupDeleteManyArgs>(args?: SelectSubset<T, ContentGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentGroups
     * const contentGroup = await prisma.contentGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentGroupUpdateManyArgs>(args: SelectSubset<T, ContentGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentGroups and returns the data updated in the database.
     * @param {ContentGroupUpdateManyAndReturnArgs} args - Arguments to update many ContentGroups.
     * @example
     * // Update many ContentGroups
     * const contentGroup = await prisma.contentGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentGroups and only return the `seasonid`
     * const contentGroupWithSeasonidOnly = await prisma.contentGroup.updateManyAndReturn({
     *   select: { seasonid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentGroup.
     * @param {ContentGroupUpsertArgs} args - Arguments to update or create a ContentGroup.
     * @example
     * // Update or create a ContentGroup
     * const contentGroup = await prisma.contentGroup.upsert({
     *   create: {
     *     // ... data to create a ContentGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentGroup we want to update
     *   }
     * })
     */
    upsert<T extends ContentGroupUpsertArgs>(args: SelectSubset<T, ContentGroupUpsertArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupCountArgs} args - Arguments to filter ContentGroups to count.
     * @example
     * // Count the number of ContentGroups
     * const count = await prisma.contentGroup.count({
     *   where: {
     *     // ... the filter for the ContentGroups we want to count
     *   }
     * })
    **/
    count<T extends ContentGroupCountArgs>(
      args?: Subset<T, ContentGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentGroupAggregateArgs>(args: Subset<T, ContentGroupAggregateArgs>): Prisma.PrismaPromise<GetContentGroupAggregateType<T>>

    /**
     * Group by ContentGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentGroup model
   */
  readonly fields: ContentGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ContentGroupLinks<T extends ContentGroup$ContentGroupLinksArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroup$ContentGroupLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentGroup model
   */ 
  interface ContentGroupFieldRefs {
    readonly seasonid: FieldRef<"ContentGroup", 'String'>
    readonly season_number: FieldRef<"ContentGroup", 'Int'>
    readonly release_date: FieldRef<"ContentGroup", 'DateTime'>
    readonly visible: FieldRef<"ContentGroup", 'Boolean'>
    readonly season_path: FieldRef<"ContentGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentGroup findUnique
   */
  export type ContentGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroup to fetch.
     */
    where: ContentGroupWhereUniqueInput
  }

  /**
   * ContentGroup findUniqueOrThrow
   */
  export type ContentGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroup to fetch.
     */
    where: ContentGroupWhereUniqueInput
  }

  /**
   * ContentGroup findFirst
   */
  export type ContentGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroup to fetch.
     */
    where?: ContentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroups to fetch.
     */
    orderBy?: ContentGroupOrderByWithRelationInput | ContentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGroups.
     */
    cursor?: ContentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGroups.
     */
    distinct?: ContentGroupScalarFieldEnum | ContentGroupScalarFieldEnum[]
  }

  /**
   * ContentGroup findFirstOrThrow
   */
  export type ContentGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroup to fetch.
     */
    where?: ContentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroups to fetch.
     */
    orderBy?: ContentGroupOrderByWithRelationInput | ContentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGroups.
     */
    cursor?: ContentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGroups.
     */
    distinct?: ContentGroupScalarFieldEnum | ContentGroupScalarFieldEnum[]
  }

  /**
   * ContentGroup findMany
   */
  export type ContentGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroups to fetch.
     */
    where?: ContentGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroups to fetch.
     */
    orderBy?: ContentGroupOrderByWithRelationInput | ContentGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentGroups.
     */
    cursor?: ContentGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroups.
     */
    skip?: number
    distinct?: ContentGroupScalarFieldEnum | ContentGroupScalarFieldEnum[]
  }

  /**
   * ContentGroup create
   */
  export type ContentGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentGroup.
     */
    data: XOR<ContentGroupCreateInput, ContentGroupUncheckedCreateInput>
  }

  /**
   * ContentGroup createMany
   */
  export type ContentGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentGroups.
     */
    data: ContentGroupCreateManyInput | ContentGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentGroup createManyAndReturn
   */
  export type ContentGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ContentGroups.
     */
    data: ContentGroupCreateManyInput | ContentGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentGroup update
   */
  export type ContentGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentGroup.
     */
    data: XOR<ContentGroupUpdateInput, ContentGroupUncheckedUpdateInput>
    /**
     * Choose, which ContentGroup to update.
     */
    where: ContentGroupWhereUniqueInput
  }

  /**
   * ContentGroup updateMany
   */
  export type ContentGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentGroups.
     */
    data: XOR<ContentGroupUpdateManyMutationInput, ContentGroupUncheckedUpdateManyInput>
    /**
     * Filter which ContentGroups to update
     */
    where?: ContentGroupWhereInput
    /**
     * Limit how many ContentGroups to update.
     */
    limit?: number
  }

  /**
   * ContentGroup updateManyAndReturn
   */
  export type ContentGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * The data used to update ContentGroups.
     */
    data: XOR<ContentGroupUpdateManyMutationInput, ContentGroupUncheckedUpdateManyInput>
    /**
     * Filter which ContentGroups to update
     */
    where?: ContentGroupWhereInput
    /**
     * Limit how many ContentGroups to update.
     */
    limit?: number
  }

  /**
   * ContentGroup upsert
   */
  export type ContentGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentGroup to update in case it exists.
     */
    where: ContentGroupWhereUniqueInput
    /**
     * In case the ContentGroup found by the `where` argument doesn't exist, create a new ContentGroup with this data.
     */
    create: XOR<ContentGroupCreateInput, ContentGroupUncheckedCreateInput>
    /**
     * In case the ContentGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentGroupUpdateInput, ContentGroupUncheckedUpdateInput>
  }

  /**
   * ContentGroup delete
   */
  export type ContentGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
    /**
     * Filter which ContentGroup to delete.
     */
    where: ContentGroupWhereUniqueInput
  }

  /**
   * ContentGroup deleteMany
   */
  export type ContentGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGroups to delete
     */
    where?: ContentGroupWhereInput
    /**
     * Limit how many ContentGroups to delete.
     */
    limit?: number
  }

  /**
   * ContentGroup.ContentGroupLinks
   */
  export type ContentGroup$ContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    where?: ContentGroupMediaWhereInput
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    cursor?: ContentGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * ContentGroup without action
   */
  export type ContentGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroup
     */
    select?: ContentGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroup
     */
    omit?: ContentGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupInclude<ExtArgs> | null
  }


  /**
   * Model ContentGroupMedia
   */

  export type AggregateContentGroupMedia = {
    _count: ContentGroupMediaCountAggregateOutputType | null
    _min: ContentGroupMediaMinAggregateOutputType | null
    _max: ContentGroupMediaMaxAggregateOutputType | null
  }

  export type ContentGroupMediaMinAggregateOutputType = {
    id: string | null
    seasonid: string | null
    mediaid: string | null
    mediatype: $Enums.MediaType | null
  }

  export type ContentGroupMediaMaxAggregateOutputType = {
    id: string | null
    seasonid: string | null
    mediaid: string | null
    mediatype: $Enums.MediaType | null
  }

  export type ContentGroupMediaCountAggregateOutputType = {
    id: number
    seasonid: number
    mediaid: number
    mediatype: number
    _all: number
  }


  export type ContentGroupMediaMinAggregateInputType = {
    id?: true
    seasonid?: true
    mediaid?: true
    mediatype?: true
  }

  export type ContentGroupMediaMaxAggregateInputType = {
    id?: true
    seasonid?: true
    mediaid?: true
    mediatype?: true
  }

  export type ContentGroupMediaCountAggregateInputType = {
    id?: true
    seasonid?: true
    mediaid?: true
    mediatype?: true
    _all?: true
  }

  export type ContentGroupMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGroupMedia to aggregate.
     */
    where?: ContentGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroupMedias to fetch.
     */
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentGroupMedias
    **/
    _count?: true | ContentGroupMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentGroupMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentGroupMediaMaxAggregateInputType
  }

  export type GetContentGroupMediaAggregateType<T extends ContentGroupMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateContentGroupMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentGroupMedia[P]>
      : GetScalarType<T[P], AggregateContentGroupMedia[P]>
  }




  export type ContentGroupMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGroupMediaWhereInput
    orderBy?: ContentGroupMediaOrderByWithAggregationInput | ContentGroupMediaOrderByWithAggregationInput[]
    by: ContentGroupMediaScalarFieldEnum[] | ContentGroupMediaScalarFieldEnum
    having?: ContentGroupMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentGroupMediaCountAggregateInputType | true
    _min?: ContentGroupMediaMinAggregateInputType
    _max?: ContentGroupMediaMaxAggregateInputType
  }

  export type ContentGroupMediaGroupByOutputType = {
    id: string
    seasonid: string
    mediaid: string
    mediatype: $Enums.MediaType
    _count: ContentGroupMediaCountAggregateOutputType | null
    _min: ContentGroupMediaMinAggregateOutputType | null
    _max: ContentGroupMediaMaxAggregateOutputType | null
  }

  type GetContentGroupMediaGroupByPayload<T extends ContentGroupMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupMediaGroupByOutputType[P]>
        }
      >
    >


  export type ContentGroupMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonid?: boolean
    mediaid?: boolean
    mediatype?: boolean
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
    ContentUnits?: boolean | ContentGroupMedia$ContentUnitsArgs<ExtArgs>
    _count?: boolean | ContentGroupMediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentGroupMedia"]>

  export type ContentGroupMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonid?: boolean
    mediaid?: boolean
    mediatype?: boolean
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentGroupMedia"]>

  export type ContentGroupMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonid?: boolean
    mediaid?: boolean
    mediatype?: boolean
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentGroupMedia"]>

  export type ContentGroupMediaSelectScalar = {
    id?: boolean
    seasonid?: boolean
    mediaid?: boolean
    mediatype?: boolean
  }

  export type ContentGroupMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seasonid" | "mediaid" | "mediatype", ExtArgs["result"]["contentGroupMedia"]>
  export type ContentGroupMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
    ContentUnits?: boolean | ContentGroupMedia$ContentUnitsArgs<ExtArgs>
    _count?: boolean | ContentGroupMediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentGroupMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
  }
  export type ContentGroupMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | ContentGroupMedia$AnimeArgs<ExtArgs>
    Manga?: boolean | ContentGroupMedia$MangaArgs<ExtArgs>
    Movies?: boolean | ContentGroupMedia$MoviesArgs<ExtArgs>
    ContentGroup?: boolean | ContentGroupDefaultArgs<ExtArgs>
  }

  export type $ContentGroupMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentGroupMedia"
    objects: {
      Anime: Prisma.$AnimePayload<ExtArgs> | null
      Manga: Prisma.$MangaPayload<ExtArgs> | null
      Movies: Prisma.$MoviesPayload<ExtArgs> | null
      ContentGroup: Prisma.$ContentGroupPayload<ExtArgs>
      ContentUnits: Prisma.$ContentUnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seasonid: string
      mediaid: string
      mediatype: $Enums.MediaType
    }, ExtArgs["result"]["contentGroupMedia"]>
    composites: {}
  }

  type ContentGroupMediaGetPayload<S extends boolean | null | undefined | ContentGroupMediaDefaultArgs> = $Result.GetResult<Prisma.$ContentGroupMediaPayload, S>

  type ContentGroupMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentGroupMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentGroupMediaCountAggregateInputType | true
    }

  export interface ContentGroupMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentGroupMedia'], meta: { name: 'ContentGroupMedia' } }
    /**
     * Find zero or one ContentGroupMedia that matches the filter.
     * @param {ContentGroupMediaFindUniqueArgs} args - Arguments to find a ContentGroupMedia
     * @example
     * // Get one ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentGroupMediaFindUniqueArgs>(args: SelectSubset<T, ContentGroupMediaFindUniqueArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentGroupMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentGroupMediaFindUniqueOrThrowArgs} args - Arguments to find a ContentGroupMedia
     * @example
     * // Get one ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentGroupMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentGroupMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGroupMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaFindFirstArgs} args - Arguments to find a ContentGroupMedia
     * @example
     * // Get one ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentGroupMediaFindFirstArgs>(args?: SelectSubset<T, ContentGroupMediaFindFirstArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGroupMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaFindFirstOrThrowArgs} args - Arguments to find a ContentGroupMedia
     * @example
     * // Get one ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentGroupMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentGroupMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentGroupMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentGroupMedias
     * const contentGroupMedias = await prisma.contentGroupMedia.findMany()
     * 
     * // Get first 10 ContentGroupMedias
     * const contentGroupMedias = await prisma.contentGroupMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentGroupMediaWithIdOnly = await prisma.contentGroupMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentGroupMediaFindManyArgs>(args?: SelectSubset<T, ContentGroupMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentGroupMedia.
     * @param {ContentGroupMediaCreateArgs} args - Arguments to create a ContentGroupMedia.
     * @example
     * // Create one ContentGroupMedia
     * const ContentGroupMedia = await prisma.contentGroupMedia.create({
     *   data: {
     *     // ... data to create a ContentGroupMedia
     *   }
     * })
     * 
     */
    create<T extends ContentGroupMediaCreateArgs>(args: SelectSubset<T, ContentGroupMediaCreateArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentGroupMedias.
     * @param {ContentGroupMediaCreateManyArgs} args - Arguments to create many ContentGroupMedias.
     * @example
     * // Create many ContentGroupMedias
     * const contentGroupMedia = await prisma.contentGroupMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentGroupMediaCreateManyArgs>(args?: SelectSubset<T, ContentGroupMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentGroupMedias and returns the data saved in the database.
     * @param {ContentGroupMediaCreateManyAndReturnArgs} args - Arguments to create many ContentGroupMedias.
     * @example
     * // Create many ContentGroupMedias
     * const contentGroupMedia = await prisma.contentGroupMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentGroupMedias and only return the `id`
     * const contentGroupMediaWithIdOnly = await prisma.contentGroupMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentGroupMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentGroupMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentGroupMedia.
     * @param {ContentGroupMediaDeleteArgs} args - Arguments to delete one ContentGroupMedia.
     * @example
     * // Delete one ContentGroupMedia
     * const ContentGroupMedia = await prisma.contentGroupMedia.delete({
     *   where: {
     *     // ... filter to delete one ContentGroupMedia
     *   }
     * })
     * 
     */
    delete<T extends ContentGroupMediaDeleteArgs>(args: SelectSubset<T, ContentGroupMediaDeleteArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentGroupMedia.
     * @param {ContentGroupMediaUpdateArgs} args - Arguments to update one ContentGroupMedia.
     * @example
     * // Update one ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentGroupMediaUpdateArgs>(args: SelectSubset<T, ContentGroupMediaUpdateArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentGroupMedias.
     * @param {ContentGroupMediaDeleteManyArgs} args - Arguments to filter ContentGroupMedias to delete.
     * @example
     * // Delete a few ContentGroupMedias
     * const { count } = await prisma.contentGroupMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentGroupMediaDeleteManyArgs>(args?: SelectSubset<T, ContentGroupMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentGroupMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentGroupMedias
     * const contentGroupMedia = await prisma.contentGroupMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentGroupMediaUpdateManyArgs>(args: SelectSubset<T, ContentGroupMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentGroupMedias and returns the data updated in the database.
     * @param {ContentGroupMediaUpdateManyAndReturnArgs} args - Arguments to update many ContentGroupMedias.
     * @example
     * // Update many ContentGroupMedias
     * const contentGroupMedia = await prisma.contentGroupMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentGroupMedias and only return the `id`
     * const contentGroupMediaWithIdOnly = await prisma.contentGroupMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentGroupMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentGroupMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentGroupMedia.
     * @param {ContentGroupMediaUpsertArgs} args - Arguments to update or create a ContentGroupMedia.
     * @example
     * // Update or create a ContentGroupMedia
     * const contentGroupMedia = await prisma.contentGroupMedia.upsert({
     *   create: {
     *     // ... data to create a ContentGroupMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentGroupMedia we want to update
     *   }
     * })
     */
    upsert<T extends ContentGroupMediaUpsertArgs>(args: SelectSubset<T, ContentGroupMediaUpsertArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentGroupMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaCountArgs} args - Arguments to filter ContentGroupMedias to count.
     * @example
     * // Count the number of ContentGroupMedias
     * const count = await prisma.contentGroupMedia.count({
     *   where: {
     *     // ... the filter for the ContentGroupMedias we want to count
     *   }
     * })
    **/
    count<T extends ContentGroupMediaCountArgs>(
      args?: Subset<T, ContentGroupMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentGroupMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentGroupMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentGroupMediaAggregateArgs>(args: Subset<T, ContentGroupMediaAggregateArgs>): Prisma.PrismaPromise<GetContentGroupMediaAggregateType<T>>

    /**
     * Group by ContentGroupMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupMediaGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentGroupMedia model
   */
  readonly fields: ContentGroupMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentGroupMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentGroupMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Anime<T extends ContentGroupMedia$AnimeArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupMedia$AnimeArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Manga<T extends ContentGroupMedia$MangaArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupMedia$MangaArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Movies<T extends ContentGroupMedia$MoviesArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupMedia$MoviesArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ContentGroup<T extends ContentGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupDefaultArgs<ExtArgs>>): Prisma__ContentGroupClient<$Result.GetResult<Prisma.$ContentGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ContentUnits<T extends ContentGroupMedia$ContentUnitsArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupMedia$ContentUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentGroupMedia model
   */ 
  interface ContentGroupMediaFieldRefs {
    readonly id: FieldRef<"ContentGroupMedia", 'String'>
    readonly seasonid: FieldRef<"ContentGroupMedia", 'String'>
    readonly mediaid: FieldRef<"ContentGroupMedia", 'String'>
    readonly mediatype: FieldRef<"ContentGroupMedia", 'MediaType'>
  }
    

  // Custom InputTypes
  /**
   * ContentGroupMedia findUnique
   */
  export type ContentGroupMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroupMedia to fetch.
     */
    where: ContentGroupMediaWhereUniqueInput
  }

  /**
   * ContentGroupMedia findUniqueOrThrow
   */
  export type ContentGroupMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroupMedia to fetch.
     */
    where: ContentGroupMediaWhereUniqueInput
  }

  /**
   * ContentGroupMedia findFirst
   */
  export type ContentGroupMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroupMedia to fetch.
     */
    where?: ContentGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroupMedias to fetch.
     */
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGroupMedias.
     */
    cursor?: ContentGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGroupMedias.
     */
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * ContentGroupMedia findFirstOrThrow
   */
  export type ContentGroupMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroupMedia to fetch.
     */
    where?: ContentGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroupMedias to fetch.
     */
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGroupMedias.
     */
    cursor?: ContentGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGroupMedias.
     */
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * ContentGroupMedia findMany
   */
  export type ContentGroupMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentGroupMedias to fetch.
     */
    where?: ContentGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGroupMedias to fetch.
     */
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentGroupMedias.
     */
    cursor?: ContentGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGroupMedias.
     */
    skip?: number
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * ContentGroupMedia create
   */
  export type ContentGroupMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentGroupMedia.
     */
    data: XOR<ContentGroupMediaCreateInput, ContentGroupMediaUncheckedCreateInput>
  }

  /**
   * ContentGroupMedia createMany
   */
  export type ContentGroupMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentGroupMedias.
     */
    data: ContentGroupMediaCreateManyInput | ContentGroupMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentGroupMedia createManyAndReturn
   */
  export type ContentGroupMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * The data used to create many ContentGroupMedias.
     */
    data: ContentGroupMediaCreateManyInput | ContentGroupMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentGroupMedia update
   */
  export type ContentGroupMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentGroupMedia.
     */
    data: XOR<ContentGroupMediaUpdateInput, ContentGroupMediaUncheckedUpdateInput>
    /**
     * Choose, which ContentGroupMedia to update.
     */
    where: ContentGroupMediaWhereUniqueInput
  }

  /**
   * ContentGroupMedia updateMany
   */
  export type ContentGroupMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentGroupMedias.
     */
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyInput>
    /**
     * Filter which ContentGroupMedias to update
     */
    where?: ContentGroupMediaWhereInput
    /**
     * Limit how many ContentGroupMedias to update.
     */
    limit?: number
  }

  /**
   * ContentGroupMedia updateManyAndReturn
   */
  export type ContentGroupMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * The data used to update ContentGroupMedias.
     */
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyInput>
    /**
     * Filter which ContentGroupMedias to update
     */
    where?: ContentGroupMediaWhereInput
    /**
     * Limit how many ContentGroupMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentGroupMedia upsert
   */
  export type ContentGroupMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentGroupMedia to update in case it exists.
     */
    where: ContentGroupMediaWhereUniqueInput
    /**
     * In case the ContentGroupMedia found by the `where` argument doesn't exist, create a new ContentGroupMedia with this data.
     */
    create: XOR<ContentGroupMediaCreateInput, ContentGroupMediaUncheckedCreateInput>
    /**
     * In case the ContentGroupMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentGroupMediaUpdateInput, ContentGroupMediaUncheckedUpdateInput>
  }

  /**
   * ContentGroupMedia delete
   */
  export type ContentGroupMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    /**
     * Filter which ContentGroupMedia to delete.
     */
    where: ContentGroupMediaWhereUniqueInput
  }

  /**
   * ContentGroupMedia deleteMany
   */
  export type ContentGroupMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGroupMedias to delete
     */
    where?: ContentGroupMediaWhereInput
    /**
     * Limit how many ContentGroupMedias to delete.
     */
    limit?: number
  }

  /**
   * ContentGroupMedia.Anime
   */
  export type ContentGroupMedia$AnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
  }

  /**
   * ContentGroupMedia.Manga
   */
  export type ContentGroupMedia$MangaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    where?: MangaWhereInput
  }

  /**
   * ContentGroupMedia.Movies
   */
  export type ContentGroupMedia$MoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    where?: MoviesWhereInput
  }

  /**
   * ContentGroupMedia.ContentUnits
   */
  export type ContentGroupMedia$ContentUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    where?: ContentUnitWhereInput
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    cursor?: ContentUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentGroupMedia without action
   */
  export type ContentGroupMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
  }


  /**
   * Model ContentUnit
   */

  export type AggregateContentUnit = {
    _count: ContentUnitCountAggregateOutputType | null
    _avg: ContentUnitAvgAggregateOutputType | null
    _sum: ContentUnitSumAggregateOutputType | null
    _min: ContentUnitMinAggregateOutputType | null
    _max: ContentUnitMaxAggregateOutputType | null
  }

  export type ContentUnitAvgAggregateOutputType = {
    likes: number | null
    dislikes: number | null
    episode_number: number | null
    views: number | null
    duration: number | null
  }

  export type ContentUnitSumAggregateOutputType = {
    likes: bigint | null
    dislikes: bigint | null
    episode_number: number | null
    views: number | null
    duration: number | null
  }

  export type ContentUnitMinAggregateOutputType = {
    episodeid: string | null
    contentgroupid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
    visible: boolean | null
    episode_number: number | null
    views: number | null
    duration: number | null
    episode_path: string | null
    thumbnail: string | null
  }

  export type ContentUnitMaxAggregateOutputType = {
    episodeid: string | null
    contentgroupid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
    visible: boolean | null
    episode_number: number | null
    views: number | null
    duration: number | null
    episode_path: string | null
    thumbnail: string | null
  }

  export type ContentUnitCountAggregateOutputType = {
    episodeid: number
    contentgroupid: number
    title: number
    description: number
    release_date: number
    likes: number
    dislikes: number
    visible: number
    episode_number: number
    views: number
    duration: number
    episode_path: number
    thumbnail: number
    _all: number
  }


  export type ContentUnitAvgAggregateInputType = {
    likes?: true
    dislikes?: true
    episode_number?: true
    views?: true
    duration?: true
  }

  export type ContentUnitSumAggregateInputType = {
    likes?: true
    dislikes?: true
    episode_number?: true
    views?: true
    duration?: true
  }

  export type ContentUnitMinAggregateInputType = {
    episodeid?: true
    contentgroupid?: true
    title?: true
    description?: true
    release_date?: true
    likes?: true
    dislikes?: true
    visible?: true
    episode_number?: true
    views?: true
    duration?: true
    episode_path?: true
    thumbnail?: true
  }

  export type ContentUnitMaxAggregateInputType = {
    episodeid?: true
    contentgroupid?: true
    title?: true
    description?: true
    release_date?: true
    likes?: true
    dislikes?: true
    visible?: true
    episode_number?: true
    views?: true
    duration?: true
    episode_path?: true
    thumbnail?: true
  }

  export type ContentUnitCountAggregateInputType = {
    episodeid?: true
    contentgroupid?: true
    title?: true
    description?: true
    release_date?: true
    likes?: true
    dislikes?: true
    visible?: true
    episode_number?: true
    views?: true
    duration?: true
    episode_path?: true
    thumbnail?: true
    _all?: true
  }

  export type ContentUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUnit to aggregate.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentUnits
    **/
    _count?: true | ContentUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentUnitMaxAggregateInputType
  }

  export type GetContentUnitAggregateType<T extends ContentUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateContentUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentUnit[P]>
      : GetScalarType<T[P], AggregateContentUnit[P]>
  }




  export type ContentUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentUnitWhereInput
    orderBy?: ContentUnitOrderByWithAggregationInput | ContentUnitOrderByWithAggregationInput[]
    by: ContentUnitScalarFieldEnum[] | ContentUnitScalarFieldEnum
    having?: ContentUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentUnitCountAggregateInputType | true
    _avg?: ContentUnitAvgAggregateInputType
    _sum?: ContentUnitSumAggregateInputType
    _min?: ContentUnitMinAggregateInputType
    _max?: ContentUnitMaxAggregateInputType
  }

  export type ContentUnitGroupByOutputType = {
    episodeid: string
    contentgroupid: string
    title: string
    description: string
    release_date: Date | null
    likes: bigint
    dislikes: bigint
    visible: boolean
    episode_number: number
    views: number
    duration: number
    episode_path: string
    thumbnail: string
    _count: ContentUnitCountAggregateOutputType | null
    _avg: ContentUnitAvgAggregateOutputType | null
    _sum: ContentUnitSumAggregateOutputType | null
    _min: ContentUnitMinAggregateOutputType | null
    _max: ContentUnitMaxAggregateOutputType | null
  }

  type GetContentUnitGroupByPayload<T extends ContentUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentUnitGroupByOutputType[P]>
            : GetScalarType<T[P], ContentUnitGroupByOutputType[P]>
        }
      >
    >


  export type ContentUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    episodeid?: boolean
    contentgroupid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    visible?: boolean
    episode_number?: boolean
    views?: boolean
    duration?: boolean
    episode_path?: boolean
    thumbnail?: boolean
    Comments?: boolean | ContentUnit$CommentsArgs<ExtArgs>
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
    _count?: boolean | ContentUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    episodeid?: boolean
    contentgroupid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    visible?: boolean
    episode_number?: boolean
    views?: boolean
    duration?: boolean
    episode_path?: boolean
    thumbnail?: boolean
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    episodeid?: boolean
    contentgroupid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    visible?: boolean
    episode_number?: boolean
    views?: boolean
    duration?: boolean
    episode_path?: boolean
    thumbnail?: boolean
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentUnit"]>

  export type ContentUnitSelectScalar = {
    episodeid?: boolean
    contentgroupid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    likes?: boolean
    dislikes?: boolean
    visible?: boolean
    episode_number?: boolean
    views?: boolean
    duration?: boolean
    episode_path?: boolean
    thumbnail?: boolean
  }

  export type ContentUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"episodeid" | "contentgroupid" | "title" | "description" | "release_date" | "likes" | "dislikes" | "visible" | "episode_number" | "views" | "duration" | "episode_path" | "thumbnail", ExtArgs["result"]["contentUnit"]>
  export type ContentUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comments?: boolean | ContentUnit$CommentsArgs<ExtArgs>
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
    _count?: boolean | ContentUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
  }
  export type ContentUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContentGroupMedia?: boolean | ContentGroupMediaDefaultArgs<ExtArgs>
  }

  export type $ContentUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentUnit"
    objects: {
      Comments: Prisma.$CommentsPayload<ExtArgs>[]
      ContentGroupMedia: Prisma.$ContentGroupMediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      episodeid: string
      contentgroupid: string
      title: string
      description: string
      release_date: Date | null
      likes: bigint
      dislikes: bigint
      visible: boolean
      episode_number: number
      views: number
      duration: number
      episode_path: string
      thumbnail: string
    }, ExtArgs["result"]["contentUnit"]>
    composites: {}
  }

  type ContentUnitGetPayload<S extends boolean | null | undefined | ContentUnitDefaultArgs> = $Result.GetResult<Prisma.$ContentUnitPayload, S>

  type ContentUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentUnitCountAggregateInputType | true
    }

  export interface ContentUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentUnit'], meta: { name: 'ContentUnit' } }
    /**
     * Find zero or one ContentUnit that matches the filter.
     * @param {ContentUnitFindUniqueArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentUnitFindUniqueArgs>(args: SelectSubset<T, ContentUnitFindUniqueArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentUnitFindUniqueOrThrowArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindFirstArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentUnitFindFirstArgs>(args?: SelectSubset<T, ContentUnitFindFirstArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindFirstOrThrowArgs} args - Arguments to find a ContentUnit
     * @example
     * // Get one ContentUnit
     * const contentUnit = await prisma.contentUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentUnits
     * const contentUnits = await prisma.contentUnit.findMany()
     * 
     * // Get first 10 ContentUnits
     * const contentUnits = await prisma.contentUnit.findMany({ take: 10 })
     * 
     * // Only select the `episodeid`
     * const contentUnitWithEpisodeidOnly = await prisma.contentUnit.findMany({ select: { episodeid: true } })
     * 
     */
    findMany<T extends ContentUnitFindManyArgs>(args?: SelectSubset<T, ContentUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentUnit.
     * @param {ContentUnitCreateArgs} args - Arguments to create a ContentUnit.
     * @example
     * // Create one ContentUnit
     * const ContentUnit = await prisma.contentUnit.create({
     *   data: {
     *     // ... data to create a ContentUnit
     *   }
     * })
     * 
     */
    create<T extends ContentUnitCreateArgs>(args: SelectSubset<T, ContentUnitCreateArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentUnits.
     * @param {ContentUnitCreateManyArgs} args - Arguments to create many ContentUnits.
     * @example
     * // Create many ContentUnits
     * const contentUnit = await prisma.contentUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentUnitCreateManyArgs>(args?: SelectSubset<T, ContentUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentUnits and returns the data saved in the database.
     * @param {ContentUnitCreateManyAndReturnArgs} args - Arguments to create many ContentUnits.
     * @example
     * // Create many ContentUnits
     * const contentUnit = await prisma.contentUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentUnits and only return the `episodeid`
     * const contentUnitWithEpisodeidOnly = await prisma.contentUnit.createManyAndReturn({
     *   select: { episodeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentUnit.
     * @param {ContentUnitDeleteArgs} args - Arguments to delete one ContentUnit.
     * @example
     * // Delete one ContentUnit
     * const ContentUnit = await prisma.contentUnit.delete({
     *   where: {
     *     // ... filter to delete one ContentUnit
     *   }
     * })
     * 
     */
    delete<T extends ContentUnitDeleteArgs>(args: SelectSubset<T, ContentUnitDeleteArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentUnit.
     * @param {ContentUnitUpdateArgs} args - Arguments to update one ContentUnit.
     * @example
     * // Update one ContentUnit
     * const contentUnit = await prisma.contentUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUnitUpdateArgs>(args: SelectSubset<T, ContentUnitUpdateArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentUnits.
     * @param {ContentUnitDeleteManyArgs} args - Arguments to filter ContentUnits to delete.
     * @example
     * // Delete a few ContentUnits
     * const { count } = await prisma.contentUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentUnitDeleteManyArgs>(args?: SelectSubset<T, ContentUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentUnits
     * const contentUnit = await prisma.contentUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUnitUpdateManyArgs>(args: SelectSubset<T, ContentUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentUnits and returns the data updated in the database.
     * @param {ContentUnitUpdateManyAndReturnArgs} args - Arguments to update many ContentUnits.
     * @example
     * // Update many ContentUnits
     * const contentUnit = await prisma.contentUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentUnits and only return the `episodeid`
     * const contentUnitWithEpisodeidOnly = await prisma.contentUnit.updateManyAndReturn({
     *   select: { episodeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentUnit.
     * @param {ContentUnitUpsertArgs} args - Arguments to update or create a ContentUnit.
     * @example
     * // Update or create a ContentUnit
     * const contentUnit = await prisma.contentUnit.upsert({
     *   create: {
     *     // ... data to create a ContentUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentUnit we want to update
     *   }
     * })
     */
    upsert<T extends ContentUnitUpsertArgs>(args: SelectSubset<T, ContentUnitUpsertArgs<ExtArgs>>): Prisma__ContentUnitClient<$Result.GetResult<Prisma.$ContentUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitCountArgs} args - Arguments to filter ContentUnits to count.
     * @example
     * // Count the number of ContentUnits
     * const count = await prisma.contentUnit.count({
     *   where: {
     *     // ... the filter for the ContentUnits we want to count
     *   }
     * })
    **/
    count<T extends ContentUnitCountArgs>(
      args?: Subset<T, ContentUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentUnitAggregateArgs>(args: Subset<T, ContentUnitAggregateArgs>): Prisma.PrismaPromise<GetContentUnitAggregateType<T>>

    /**
     * Group by ContentUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentUnitGroupByArgs['orderBy'] }
        : { orderBy?: ContentUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentUnit model
   */
  readonly fields: ContentUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comments<T extends ContentUnit$CommentsArgs<ExtArgs> = {}>(args?: Subset<T, ContentUnit$CommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContentGroupMedia<T extends ContentGroupMediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentGroupMediaDefaultArgs<ExtArgs>>): Prisma__ContentGroupMediaClient<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentUnit model
   */ 
  interface ContentUnitFieldRefs {
    readonly episodeid: FieldRef<"ContentUnit", 'String'>
    readonly contentgroupid: FieldRef<"ContentUnit", 'String'>
    readonly title: FieldRef<"ContentUnit", 'String'>
    readonly description: FieldRef<"ContentUnit", 'String'>
    readonly release_date: FieldRef<"ContentUnit", 'DateTime'>
    readonly likes: FieldRef<"ContentUnit", 'BigInt'>
    readonly dislikes: FieldRef<"ContentUnit", 'BigInt'>
    readonly visible: FieldRef<"ContentUnit", 'Boolean'>
    readonly episode_number: FieldRef<"ContentUnit", 'Float'>
    readonly views: FieldRef<"ContentUnit", 'Int'>
    readonly duration: FieldRef<"ContentUnit", 'Int'>
    readonly episode_path: FieldRef<"ContentUnit", 'String'>
    readonly thumbnail: FieldRef<"ContentUnit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentUnit findUnique
   */
  export type ContentUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit findUniqueOrThrow
   */
  export type ContentUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit findFirst
   */
  export type ContentUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUnits.
     */
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit findFirstOrThrow
   */
  export type ContentUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnit to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentUnits.
     */
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit findMany
   */
  export type ContentUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter, which ContentUnits to fetch.
     */
    where?: ContentUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentUnits to fetch.
     */
    orderBy?: ContentUnitOrderByWithRelationInput | ContentUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentUnits.
     */
    cursor?: ContentUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentUnits.
     */
    skip?: number
    distinct?: ContentUnitScalarFieldEnum | ContentUnitScalarFieldEnum[]
  }

  /**
   * ContentUnit create
   */
  export type ContentUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentUnit.
     */
    data: XOR<ContentUnitCreateInput, ContentUnitUncheckedCreateInput>
  }

  /**
   * ContentUnit createMany
   */
  export type ContentUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentUnits.
     */
    data: ContentUnitCreateManyInput | ContentUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentUnit createManyAndReturn
   */
  export type ContentUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * The data used to create many ContentUnits.
     */
    data: ContentUnitCreateManyInput | ContentUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentUnit update
   */
  export type ContentUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentUnit.
     */
    data: XOR<ContentUnitUpdateInput, ContentUnitUncheckedUpdateInput>
    /**
     * Choose, which ContentUnit to update.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit updateMany
   */
  export type ContentUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentUnits.
     */
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyInput>
    /**
     * Filter which ContentUnits to update
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to update.
     */
    limit?: number
  }

  /**
   * ContentUnit updateManyAndReturn
   */
  export type ContentUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * The data used to update ContentUnits.
     */
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyInput>
    /**
     * Filter which ContentUnits to update
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentUnit upsert
   */
  export type ContentUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentUnit to update in case it exists.
     */
    where: ContentUnitWhereUniqueInput
    /**
     * In case the ContentUnit found by the `where` argument doesn't exist, create a new ContentUnit with this data.
     */
    create: XOR<ContentUnitCreateInput, ContentUnitUncheckedCreateInput>
    /**
     * In case the ContentUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUnitUpdateInput, ContentUnitUncheckedUpdateInput>
  }

  /**
   * ContentUnit delete
   */
  export type ContentUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
    /**
     * Filter which ContentUnit to delete.
     */
    where: ContentUnitWhereUniqueInput
  }

  /**
   * ContentUnit deleteMany
   */
  export type ContentUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentUnits to delete
     */
    where?: ContentUnitWhereInput
    /**
     * Limit how many ContentUnits to delete.
     */
    limit?: number
  }

  /**
   * ContentUnit.Comments
   */
  export type ContentUnit$CommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * ContentUnit without action
   */
  export type ContentUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentUnit
     */
    select?: ContentUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentUnit
     */
    omit?: ContentUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentUnitInclude<ExtArgs> | null
  }


  /**
   * Model Disliked_Content
   */

  export type AggregateDisliked_Content = {
    _count: Disliked_ContentCountAggregateOutputType | null
    _avg: Disliked_ContentAvgAggregateOutputType | null
    _sum: Disliked_ContentSumAggregateOutputType | null
    _min: Disliked_ContentMinAggregateOutputType | null
    _max: Disliked_ContentMaxAggregateOutputType | null
  }

  export type Disliked_ContentAvgAggregateOutputType = {
    contentid: number | null
  }

  export type Disliked_ContentSumAggregateOutputType = {
    contentid: number | null
  }

  export type Disliked_ContentMinAggregateOutputType = {
    userid: string | null
    contentid: number | null
    mediatype: $Enums.MediaType | null
  }

  export type Disliked_ContentMaxAggregateOutputType = {
    userid: string | null
    contentid: number | null
    mediatype: $Enums.MediaType | null
  }

  export type Disliked_ContentCountAggregateOutputType = {
    userid: number
    contentid: number
    mediatype: number
    _all: number
  }


  export type Disliked_ContentAvgAggregateInputType = {
    contentid?: true
  }

  export type Disliked_ContentSumAggregateInputType = {
    contentid?: true
  }

  export type Disliked_ContentMinAggregateInputType = {
    userid?: true
    contentid?: true
    mediatype?: true
  }

  export type Disliked_ContentMaxAggregateInputType = {
    userid?: true
    contentid?: true
    mediatype?: true
  }

  export type Disliked_ContentCountAggregateInputType = {
    userid?: true
    contentid?: true
    mediatype?: true
    _all?: true
  }

  export type Disliked_ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disliked_Content to aggregate.
     */
    where?: Disliked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disliked_Contents to fetch.
     */
    orderBy?: Disliked_ContentOrderByWithRelationInput | Disliked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Disliked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disliked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disliked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disliked_Contents
    **/
    _count?: true | Disliked_ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Disliked_ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Disliked_ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Disliked_ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Disliked_ContentMaxAggregateInputType
  }

  export type GetDisliked_ContentAggregateType<T extends Disliked_ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateDisliked_Content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisliked_Content[P]>
      : GetScalarType<T[P], AggregateDisliked_Content[P]>
  }




  export type Disliked_ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Disliked_ContentWhereInput
    orderBy?: Disliked_ContentOrderByWithAggregationInput | Disliked_ContentOrderByWithAggregationInput[]
    by: Disliked_ContentScalarFieldEnum[] | Disliked_ContentScalarFieldEnum
    having?: Disliked_ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Disliked_ContentCountAggregateInputType | true
    _avg?: Disliked_ContentAvgAggregateInputType
    _sum?: Disliked_ContentSumAggregateInputType
    _min?: Disliked_ContentMinAggregateInputType
    _max?: Disliked_ContentMaxAggregateInputType
  }

  export type Disliked_ContentGroupByOutputType = {
    userid: string
    contentid: number
    mediatype: $Enums.MediaType
    _count: Disliked_ContentCountAggregateOutputType | null
    _avg: Disliked_ContentAvgAggregateOutputType | null
    _sum: Disliked_ContentSumAggregateOutputType | null
    _min: Disliked_ContentMinAggregateOutputType | null
    _max: Disliked_ContentMaxAggregateOutputType | null
  }

  type GetDisliked_ContentGroupByPayload<T extends Disliked_ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Disliked_ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Disliked_ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Disliked_ContentGroupByOutputType[P]>
            : GetScalarType<T[P], Disliked_ContentGroupByOutputType[P]>
        }
      >
    >


  export type Disliked_ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    contentid?: boolean
    mediatype?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disliked_Content"]>

  export type Disliked_ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    contentid?: boolean
    mediatype?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disliked_Content"]>

  export type Disliked_ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    contentid?: boolean
    mediatype?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disliked_Content"]>

  export type Disliked_ContentSelectScalar = {
    userid?: boolean
    contentid?: boolean
    mediatype?: boolean
  }

  export type Disliked_ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "contentid" | "mediatype", ExtArgs["result"]["disliked_Content"]>
  export type Disliked_ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Disliked_ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Disliked_ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $Disliked_ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Disliked_Content"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      contentid: number
      mediatype: $Enums.MediaType
    }, ExtArgs["result"]["disliked_Content"]>
    composites: {}
  }

  type Disliked_ContentGetPayload<S extends boolean | null | undefined | Disliked_ContentDefaultArgs> = $Result.GetResult<Prisma.$Disliked_ContentPayload, S>

  type Disliked_ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Disliked_ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Disliked_ContentCountAggregateInputType | true
    }

  export interface Disliked_ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Disliked_Content'], meta: { name: 'Disliked_Content' } }
    /**
     * Find zero or one Disliked_Content that matches the filter.
     * @param {Disliked_ContentFindUniqueArgs} args - Arguments to find a Disliked_Content
     * @example
     * // Get one Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Disliked_ContentFindUniqueArgs>(args: SelectSubset<T, Disliked_ContentFindUniqueArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Disliked_Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Disliked_ContentFindUniqueOrThrowArgs} args - Arguments to find a Disliked_Content
     * @example
     * // Get one Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Disliked_ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, Disliked_ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disliked_Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentFindFirstArgs} args - Arguments to find a Disliked_Content
     * @example
     * // Get one Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Disliked_ContentFindFirstArgs>(args?: SelectSubset<T, Disliked_ContentFindFirstArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disliked_Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentFindFirstOrThrowArgs} args - Arguments to find a Disliked_Content
     * @example
     * // Get one Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Disliked_ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, Disliked_ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disliked_Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disliked_Contents
     * const disliked_Contents = await prisma.disliked_Content.findMany()
     * 
     * // Get first 10 Disliked_Contents
     * const disliked_Contents = await prisma.disliked_Content.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const disliked_ContentWithUseridOnly = await prisma.disliked_Content.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends Disliked_ContentFindManyArgs>(args?: SelectSubset<T, Disliked_ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Disliked_Content.
     * @param {Disliked_ContentCreateArgs} args - Arguments to create a Disliked_Content.
     * @example
     * // Create one Disliked_Content
     * const Disliked_Content = await prisma.disliked_Content.create({
     *   data: {
     *     // ... data to create a Disliked_Content
     *   }
     * })
     * 
     */
    create<T extends Disliked_ContentCreateArgs>(args: SelectSubset<T, Disliked_ContentCreateArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disliked_Contents.
     * @param {Disliked_ContentCreateManyArgs} args - Arguments to create many Disliked_Contents.
     * @example
     * // Create many Disliked_Contents
     * const disliked_Content = await prisma.disliked_Content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Disliked_ContentCreateManyArgs>(args?: SelectSubset<T, Disliked_ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disliked_Contents and returns the data saved in the database.
     * @param {Disliked_ContentCreateManyAndReturnArgs} args - Arguments to create many Disliked_Contents.
     * @example
     * // Create many Disliked_Contents
     * const disliked_Content = await prisma.disliked_Content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disliked_Contents and only return the `userid`
     * const disliked_ContentWithUseridOnly = await prisma.disliked_Content.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Disliked_ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, Disliked_ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Disliked_Content.
     * @param {Disliked_ContentDeleteArgs} args - Arguments to delete one Disliked_Content.
     * @example
     * // Delete one Disliked_Content
     * const Disliked_Content = await prisma.disliked_Content.delete({
     *   where: {
     *     // ... filter to delete one Disliked_Content
     *   }
     * })
     * 
     */
    delete<T extends Disliked_ContentDeleteArgs>(args: SelectSubset<T, Disliked_ContentDeleteArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Disliked_Content.
     * @param {Disliked_ContentUpdateArgs} args - Arguments to update one Disliked_Content.
     * @example
     * // Update one Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Disliked_ContentUpdateArgs>(args: SelectSubset<T, Disliked_ContentUpdateArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disliked_Contents.
     * @param {Disliked_ContentDeleteManyArgs} args - Arguments to filter Disliked_Contents to delete.
     * @example
     * // Delete a few Disliked_Contents
     * const { count } = await prisma.disliked_Content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Disliked_ContentDeleteManyArgs>(args?: SelectSubset<T, Disliked_ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disliked_Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disliked_Contents
     * const disliked_Content = await prisma.disliked_Content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Disliked_ContentUpdateManyArgs>(args: SelectSubset<T, Disliked_ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disliked_Contents and returns the data updated in the database.
     * @param {Disliked_ContentUpdateManyAndReturnArgs} args - Arguments to update many Disliked_Contents.
     * @example
     * // Update many Disliked_Contents
     * const disliked_Content = await prisma.disliked_Content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Disliked_Contents and only return the `userid`
     * const disliked_ContentWithUseridOnly = await prisma.disliked_Content.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Disliked_ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, Disliked_ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Disliked_Content.
     * @param {Disliked_ContentUpsertArgs} args - Arguments to update or create a Disliked_Content.
     * @example
     * // Update or create a Disliked_Content
     * const disliked_Content = await prisma.disliked_Content.upsert({
     *   create: {
     *     // ... data to create a Disliked_Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disliked_Content we want to update
     *   }
     * })
     */
    upsert<T extends Disliked_ContentUpsertArgs>(args: SelectSubset<T, Disliked_ContentUpsertArgs<ExtArgs>>): Prisma__Disliked_ContentClient<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disliked_Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentCountArgs} args - Arguments to filter Disliked_Contents to count.
     * @example
     * // Count the number of Disliked_Contents
     * const count = await prisma.disliked_Content.count({
     *   where: {
     *     // ... the filter for the Disliked_Contents we want to count
     *   }
     * })
    **/
    count<T extends Disliked_ContentCountArgs>(
      args?: Subset<T, Disliked_ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Disliked_ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disliked_Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Disliked_ContentAggregateArgs>(args: Subset<T, Disliked_ContentAggregateArgs>): Prisma.PrismaPromise<GetDisliked_ContentAggregateType<T>>

    /**
     * Group by Disliked_Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Disliked_ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Disliked_ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Disliked_ContentGroupByArgs['orderBy'] }
        : { orderBy?: Disliked_ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Disliked_ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisliked_ContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Disliked_Content model
   */
  readonly fields: Disliked_ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Disliked_Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Disliked_ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Disliked_Content model
   */ 
  interface Disliked_ContentFieldRefs {
    readonly userid: FieldRef<"Disliked_Content", 'String'>
    readonly contentid: FieldRef<"Disliked_Content", 'Int'>
    readonly mediatype: FieldRef<"Disliked_Content", 'MediaType'>
  }
    

  // Custom InputTypes
  /**
   * Disliked_Content findUnique
   */
  export type Disliked_ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Disliked_Content to fetch.
     */
    where: Disliked_ContentWhereUniqueInput
  }

  /**
   * Disliked_Content findUniqueOrThrow
   */
  export type Disliked_ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Disliked_Content to fetch.
     */
    where: Disliked_ContentWhereUniqueInput
  }

  /**
   * Disliked_Content findFirst
   */
  export type Disliked_ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Disliked_Content to fetch.
     */
    where?: Disliked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disliked_Contents to fetch.
     */
    orderBy?: Disliked_ContentOrderByWithRelationInput | Disliked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disliked_Contents.
     */
    cursor?: Disliked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disliked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disliked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disliked_Contents.
     */
    distinct?: Disliked_ContentScalarFieldEnum | Disliked_ContentScalarFieldEnum[]
  }

  /**
   * Disliked_Content findFirstOrThrow
   */
  export type Disliked_ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Disliked_Content to fetch.
     */
    where?: Disliked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disliked_Contents to fetch.
     */
    orderBy?: Disliked_ContentOrderByWithRelationInput | Disliked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disliked_Contents.
     */
    cursor?: Disliked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disliked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disliked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disliked_Contents.
     */
    distinct?: Disliked_ContentScalarFieldEnum | Disliked_ContentScalarFieldEnum[]
  }

  /**
   * Disliked_Content findMany
   */
  export type Disliked_ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Disliked_Contents to fetch.
     */
    where?: Disliked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disliked_Contents to fetch.
     */
    orderBy?: Disliked_ContentOrderByWithRelationInput | Disliked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disliked_Contents.
     */
    cursor?: Disliked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disliked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disliked_Contents.
     */
    skip?: number
    distinct?: Disliked_ContentScalarFieldEnum | Disliked_ContentScalarFieldEnum[]
  }

  /**
   * Disliked_Content create
   */
  export type Disliked_ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Disliked_Content.
     */
    data: XOR<Disliked_ContentCreateInput, Disliked_ContentUncheckedCreateInput>
  }

  /**
   * Disliked_Content createMany
   */
  export type Disliked_ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disliked_Contents.
     */
    data: Disliked_ContentCreateManyInput | Disliked_ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Disliked_Content createManyAndReturn
   */
  export type Disliked_ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Disliked_Contents.
     */
    data: Disliked_ContentCreateManyInput | Disliked_ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Disliked_Content update
   */
  export type Disliked_ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Disliked_Content.
     */
    data: XOR<Disliked_ContentUpdateInput, Disliked_ContentUncheckedUpdateInput>
    /**
     * Choose, which Disliked_Content to update.
     */
    where: Disliked_ContentWhereUniqueInput
  }

  /**
   * Disliked_Content updateMany
   */
  export type Disliked_ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disliked_Contents.
     */
    data: XOR<Disliked_ContentUpdateManyMutationInput, Disliked_ContentUncheckedUpdateManyInput>
    /**
     * Filter which Disliked_Contents to update
     */
    where?: Disliked_ContentWhereInput
    /**
     * Limit how many Disliked_Contents to update.
     */
    limit?: number
  }

  /**
   * Disliked_Content updateManyAndReturn
   */
  export type Disliked_ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * The data used to update Disliked_Contents.
     */
    data: XOR<Disliked_ContentUpdateManyMutationInput, Disliked_ContentUncheckedUpdateManyInput>
    /**
     * Filter which Disliked_Contents to update
     */
    where?: Disliked_ContentWhereInput
    /**
     * Limit how many Disliked_Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Disliked_Content upsert
   */
  export type Disliked_ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Disliked_Content to update in case it exists.
     */
    where: Disliked_ContentWhereUniqueInput
    /**
     * In case the Disliked_Content found by the `where` argument doesn't exist, create a new Disliked_Content with this data.
     */
    create: XOR<Disliked_ContentCreateInput, Disliked_ContentUncheckedCreateInput>
    /**
     * In case the Disliked_Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Disliked_ContentUpdateInput, Disliked_ContentUncheckedUpdateInput>
  }

  /**
   * Disliked_Content delete
   */
  export type Disliked_ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    /**
     * Filter which Disliked_Content to delete.
     */
    where: Disliked_ContentWhereUniqueInput
  }

  /**
   * Disliked_Content deleteMany
   */
  export type Disliked_ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disliked_Contents to delete
     */
    where?: Disliked_ContentWhereInput
    /**
     * Limit how many Disliked_Contents to delete.
     */
    limit?: number
  }

  /**
   * Disliked_Content without action
   */
  export type Disliked_ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
    downloadCount: number | null
  }

  export type FileSumAggregateOutputType = {
    size: bigint | null
    downloadCount: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    path: string | null
    extension: string | null
    folderId: string | null
    size: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessed: Date | null
    isShared: boolean | null
    ownerId: string | null
    checksum: string | null
    downloadCount: number | null
    previewEnabled: boolean | null
    isPublic: boolean | null
    filetype: $Enums.FileType | null
    location: $Enums.MediaType | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    path: string | null
    extension: string | null
    folderId: string | null
    size: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessed: Date | null
    isShared: boolean | null
    ownerId: string | null
    checksum: string | null
    downloadCount: number | null
    previewEnabled: boolean | null
    isPublic: boolean | null
    filetype: $Enums.FileType | null
    location: $Enums.MediaType | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    description: number
    path: number
    extension: number
    folderId: number
    size: number
    createdAt: number
    updatedAt: number
    lastAccessed: number
    isShared: number
    ownerId: number
    tags: number
    checksum: number
    downloadCount: number
    previewEnabled: number
    isPublic: number
    filetype: number
    location: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
    downloadCount?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
    downloadCount?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    path?: true
    extension?: true
    folderId?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    isShared?: true
    ownerId?: true
    checksum?: true
    downloadCount?: true
    previewEnabled?: true
    isPublic?: true
    filetype?: true
    location?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    path?: true
    extension?: true
    folderId?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    isShared?: true
    ownerId?: true
    checksum?: true
    downloadCount?: true
    previewEnabled?: true
    isPublic?: true
    filetype?: true
    location?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    path?: true
    extension?: true
    folderId?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    isShared?: true
    ownerId?: true
    tags?: true
    checksum?: true
    downloadCount?: true
    previewEnabled?: true
    isPublic?: true
    filetype?: true
    location?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    description: string | null
    path: string
    extension: string
    folderId: string | null
    size: bigint
    createdAt: Date
    updatedAt: Date | null
    lastAccessed: Date | null
    isShared: boolean
    ownerId: string
    tags: string[]
    checksum: string | null
    downloadCount: number
    previewEnabled: boolean
    isPublic: boolean
    filetype: $Enums.FileType
    location: $Enums.MediaType
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    path?: boolean
    extension?: boolean
    folderId?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    isShared?: boolean
    ownerId?: boolean
    tags?: boolean
    checksum?: boolean
    downloadCount?: boolean
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: boolean
    location?: boolean
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    FileShares?: boolean | File$FileSharesArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    path?: boolean
    extension?: boolean
    folderId?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    isShared?: boolean
    ownerId?: boolean
    tags?: boolean
    checksum?: boolean
    downloadCount?: boolean
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: boolean
    location?: boolean
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    path?: boolean
    extension?: boolean
    folderId?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    isShared?: boolean
    ownerId?: boolean
    tags?: boolean
    checksum?: boolean
    downloadCount?: boolean
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: boolean
    location?: boolean
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    path?: boolean
    extension?: boolean
    folderId?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    isShared?: boolean
    ownerId?: boolean
    tags?: boolean
    checksum?: boolean
    downloadCount?: boolean
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: boolean
    location?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "path" | "extension" | "folderId" | "size" | "createdAt" | "updatedAt" | "lastAccessed" | "isShared" | "ownerId" | "tags" | "checksum" | "downloadCount" | "previewEnabled" | "isPublic" | "filetype" | "location", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    FileShares?: boolean | File$FileSharesArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | File$FolderArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      Folder: Prisma.$FolderPayload<ExtArgs> | null
      Users: Prisma.$UsersPayload<ExtArgs>
      FileShares: Prisma.$FileSharesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      path: string
      extension: string
      folderId: string | null
      size: bigint
      createdAt: Date
      updatedAt: Date | null
      lastAccessed: Date | null
      isShared: boolean
      ownerId: string
      tags: string[]
      checksum: string | null
      downloadCount: number
      previewEnabled: boolean
      isPublic: boolean
      filetype: $Enums.FileType
      location: $Enums.MediaType
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Folder<T extends File$FolderArgs<ExtArgs> = {}>(args?: Subset<T, File$FolderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FileShares<T extends File$FileSharesArgs<ExtArgs> = {}>(args?: Subset<T, File$FileSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly description: FieldRef<"File", 'String'>
    readonly path: FieldRef<"File", 'String'>
    readonly extension: FieldRef<"File", 'String'>
    readonly folderId: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'BigInt'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly lastAccessed: FieldRef<"File", 'DateTime'>
    readonly isShared: FieldRef<"File", 'Boolean'>
    readonly ownerId: FieldRef<"File", 'String'>
    readonly tags: FieldRef<"File", 'String[]'>
    readonly checksum: FieldRef<"File", 'String'>
    readonly downloadCount: FieldRef<"File", 'Int'>
    readonly previewEnabled: FieldRef<"File", 'Boolean'>
    readonly isPublic: FieldRef<"File", 'Boolean'>
    readonly filetype: FieldRef<"File", 'FileType'>
    readonly location: FieldRef<"File", 'MediaType'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.Folder
   */
  export type File$FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * File.FileShares
   */
  export type File$FileSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    where?: FileSharesWhereInput
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    cursor?: FileSharesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileSharesScalarFieldEnum | FileSharesScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model FileShares
   */

  export type AggregateFileShares = {
    _count: FileSharesCountAggregateOutputType | null
    _min: FileSharesMinAggregateOutputType | null
    _max: FileSharesMaxAggregateOutputType | null
  }

  export type FileSharesMinAggregateOutputType = {
    userId: string | null
    fileId: string | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type FileSharesMaxAggregateOutputType = {
    userId: string | null
    fileId: string | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type FileSharesCountAggregateOutputType = {
    userId: number
    fileId: number
    accessLevel: number
    _all: number
  }


  export type FileSharesMinAggregateInputType = {
    userId?: true
    fileId?: true
    accessLevel?: true
  }

  export type FileSharesMaxAggregateInputType = {
    userId?: true
    fileId?: true
    accessLevel?: true
  }

  export type FileSharesCountAggregateInputType = {
    userId?: true
    fileId?: true
    accessLevel?: true
    _all?: true
  }

  export type FileSharesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileShares to aggregate.
     */
    where?: FileSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileShares to fetch.
     */
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileShares
    **/
    _count?: true | FileSharesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileSharesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileSharesMaxAggregateInputType
  }

  export type GetFileSharesAggregateType<T extends FileSharesAggregateArgs> = {
        [P in keyof T & keyof AggregateFileShares]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileShares[P]>
      : GetScalarType<T[P], AggregateFileShares[P]>
  }




  export type FileSharesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileSharesWhereInput
    orderBy?: FileSharesOrderByWithAggregationInput | FileSharesOrderByWithAggregationInput[]
    by: FileSharesScalarFieldEnum[] | FileSharesScalarFieldEnum
    having?: FileSharesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileSharesCountAggregateInputType | true
    _min?: FileSharesMinAggregateInputType
    _max?: FileSharesMaxAggregateInputType
  }

  export type FileSharesGroupByOutputType = {
    userId: string
    fileId: string
    accessLevel: $Enums.AccessLevel
    _count: FileSharesCountAggregateOutputType | null
    _min: FileSharesMinAggregateOutputType | null
    _max: FileSharesMaxAggregateOutputType | null
  }

  type GetFileSharesGroupByPayload<T extends FileSharesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileSharesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileSharesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileSharesGroupByOutputType[P]>
            : GetScalarType<T[P], FileSharesGroupByOutputType[P]>
        }
      >
    >


  export type FileSharesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fileId?: boolean
    accessLevel?: boolean
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileShares"]>

  export type FileSharesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fileId?: boolean
    accessLevel?: boolean
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileShares"]>

  export type FileSharesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fileId?: boolean
    accessLevel?: boolean
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileShares"]>

  export type FileSharesSelectScalar = {
    userId?: boolean
    fileId?: boolean
    accessLevel?: boolean
  }

  export type FileSharesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "fileId" | "accessLevel", ExtArgs["result"]["fileShares"]>
  export type FileSharesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FileSharesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FileSharesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | FileDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FileSharesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileShares"
    objects: {
      File: Prisma.$FilePayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      fileId: string
      accessLevel: $Enums.AccessLevel
    }, ExtArgs["result"]["fileShares"]>
    composites: {}
  }

  type FileSharesGetPayload<S extends boolean | null | undefined | FileSharesDefaultArgs> = $Result.GetResult<Prisma.$FileSharesPayload, S>

  type FileSharesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileSharesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileSharesCountAggregateInputType | true
    }

  export interface FileSharesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileShares'], meta: { name: 'FileShares' } }
    /**
     * Find zero or one FileShares that matches the filter.
     * @param {FileSharesFindUniqueArgs} args - Arguments to find a FileShares
     * @example
     * // Get one FileShares
     * const fileShares = await prisma.fileShares.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileSharesFindUniqueArgs>(args: SelectSubset<T, FileSharesFindUniqueArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileShares that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileSharesFindUniqueOrThrowArgs} args - Arguments to find a FileShares
     * @example
     * // Get one FileShares
     * const fileShares = await prisma.fileShares.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileSharesFindUniqueOrThrowArgs>(args: SelectSubset<T, FileSharesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesFindFirstArgs} args - Arguments to find a FileShares
     * @example
     * // Get one FileShares
     * const fileShares = await prisma.fileShares.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileSharesFindFirstArgs>(args?: SelectSubset<T, FileSharesFindFirstArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileShares that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesFindFirstOrThrowArgs} args - Arguments to find a FileShares
     * @example
     * // Get one FileShares
     * const fileShares = await prisma.fileShares.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileSharesFindFirstOrThrowArgs>(args?: SelectSubset<T, FileSharesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileShares
     * const fileShares = await prisma.fileShares.findMany()
     * 
     * // Get first 10 FileShares
     * const fileShares = await prisma.fileShares.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const fileSharesWithUserIdOnly = await prisma.fileShares.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends FileSharesFindManyArgs>(args?: SelectSubset<T, FileSharesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileShares.
     * @param {FileSharesCreateArgs} args - Arguments to create a FileShares.
     * @example
     * // Create one FileShares
     * const FileShares = await prisma.fileShares.create({
     *   data: {
     *     // ... data to create a FileShares
     *   }
     * })
     * 
     */
    create<T extends FileSharesCreateArgs>(args: SelectSubset<T, FileSharesCreateArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileShares.
     * @param {FileSharesCreateManyArgs} args - Arguments to create many FileShares.
     * @example
     * // Create many FileShares
     * const fileShares = await prisma.fileShares.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileSharesCreateManyArgs>(args?: SelectSubset<T, FileSharesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileShares and returns the data saved in the database.
     * @param {FileSharesCreateManyAndReturnArgs} args - Arguments to create many FileShares.
     * @example
     * // Create many FileShares
     * const fileShares = await prisma.fileShares.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileShares and only return the `userId`
     * const fileSharesWithUserIdOnly = await prisma.fileShares.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileSharesCreateManyAndReturnArgs>(args?: SelectSubset<T, FileSharesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileShares.
     * @param {FileSharesDeleteArgs} args - Arguments to delete one FileShares.
     * @example
     * // Delete one FileShares
     * const FileShares = await prisma.fileShares.delete({
     *   where: {
     *     // ... filter to delete one FileShares
     *   }
     * })
     * 
     */
    delete<T extends FileSharesDeleteArgs>(args: SelectSubset<T, FileSharesDeleteArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileShares.
     * @param {FileSharesUpdateArgs} args - Arguments to update one FileShares.
     * @example
     * // Update one FileShares
     * const fileShares = await prisma.fileShares.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileSharesUpdateArgs>(args: SelectSubset<T, FileSharesUpdateArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileShares.
     * @param {FileSharesDeleteManyArgs} args - Arguments to filter FileShares to delete.
     * @example
     * // Delete a few FileShares
     * const { count } = await prisma.fileShares.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileSharesDeleteManyArgs>(args?: SelectSubset<T, FileSharesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileShares
     * const fileShares = await prisma.fileShares.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileSharesUpdateManyArgs>(args: SelectSubset<T, FileSharesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileShares and returns the data updated in the database.
     * @param {FileSharesUpdateManyAndReturnArgs} args - Arguments to update many FileShares.
     * @example
     * // Update many FileShares
     * const fileShares = await prisma.fileShares.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileShares and only return the `userId`
     * const fileSharesWithUserIdOnly = await prisma.fileShares.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileSharesUpdateManyAndReturnArgs>(args: SelectSubset<T, FileSharesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileShares.
     * @param {FileSharesUpsertArgs} args - Arguments to update or create a FileShares.
     * @example
     * // Update or create a FileShares
     * const fileShares = await prisma.fileShares.upsert({
     *   create: {
     *     // ... data to create a FileShares
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileShares we want to update
     *   }
     * })
     */
    upsert<T extends FileSharesUpsertArgs>(args: SelectSubset<T, FileSharesUpsertArgs<ExtArgs>>): Prisma__FileSharesClient<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesCountArgs} args - Arguments to filter FileShares to count.
     * @example
     * // Count the number of FileShares
     * const count = await prisma.fileShares.count({
     *   where: {
     *     // ... the filter for the FileShares we want to count
     *   }
     * })
    **/
    count<T extends FileSharesCountArgs>(
      args?: Subset<T, FileSharesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileSharesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileSharesAggregateArgs>(args: Subset<T, FileSharesAggregateArgs>): Prisma.PrismaPromise<GetFileSharesAggregateType<T>>

    /**
     * Group by FileShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSharesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileSharesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileSharesGroupByArgs['orderBy'] }
        : { orderBy?: FileSharesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileSharesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileSharesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileShares model
   */
  readonly fields: FileSharesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileShares.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileSharesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    File<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileShares model
   */ 
  interface FileSharesFieldRefs {
    readonly userId: FieldRef<"FileShares", 'String'>
    readonly fileId: FieldRef<"FileShares", 'String'>
    readonly accessLevel: FieldRef<"FileShares", 'AccessLevel'>
  }
    

  // Custom InputTypes
  /**
   * FileShares findUnique
   */
  export type FileSharesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter, which FileShares to fetch.
     */
    where: FileSharesWhereUniqueInput
  }

  /**
   * FileShares findUniqueOrThrow
   */
  export type FileSharesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter, which FileShares to fetch.
     */
    where: FileSharesWhereUniqueInput
  }

  /**
   * FileShares findFirst
   */
  export type FileSharesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter, which FileShares to fetch.
     */
    where?: FileSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileShares to fetch.
     */
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileShares.
     */
    cursor?: FileSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileShares.
     */
    distinct?: FileSharesScalarFieldEnum | FileSharesScalarFieldEnum[]
  }

  /**
   * FileShares findFirstOrThrow
   */
  export type FileSharesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter, which FileShares to fetch.
     */
    where?: FileSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileShares to fetch.
     */
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileShares.
     */
    cursor?: FileSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileShares.
     */
    distinct?: FileSharesScalarFieldEnum | FileSharesScalarFieldEnum[]
  }

  /**
   * FileShares findMany
   */
  export type FileSharesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter, which FileShares to fetch.
     */
    where?: FileSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileShares to fetch.
     */
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileShares.
     */
    cursor?: FileSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileShares.
     */
    skip?: number
    distinct?: FileSharesScalarFieldEnum | FileSharesScalarFieldEnum[]
  }

  /**
   * FileShares create
   */
  export type FileSharesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * The data needed to create a FileShares.
     */
    data: XOR<FileSharesCreateInput, FileSharesUncheckedCreateInput>
  }

  /**
   * FileShares createMany
   */
  export type FileSharesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileShares.
     */
    data: FileSharesCreateManyInput | FileSharesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileShares createManyAndReturn
   */
  export type FileSharesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * The data used to create many FileShares.
     */
    data: FileSharesCreateManyInput | FileSharesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileShares update
   */
  export type FileSharesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * The data needed to update a FileShares.
     */
    data: XOR<FileSharesUpdateInput, FileSharesUncheckedUpdateInput>
    /**
     * Choose, which FileShares to update.
     */
    where: FileSharesWhereUniqueInput
  }

  /**
   * FileShares updateMany
   */
  export type FileSharesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileShares.
     */
    data: XOR<FileSharesUpdateManyMutationInput, FileSharesUncheckedUpdateManyInput>
    /**
     * Filter which FileShares to update
     */
    where?: FileSharesWhereInput
    /**
     * Limit how many FileShares to update.
     */
    limit?: number
  }

  /**
   * FileShares updateManyAndReturn
   */
  export type FileSharesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * The data used to update FileShares.
     */
    data: XOR<FileSharesUpdateManyMutationInput, FileSharesUncheckedUpdateManyInput>
    /**
     * Filter which FileShares to update
     */
    where?: FileSharesWhereInput
    /**
     * Limit how many FileShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileShares upsert
   */
  export type FileSharesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * The filter to search for the FileShares to update in case it exists.
     */
    where: FileSharesWhereUniqueInput
    /**
     * In case the FileShares found by the `where` argument doesn't exist, create a new FileShares with this data.
     */
    create: XOR<FileSharesCreateInput, FileSharesUncheckedCreateInput>
    /**
     * In case the FileShares was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileSharesUpdateInput, FileSharesUncheckedUpdateInput>
  }

  /**
   * FileShares delete
   */
  export type FileSharesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    /**
     * Filter which FileShares to delete.
     */
    where: FileSharesWhereUniqueInput
  }

  /**
   * FileShares deleteMany
   */
  export type FileSharesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileShares to delete
     */
    where?: FileSharesWhereInput
    /**
     * Limit how many FileShares to delete.
     */
    limit?: number
  }

  /**
   * FileShares without action
   */
  export type FileSharesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _avg: FolderAvgAggregateOutputType | null
    _sum: FolderSumAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderAvgAggregateOutputType = {
    accessCount: number | null
    totalSize: number | null
  }

  export type FolderSumAggregateOutputType = {
    accessCount: number | null
    totalSize: number | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessed: Date | null
    ownerId: string | null
    accessCount: number | null
    totalSize: number | null
    parentFolderId: string | null
    filetype: $Enums.FileType | null
    location: $Enums.MediaType | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastAccessed: Date | null
    ownerId: string | null
    accessCount: number | null
    totalSize: number | null
    parentFolderId: string | null
    filetype: $Enums.FileType | null
    location: $Enums.MediaType | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    lastAccessed: number
    ownerId: number
    tags: number
    accessCount: number
    totalSize: number
    parentFolderId: number
    filetype: number
    location: number
    _all: number
  }


  export type FolderAvgAggregateInputType = {
    accessCount?: true
    totalSize?: true
  }

  export type FolderSumAggregateInputType = {
    accessCount?: true
    totalSize?: true
  }

  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    ownerId?: true
    accessCount?: true
    totalSize?: true
    parentFolderId?: true
    filetype?: true
    location?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    ownerId?: true
    accessCount?: true
    totalSize?: true
    parentFolderId?: true
    filetype?: true
    location?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    lastAccessed?: true
    ownerId?: true
    tags?: true
    accessCount?: true
    totalSize?: true
    parentFolderId?: true
    filetype?: true
    location?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FolderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FolderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _avg?: FolderAvgAggregateInputType
    _sum?: FolderSumAggregateInputType
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date | null
    lastAccessed: Date | null
    ownerId: string
    tags: string[]
    accessCount: number
    totalSize: number
    parentFolderId: string | null
    filetype: $Enums.FileType
    location: $Enums.MediaType
    _count: FolderCountAggregateOutputType | null
    _avg: FolderAvgAggregateOutputType | null
    _sum: FolderSumAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    ownerId?: boolean
    tags?: boolean
    accessCount?: boolean
    totalSize?: boolean
    parentFolderId?: boolean
    filetype?: boolean
    location?: boolean
    File?: boolean | Folder$FileArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
    other_Folder?: boolean | Folder$other_FolderArgs<ExtArgs>
    FolderShares?: boolean | Folder$FolderSharesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    ownerId?: boolean
    tags?: boolean
    accessCount?: boolean
    totalSize?: boolean
    parentFolderId?: boolean
    filetype?: boolean
    location?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    ownerId?: boolean
    tags?: boolean
    accessCount?: boolean
    totalSize?: boolean
    parentFolderId?: boolean
    filetype?: boolean
    location?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastAccessed?: boolean
    ownerId?: boolean
    tags?: boolean
    accessCount?: boolean
    totalSize?: boolean
    parentFolderId?: boolean
    filetype?: boolean
    location?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "lastAccessed" | "ownerId" | "tags" | "accessCount" | "totalSize" | "parentFolderId" | "filetype" | "location", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    File?: boolean | Folder$FileArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
    other_Folder?: boolean | Folder$other_FolderArgs<ExtArgs>
    FolderShares?: boolean | Folder$FolderSharesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Folder?: boolean | Folder$FolderArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      File: Prisma.$FilePayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
      Folder: Prisma.$FolderPayload<ExtArgs> | null
      other_Folder: Prisma.$FolderPayload<ExtArgs>[]
      FolderShares: Prisma.$FolderSharesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date | null
      lastAccessed: Date | null
      ownerId: string
      tags: string[]
      accessCount: number
      totalSize: number
      parentFolderId: string | null
      filetype: $Enums.FileType
      location: $Enums.MediaType
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    File<T extends Folder$FileArgs<ExtArgs> = {}>(args?: Subset<T, Folder$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Folder<T extends Folder$FolderArgs<ExtArgs> = {}>(args?: Subset<T, Folder$FolderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_Folder<T extends Folder$other_FolderArgs<ExtArgs> = {}>(args?: Subset<T, Folder$other_FolderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FolderShares<T extends Folder$FolderSharesArgs<ExtArgs> = {}>(args?: Subset<T, Folder$FolderSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */ 
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly description: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
    readonly lastAccessed: FieldRef<"Folder", 'DateTime'>
    readonly ownerId: FieldRef<"Folder", 'String'>
    readonly tags: FieldRef<"Folder", 'String[]'>
    readonly accessCount: FieldRef<"Folder", 'Int'>
    readonly totalSize: FieldRef<"Folder", 'Int'>
    readonly parentFolderId: FieldRef<"Folder", 'String'>
    readonly filetype: FieldRef<"Folder", 'FileType'>
    readonly location: FieldRef<"Folder", 'MediaType'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.File
   */
  export type Folder$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Folder.Folder
   */
  export type Folder$FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Folder.other_Folder
   */
  export type Folder$other_FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder.FolderShares
   */
  export type Folder$FolderSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    where?: FolderSharesWhereInput
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    cursor?: FolderSharesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderSharesScalarFieldEnum | FolderSharesScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model FolderShares
   */

  export type AggregateFolderShares = {
    _count: FolderSharesCountAggregateOutputType | null
    _min: FolderSharesMinAggregateOutputType | null
    _max: FolderSharesMaxAggregateOutputType | null
  }

  export type FolderSharesMinAggregateOutputType = {
    userId: string | null
    folderId: string | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type FolderSharesMaxAggregateOutputType = {
    userId: string | null
    folderId: string | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type FolderSharesCountAggregateOutputType = {
    userId: number
    folderId: number
    accessLevel: number
    _all: number
  }


  export type FolderSharesMinAggregateInputType = {
    userId?: true
    folderId?: true
    accessLevel?: true
  }

  export type FolderSharesMaxAggregateInputType = {
    userId?: true
    folderId?: true
    accessLevel?: true
  }

  export type FolderSharesCountAggregateInputType = {
    userId?: true
    folderId?: true
    accessLevel?: true
    _all?: true
  }

  export type FolderSharesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FolderShares to aggregate.
     */
    where?: FolderSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderShares to fetch.
     */
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FolderShares
    **/
    _count?: true | FolderSharesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderSharesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderSharesMaxAggregateInputType
  }

  export type GetFolderSharesAggregateType<T extends FolderSharesAggregateArgs> = {
        [P in keyof T & keyof AggregateFolderShares]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolderShares[P]>
      : GetScalarType<T[P], AggregateFolderShares[P]>
  }




  export type FolderSharesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderSharesWhereInput
    orderBy?: FolderSharesOrderByWithAggregationInput | FolderSharesOrderByWithAggregationInput[]
    by: FolderSharesScalarFieldEnum[] | FolderSharesScalarFieldEnum
    having?: FolderSharesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderSharesCountAggregateInputType | true
    _min?: FolderSharesMinAggregateInputType
    _max?: FolderSharesMaxAggregateInputType
  }

  export type FolderSharesGroupByOutputType = {
    userId: string
    folderId: string
    accessLevel: $Enums.AccessLevel
    _count: FolderSharesCountAggregateOutputType | null
    _min: FolderSharesMinAggregateOutputType | null
    _max: FolderSharesMaxAggregateOutputType | null
  }

  type GetFolderSharesGroupByPayload<T extends FolderSharesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderSharesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderSharesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderSharesGroupByOutputType[P]>
            : GetScalarType<T[P], FolderSharesGroupByOutputType[P]>
        }
      >
    >


  export type FolderSharesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    folderId?: boolean
    accessLevel?: boolean
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderShares"]>

  export type FolderSharesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    folderId?: boolean
    accessLevel?: boolean
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderShares"]>

  export type FolderSharesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    folderId?: boolean
    accessLevel?: boolean
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderShares"]>

  export type FolderSharesSelectScalar = {
    userId?: boolean
    folderId?: boolean
    accessLevel?: boolean
  }

  export type FolderSharesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "folderId" | "accessLevel", ExtArgs["result"]["folderShares"]>
  export type FolderSharesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FolderSharesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FolderSharesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Folder?: boolean | FolderDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FolderSharesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FolderShares"
    objects: {
      Folder: Prisma.$FolderPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      folderId: string
      accessLevel: $Enums.AccessLevel
    }, ExtArgs["result"]["folderShares"]>
    composites: {}
  }

  type FolderSharesGetPayload<S extends boolean | null | undefined | FolderSharesDefaultArgs> = $Result.GetResult<Prisma.$FolderSharesPayload, S>

  type FolderSharesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderSharesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderSharesCountAggregateInputType | true
    }

  export interface FolderSharesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FolderShares'], meta: { name: 'FolderShares' } }
    /**
     * Find zero or one FolderShares that matches the filter.
     * @param {FolderSharesFindUniqueArgs} args - Arguments to find a FolderShares
     * @example
     * // Get one FolderShares
     * const folderShares = await prisma.folderShares.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderSharesFindUniqueArgs>(args: SelectSubset<T, FolderSharesFindUniqueArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FolderShares that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderSharesFindUniqueOrThrowArgs} args - Arguments to find a FolderShares
     * @example
     * // Get one FolderShares
     * const folderShares = await prisma.folderShares.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderSharesFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderSharesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FolderShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesFindFirstArgs} args - Arguments to find a FolderShares
     * @example
     * // Get one FolderShares
     * const folderShares = await prisma.folderShares.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderSharesFindFirstArgs>(args?: SelectSubset<T, FolderSharesFindFirstArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FolderShares that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesFindFirstOrThrowArgs} args - Arguments to find a FolderShares
     * @example
     * // Get one FolderShares
     * const folderShares = await prisma.folderShares.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderSharesFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderSharesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FolderShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FolderShares
     * const folderShares = await prisma.folderShares.findMany()
     * 
     * // Get first 10 FolderShares
     * const folderShares = await prisma.folderShares.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const folderSharesWithUserIdOnly = await prisma.folderShares.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends FolderSharesFindManyArgs>(args?: SelectSubset<T, FolderSharesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FolderShares.
     * @param {FolderSharesCreateArgs} args - Arguments to create a FolderShares.
     * @example
     * // Create one FolderShares
     * const FolderShares = await prisma.folderShares.create({
     *   data: {
     *     // ... data to create a FolderShares
     *   }
     * })
     * 
     */
    create<T extends FolderSharesCreateArgs>(args: SelectSubset<T, FolderSharesCreateArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FolderShares.
     * @param {FolderSharesCreateManyArgs} args - Arguments to create many FolderShares.
     * @example
     * // Create many FolderShares
     * const folderShares = await prisma.folderShares.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderSharesCreateManyArgs>(args?: SelectSubset<T, FolderSharesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FolderShares and returns the data saved in the database.
     * @param {FolderSharesCreateManyAndReturnArgs} args - Arguments to create many FolderShares.
     * @example
     * // Create many FolderShares
     * const folderShares = await prisma.folderShares.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FolderShares and only return the `userId`
     * const folderSharesWithUserIdOnly = await prisma.folderShares.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderSharesCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderSharesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FolderShares.
     * @param {FolderSharesDeleteArgs} args - Arguments to delete one FolderShares.
     * @example
     * // Delete one FolderShares
     * const FolderShares = await prisma.folderShares.delete({
     *   where: {
     *     // ... filter to delete one FolderShares
     *   }
     * })
     * 
     */
    delete<T extends FolderSharesDeleteArgs>(args: SelectSubset<T, FolderSharesDeleteArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FolderShares.
     * @param {FolderSharesUpdateArgs} args - Arguments to update one FolderShares.
     * @example
     * // Update one FolderShares
     * const folderShares = await prisma.folderShares.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderSharesUpdateArgs>(args: SelectSubset<T, FolderSharesUpdateArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FolderShares.
     * @param {FolderSharesDeleteManyArgs} args - Arguments to filter FolderShares to delete.
     * @example
     * // Delete a few FolderShares
     * const { count } = await prisma.folderShares.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderSharesDeleteManyArgs>(args?: SelectSubset<T, FolderSharesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FolderShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FolderShares
     * const folderShares = await prisma.folderShares.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderSharesUpdateManyArgs>(args: SelectSubset<T, FolderSharesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FolderShares and returns the data updated in the database.
     * @param {FolderSharesUpdateManyAndReturnArgs} args - Arguments to update many FolderShares.
     * @example
     * // Update many FolderShares
     * const folderShares = await prisma.folderShares.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FolderShares and only return the `userId`
     * const folderSharesWithUserIdOnly = await prisma.folderShares.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderSharesUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderSharesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FolderShares.
     * @param {FolderSharesUpsertArgs} args - Arguments to update or create a FolderShares.
     * @example
     * // Update or create a FolderShares
     * const folderShares = await prisma.folderShares.upsert({
     *   create: {
     *     // ... data to create a FolderShares
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FolderShares we want to update
     *   }
     * })
     */
    upsert<T extends FolderSharesUpsertArgs>(args: SelectSubset<T, FolderSharesUpsertArgs<ExtArgs>>): Prisma__FolderSharesClient<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FolderShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesCountArgs} args - Arguments to filter FolderShares to count.
     * @example
     * // Count the number of FolderShares
     * const count = await prisma.folderShares.count({
     *   where: {
     *     // ... the filter for the FolderShares we want to count
     *   }
     * })
    **/
    count<T extends FolderSharesCountArgs>(
      args?: Subset<T, FolderSharesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderSharesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FolderShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderSharesAggregateArgs>(args: Subset<T, FolderSharesAggregateArgs>): Prisma.PrismaPromise<GetFolderSharesAggregateType<T>>

    /**
     * Group by FolderShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderSharesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderSharesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderSharesGroupByArgs['orderBy'] }
        : { orderBy?: FolderSharesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderSharesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderSharesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FolderShares model
   */
  readonly fields: FolderSharesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FolderShares.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderSharesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Folder<T extends FolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FolderDefaultArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FolderShares model
   */ 
  interface FolderSharesFieldRefs {
    readonly userId: FieldRef<"FolderShares", 'String'>
    readonly folderId: FieldRef<"FolderShares", 'String'>
    readonly accessLevel: FieldRef<"FolderShares", 'AccessLevel'>
  }
    

  // Custom InputTypes
  /**
   * FolderShares findUnique
   */
  export type FolderSharesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter, which FolderShares to fetch.
     */
    where: FolderSharesWhereUniqueInput
  }

  /**
   * FolderShares findUniqueOrThrow
   */
  export type FolderSharesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter, which FolderShares to fetch.
     */
    where: FolderSharesWhereUniqueInput
  }

  /**
   * FolderShares findFirst
   */
  export type FolderSharesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter, which FolderShares to fetch.
     */
    where?: FolderSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderShares to fetch.
     */
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FolderShares.
     */
    cursor?: FolderSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FolderShares.
     */
    distinct?: FolderSharesScalarFieldEnum | FolderSharesScalarFieldEnum[]
  }

  /**
   * FolderShares findFirstOrThrow
   */
  export type FolderSharesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter, which FolderShares to fetch.
     */
    where?: FolderSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderShares to fetch.
     */
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FolderShares.
     */
    cursor?: FolderSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FolderShares.
     */
    distinct?: FolderSharesScalarFieldEnum | FolderSharesScalarFieldEnum[]
  }

  /**
   * FolderShares findMany
   */
  export type FolderSharesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter, which FolderShares to fetch.
     */
    where?: FolderSharesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderShares to fetch.
     */
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FolderShares.
     */
    cursor?: FolderSharesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderShares.
     */
    skip?: number
    distinct?: FolderSharesScalarFieldEnum | FolderSharesScalarFieldEnum[]
  }

  /**
   * FolderShares create
   */
  export type FolderSharesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * The data needed to create a FolderShares.
     */
    data: XOR<FolderSharesCreateInput, FolderSharesUncheckedCreateInput>
  }

  /**
   * FolderShares createMany
   */
  export type FolderSharesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FolderShares.
     */
    data: FolderSharesCreateManyInput | FolderSharesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FolderShares createManyAndReturn
   */
  export type FolderSharesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * The data used to create many FolderShares.
     */
    data: FolderSharesCreateManyInput | FolderSharesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FolderShares update
   */
  export type FolderSharesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * The data needed to update a FolderShares.
     */
    data: XOR<FolderSharesUpdateInput, FolderSharesUncheckedUpdateInput>
    /**
     * Choose, which FolderShares to update.
     */
    where: FolderSharesWhereUniqueInput
  }

  /**
   * FolderShares updateMany
   */
  export type FolderSharesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FolderShares.
     */
    data: XOR<FolderSharesUpdateManyMutationInput, FolderSharesUncheckedUpdateManyInput>
    /**
     * Filter which FolderShares to update
     */
    where?: FolderSharesWhereInput
    /**
     * Limit how many FolderShares to update.
     */
    limit?: number
  }

  /**
   * FolderShares updateManyAndReturn
   */
  export type FolderSharesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * The data used to update FolderShares.
     */
    data: XOR<FolderSharesUpdateManyMutationInput, FolderSharesUncheckedUpdateManyInput>
    /**
     * Filter which FolderShares to update
     */
    where?: FolderSharesWhereInput
    /**
     * Limit how many FolderShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FolderShares upsert
   */
  export type FolderSharesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * The filter to search for the FolderShares to update in case it exists.
     */
    where: FolderSharesWhereUniqueInput
    /**
     * In case the FolderShares found by the `where` argument doesn't exist, create a new FolderShares with this data.
     */
    create: XOR<FolderSharesCreateInput, FolderSharesUncheckedCreateInput>
    /**
     * In case the FolderShares was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderSharesUpdateInput, FolderSharesUncheckedUpdateInput>
  }

  /**
   * FolderShares delete
   */
  export type FolderSharesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    /**
     * Filter which FolderShares to delete.
     */
    where: FolderSharesWhereUniqueInput
  }

  /**
   * FolderShares deleteMany
   */
  export type FolderSharesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FolderShares to delete
     */
    where?: FolderSharesWhereInput
    /**
     * Limit how many FolderShares to delete.
     */
    limit?: number
  }

  /**
   * FolderShares without action
   */
  export type FolderSharesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
  }


  /**
   * Model Liked_Content
   */

  export type AggregateLiked_Content = {
    _count: Liked_ContentCountAggregateOutputType | null
    _avg: Liked_ContentAvgAggregateOutputType | null
    _sum: Liked_ContentSumAggregateOutputType | null
    _min: Liked_ContentMinAggregateOutputType | null
    _max: Liked_ContentMaxAggregateOutputType | null
  }

  export type Liked_ContentAvgAggregateOutputType = {
    contentid: number | null
  }

  export type Liked_ContentSumAggregateOutputType = {
    contentid: number | null
  }

  export type Liked_ContentMinAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    contentid: number | null
  }

  export type Liked_ContentMaxAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    contentid: number | null
  }

  export type Liked_ContentCountAggregateOutputType = {
    userid: number
    mediatype: number
    contentid: number
    _all: number
  }


  export type Liked_ContentAvgAggregateInputType = {
    contentid?: true
  }

  export type Liked_ContentSumAggregateInputType = {
    contentid?: true
  }

  export type Liked_ContentMinAggregateInputType = {
    userid?: true
    mediatype?: true
    contentid?: true
  }

  export type Liked_ContentMaxAggregateInputType = {
    userid?: true
    mediatype?: true
    contentid?: true
  }

  export type Liked_ContentCountAggregateInputType = {
    userid?: true
    mediatype?: true
    contentid?: true
    _all?: true
  }

  export type Liked_ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liked_Content to aggregate.
     */
    where?: Liked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liked_Contents to fetch.
     */
    orderBy?: Liked_ContentOrderByWithRelationInput | Liked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Liked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Liked_Contents
    **/
    _count?: true | Liked_ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Liked_ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Liked_ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Liked_ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Liked_ContentMaxAggregateInputType
  }

  export type GetLiked_ContentAggregateType<T extends Liked_ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateLiked_Content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiked_Content[P]>
      : GetScalarType<T[P], AggregateLiked_Content[P]>
  }




  export type Liked_ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Liked_ContentWhereInput
    orderBy?: Liked_ContentOrderByWithAggregationInput | Liked_ContentOrderByWithAggregationInput[]
    by: Liked_ContentScalarFieldEnum[] | Liked_ContentScalarFieldEnum
    having?: Liked_ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Liked_ContentCountAggregateInputType | true
    _avg?: Liked_ContentAvgAggregateInputType
    _sum?: Liked_ContentSumAggregateInputType
    _min?: Liked_ContentMinAggregateInputType
    _max?: Liked_ContentMaxAggregateInputType
  }

  export type Liked_ContentGroupByOutputType = {
    userid: string
    mediatype: $Enums.MediaType
    contentid: number
    _count: Liked_ContentCountAggregateOutputType | null
    _avg: Liked_ContentAvgAggregateOutputType | null
    _sum: Liked_ContentSumAggregateOutputType | null
    _min: Liked_ContentMinAggregateOutputType | null
    _max: Liked_ContentMaxAggregateOutputType | null
  }

  type GetLiked_ContentGroupByPayload<T extends Liked_ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Liked_ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Liked_ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Liked_ContentGroupByOutputType[P]>
            : GetScalarType<T[P], Liked_ContentGroupByOutputType[P]>
        }
      >
    >


  export type Liked_ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    contentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liked_Content"]>

  export type Liked_ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    contentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liked_Content"]>

  export type Liked_ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    contentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liked_Content"]>

  export type Liked_ContentSelectScalar = {
    userid?: boolean
    mediatype?: boolean
    contentid?: boolean
  }

  export type Liked_ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "mediatype" | "contentid", ExtArgs["result"]["liked_Content"]>
  export type Liked_ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Liked_ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Liked_ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $Liked_ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Liked_Content"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      mediatype: $Enums.MediaType
      contentid: number
    }, ExtArgs["result"]["liked_Content"]>
    composites: {}
  }

  type Liked_ContentGetPayload<S extends boolean | null | undefined | Liked_ContentDefaultArgs> = $Result.GetResult<Prisma.$Liked_ContentPayload, S>

  type Liked_ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Liked_ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Liked_ContentCountAggregateInputType | true
    }

  export interface Liked_ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Liked_Content'], meta: { name: 'Liked_Content' } }
    /**
     * Find zero or one Liked_Content that matches the filter.
     * @param {Liked_ContentFindUniqueArgs} args - Arguments to find a Liked_Content
     * @example
     * // Get one Liked_Content
     * const liked_Content = await prisma.liked_Content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Liked_ContentFindUniqueArgs>(args: SelectSubset<T, Liked_ContentFindUniqueArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Liked_Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Liked_ContentFindUniqueOrThrowArgs} args - Arguments to find a Liked_Content
     * @example
     * // Get one Liked_Content
     * const liked_Content = await prisma.liked_Content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Liked_ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, Liked_ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liked_Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentFindFirstArgs} args - Arguments to find a Liked_Content
     * @example
     * // Get one Liked_Content
     * const liked_Content = await prisma.liked_Content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Liked_ContentFindFirstArgs>(args?: SelectSubset<T, Liked_ContentFindFirstArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liked_Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentFindFirstOrThrowArgs} args - Arguments to find a Liked_Content
     * @example
     * // Get one Liked_Content
     * const liked_Content = await prisma.liked_Content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Liked_ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, Liked_ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Liked_Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liked_Contents
     * const liked_Contents = await prisma.liked_Content.findMany()
     * 
     * // Get first 10 Liked_Contents
     * const liked_Contents = await prisma.liked_Content.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const liked_ContentWithUseridOnly = await prisma.liked_Content.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends Liked_ContentFindManyArgs>(args?: SelectSubset<T, Liked_ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Liked_Content.
     * @param {Liked_ContentCreateArgs} args - Arguments to create a Liked_Content.
     * @example
     * // Create one Liked_Content
     * const Liked_Content = await prisma.liked_Content.create({
     *   data: {
     *     // ... data to create a Liked_Content
     *   }
     * })
     * 
     */
    create<T extends Liked_ContentCreateArgs>(args: SelectSubset<T, Liked_ContentCreateArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Liked_Contents.
     * @param {Liked_ContentCreateManyArgs} args - Arguments to create many Liked_Contents.
     * @example
     * // Create many Liked_Contents
     * const liked_Content = await prisma.liked_Content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Liked_ContentCreateManyArgs>(args?: SelectSubset<T, Liked_ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Liked_Contents and returns the data saved in the database.
     * @param {Liked_ContentCreateManyAndReturnArgs} args - Arguments to create many Liked_Contents.
     * @example
     * // Create many Liked_Contents
     * const liked_Content = await prisma.liked_Content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Liked_Contents and only return the `userid`
     * const liked_ContentWithUseridOnly = await prisma.liked_Content.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Liked_ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, Liked_ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Liked_Content.
     * @param {Liked_ContentDeleteArgs} args - Arguments to delete one Liked_Content.
     * @example
     * // Delete one Liked_Content
     * const Liked_Content = await prisma.liked_Content.delete({
     *   where: {
     *     // ... filter to delete one Liked_Content
     *   }
     * })
     * 
     */
    delete<T extends Liked_ContentDeleteArgs>(args: SelectSubset<T, Liked_ContentDeleteArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Liked_Content.
     * @param {Liked_ContentUpdateArgs} args - Arguments to update one Liked_Content.
     * @example
     * // Update one Liked_Content
     * const liked_Content = await prisma.liked_Content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Liked_ContentUpdateArgs>(args: SelectSubset<T, Liked_ContentUpdateArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Liked_Contents.
     * @param {Liked_ContentDeleteManyArgs} args - Arguments to filter Liked_Contents to delete.
     * @example
     * // Delete a few Liked_Contents
     * const { count } = await prisma.liked_Content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Liked_ContentDeleteManyArgs>(args?: SelectSubset<T, Liked_ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liked_Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liked_Contents
     * const liked_Content = await prisma.liked_Content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Liked_ContentUpdateManyArgs>(args: SelectSubset<T, Liked_ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liked_Contents and returns the data updated in the database.
     * @param {Liked_ContentUpdateManyAndReturnArgs} args - Arguments to update many Liked_Contents.
     * @example
     * // Update many Liked_Contents
     * const liked_Content = await prisma.liked_Content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Liked_Contents and only return the `userid`
     * const liked_ContentWithUseridOnly = await prisma.liked_Content.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Liked_ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, Liked_ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Liked_Content.
     * @param {Liked_ContentUpsertArgs} args - Arguments to update or create a Liked_Content.
     * @example
     * // Update or create a Liked_Content
     * const liked_Content = await prisma.liked_Content.upsert({
     *   create: {
     *     // ... data to create a Liked_Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liked_Content we want to update
     *   }
     * })
     */
    upsert<T extends Liked_ContentUpsertArgs>(args: SelectSubset<T, Liked_ContentUpsertArgs<ExtArgs>>): Prisma__Liked_ContentClient<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Liked_Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentCountArgs} args - Arguments to filter Liked_Contents to count.
     * @example
     * // Count the number of Liked_Contents
     * const count = await prisma.liked_Content.count({
     *   where: {
     *     // ... the filter for the Liked_Contents we want to count
     *   }
     * })
    **/
    count<T extends Liked_ContentCountArgs>(
      args?: Subset<T, Liked_ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Liked_ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liked_Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Liked_ContentAggregateArgs>(args: Subset<T, Liked_ContentAggregateArgs>): Prisma.PrismaPromise<GetLiked_ContentAggregateType<T>>

    /**
     * Group by Liked_Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liked_ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Liked_ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Liked_ContentGroupByArgs['orderBy'] }
        : { orderBy?: Liked_ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Liked_ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiked_ContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Liked_Content model
   */
  readonly fields: Liked_ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Liked_Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Liked_ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Liked_Content model
   */ 
  interface Liked_ContentFieldRefs {
    readonly userid: FieldRef<"Liked_Content", 'String'>
    readonly mediatype: FieldRef<"Liked_Content", 'MediaType'>
    readonly contentid: FieldRef<"Liked_Content", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Liked_Content findUnique
   */
  export type Liked_ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Liked_Content to fetch.
     */
    where: Liked_ContentWhereUniqueInput
  }

  /**
   * Liked_Content findUniqueOrThrow
   */
  export type Liked_ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Liked_Content to fetch.
     */
    where: Liked_ContentWhereUniqueInput
  }

  /**
   * Liked_Content findFirst
   */
  export type Liked_ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Liked_Content to fetch.
     */
    where?: Liked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liked_Contents to fetch.
     */
    orderBy?: Liked_ContentOrderByWithRelationInput | Liked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liked_Contents.
     */
    cursor?: Liked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liked_Contents.
     */
    distinct?: Liked_ContentScalarFieldEnum | Liked_ContentScalarFieldEnum[]
  }

  /**
   * Liked_Content findFirstOrThrow
   */
  export type Liked_ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Liked_Content to fetch.
     */
    where?: Liked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liked_Contents to fetch.
     */
    orderBy?: Liked_ContentOrderByWithRelationInput | Liked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liked_Contents.
     */
    cursor?: Liked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liked_Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liked_Contents.
     */
    distinct?: Liked_ContentScalarFieldEnum | Liked_ContentScalarFieldEnum[]
  }

  /**
   * Liked_Content findMany
   */
  export type Liked_ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter, which Liked_Contents to fetch.
     */
    where?: Liked_ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liked_Contents to fetch.
     */
    orderBy?: Liked_ContentOrderByWithRelationInput | Liked_ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Liked_Contents.
     */
    cursor?: Liked_ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liked_Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liked_Contents.
     */
    skip?: number
    distinct?: Liked_ContentScalarFieldEnum | Liked_ContentScalarFieldEnum[]
  }

  /**
   * Liked_Content create
   */
  export type Liked_ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Liked_Content.
     */
    data: XOR<Liked_ContentCreateInput, Liked_ContentUncheckedCreateInput>
  }

  /**
   * Liked_Content createMany
   */
  export type Liked_ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Liked_Contents.
     */
    data: Liked_ContentCreateManyInput | Liked_ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Liked_Content createManyAndReturn
   */
  export type Liked_ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Liked_Contents.
     */
    data: Liked_ContentCreateManyInput | Liked_ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liked_Content update
   */
  export type Liked_ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Liked_Content.
     */
    data: XOR<Liked_ContentUpdateInput, Liked_ContentUncheckedUpdateInput>
    /**
     * Choose, which Liked_Content to update.
     */
    where: Liked_ContentWhereUniqueInput
  }

  /**
   * Liked_Content updateMany
   */
  export type Liked_ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Liked_Contents.
     */
    data: XOR<Liked_ContentUpdateManyMutationInput, Liked_ContentUncheckedUpdateManyInput>
    /**
     * Filter which Liked_Contents to update
     */
    where?: Liked_ContentWhereInput
    /**
     * Limit how many Liked_Contents to update.
     */
    limit?: number
  }

  /**
   * Liked_Content updateManyAndReturn
   */
  export type Liked_ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * The data used to update Liked_Contents.
     */
    data: XOR<Liked_ContentUpdateManyMutationInput, Liked_ContentUncheckedUpdateManyInput>
    /**
     * Filter which Liked_Contents to update
     */
    where?: Liked_ContentWhereInput
    /**
     * Limit how many Liked_Contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Liked_Content upsert
   */
  export type Liked_ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Liked_Content to update in case it exists.
     */
    where: Liked_ContentWhereUniqueInput
    /**
     * In case the Liked_Content found by the `where` argument doesn't exist, create a new Liked_Content with this data.
     */
    create: XOR<Liked_ContentCreateInput, Liked_ContentUncheckedCreateInput>
    /**
     * In case the Liked_Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Liked_ContentUpdateInput, Liked_ContentUncheckedUpdateInput>
  }

  /**
   * Liked_Content delete
   */
  export type Liked_ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    /**
     * Filter which Liked_Content to delete.
     */
    where: Liked_ContentWhereUniqueInput
  }

  /**
   * Liked_Content deleteMany
   */
  export type Liked_ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liked_Contents to delete
     */
    where?: Liked_ContentWhereInput
    /**
     * Limit how many Liked_Contents to delete.
     */
    limit?: number
  }

  /**
   * Liked_Content without action
   */
  export type Liked_ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
  }


  /**
   * Model Manga
   */

  export type AggregateManga = {
    _count: MangaCountAggregateOutputType | null
    _avg: MangaAvgAggregateOutputType | null
    _sum: MangaSumAggregateOutputType | null
    _min: MangaMinAggregateOutputType | null
    _max: MangaMaxAggregateOutputType | null
  }

  export type MangaAvgAggregateOutputType = {
    likes: number | null
    dislikes: number | null
  }

  export type MangaSumAggregateOutputType = {
    likes: bigint | null
    dislikes: bigint | null
  }

  export type MangaMinAggregateOutputType = {
    mangaid: string | null
    authorid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    cover_iamge: string | null
    likes: bigint | null
    dislikes: bigint | null
    age_rating: $Enums.AgeRating | null
  }

  export type MangaMaxAggregateOutputType = {
    mangaid: string | null
    authorid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    cover_iamge: string | null
    likes: bigint | null
    dislikes: bigint | null
    age_rating: $Enums.AgeRating | null
  }

  export type MangaCountAggregateOutputType = {
    mangaid: number
    authorid: number
    title: number
    description: number
    release_date: number
    cover_iamge: number
    likes: number
    dislikes: number
    age_rating: number
    MediaGenre: number
    _all: number
  }


  export type MangaAvgAggregateInputType = {
    likes?: true
    dislikes?: true
  }

  export type MangaSumAggregateInputType = {
    likes?: true
    dislikes?: true
  }

  export type MangaMinAggregateInputType = {
    mangaid?: true
    authorid?: true
    title?: true
    description?: true
    release_date?: true
    cover_iamge?: true
    likes?: true
    dislikes?: true
    age_rating?: true
  }

  export type MangaMaxAggregateInputType = {
    mangaid?: true
    authorid?: true
    title?: true
    description?: true
    release_date?: true
    cover_iamge?: true
    likes?: true
    dislikes?: true
    age_rating?: true
  }

  export type MangaCountAggregateInputType = {
    mangaid?: true
    authorid?: true
    title?: true
    description?: true
    release_date?: true
    cover_iamge?: true
    likes?: true
    dislikes?: true
    age_rating?: true
    MediaGenre?: true
    _all?: true
  }

  export type MangaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manga to aggregate.
     */
    where?: MangaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manga to fetch.
     */
    orderBy?: MangaOrderByWithRelationInput | MangaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MangaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manga from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manga.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Manga
    **/
    _count?: true | MangaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MangaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MangaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MangaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MangaMaxAggregateInputType
  }

  export type GetMangaAggregateType<T extends MangaAggregateArgs> = {
        [P in keyof T & keyof AggregateManga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManga[P]>
      : GetScalarType<T[P], AggregateManga[P]>
  }




  export type MangaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MangaWhereInput
    orderBy?: MangaOrderByWithAggregationInput | MangaOrderByWithAggregationInput[]
    by: MangaScalarFieldEnum[] | MangaScalarFieldEnum
    having?: MangaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MangaCountAggregateInputType | true
    _avg?: MangaAvgAggregateInputType
    _sum?: MangaSumAggregateInputType
    _min?: MangaMinAggregateInputType
    _max?: MangaMaxAggregateInputType
  }

  export type MangaGroupByOutputType = {
    mangaid: string
    authorid: string
    title: string
    description: string | null
    release_date: Date | null
    cover_iamge: string | null
    likes: bigint
    dislikes: bigint
    age_rating: $Enums.AgeRating
    MediaGenre: $Enums.MediaGenre[]
    _count: MangaCountAggregateOutputType | null
    _avg: MangaAvgAggregateOutputType | null
    _sum: MangaSumAggregateOutputType | null
    _min: MangaMinAggregateOutputType | null
    _max: MangaMaxAggregateOutputType | null
  }

  type GetMangaGroupByPayload<T extends MangaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MangaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MangaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MangaGroupByOutputType[P]>
            : GetScalarType<T[P], MangaGroupByOutputType[P]>
        }
      >
    >


  export type MangaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mangaid?: boolean
    authorid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    cover_iamge?: boolean
    likes?: boolean
    dislikes?: boolean
    age_rating?: boolean
    MediaGenre?: boolean
    Anime?: boolean | Manga$AnimeArgs<ExtArgs>
    Bookmarks?: boolean | Manga$BookmarksArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    ContentGroupLinks?: boolean | Manga$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | MangaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manga"]>

  export type MangaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mangaid?: boolean
    authorid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    cover_iamge?: boolean
    likes?: boolean
    dislikes?: boolean
    age_rating?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manga"]>

  export type MangaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mangaid?: boolean
    authorid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    cover_iamge?: boolean
    likes?: boolean
    dislikes?: boolean
    age_rating?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manga"]>

  export type MangaSelectScalar = {
    mangaid?: boolean
    authorid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    cover_iamge?: boolean
    likes?: boolean
    dislikes?: boolean
    age_rating?: boolean
    MediaGenre?: boolean
  }

  export type MangaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mangaid" | "authorid" | "title" | "description" | "release_date" | "cover_iamge" | "likes" | "dislikes" | "age_rating" | "MediaGenre", ExtArgs["result"]["manga"]>
  export type MangaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | Manga$AnimeArgs<ExtArgs>
    Bookmarks?: boolean | Manga$BookmarksArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    ContentGroupLinks?: boolean | Manga$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | MangaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MangaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MangaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MangaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manga"
    objects: {
      Anime: Prisma.$AnimePayload<ExtArgs>[]
      Bookmarks: Prisma.$BookmarksPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
      ContentGroupLinks: Prisma.$ContentGroupMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      mangaid: string
      authorid: string
      title: string
      description: string | null
      release_date: Date | null
      cover_iamge: string | null
      likes: bigint
      dislikes: bigint
      age_rating: $Enums.AgeRating
      MediaGenre: $Enums.MediaGenre[]
    }, ExtArgs["result"]["manga"]>
    composites: {}
  }

  type MangaGetPayload<S extends boolean | null | undefined | MangaDefaultArgs> = $Result.GetResult<Prisma.$MangaPayload, S>

  type MangaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MangaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MangaCountAggregateInputType | true
    }

  export interface MangaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manga'], meta: { name: 'Manga' } }
    /**
     * Find zero or one Manga that matches the filter.
     * @param {MangaFindUniqueArgs} args - Arguments to find a Manga
     * @example
     * // Get one Manga
     * const manga = await prisma.manga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MangaFindUniqueArgs>(args: SelectSubset<T, MangaFindUniqueArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manga that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MangaFindUniqueOrThrowArgs} args - Arguments to find a Manga
     * @example
     * // Get one Manga
     * const manga = await prisma.manga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MangaFindUniqueOrThrowArgs>(args: SelectSubset<T, MangaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaFindFirstArgs} args - Arguments to find a Manga
     * @example
     * // Get one Manga
     * const manga = await prisma.manga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MangaFindFirstArgs>(args?: SelectSubset<T, MangaFindFirstArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaFindFirstOrThrowArgs} args - Arguments to find a Manga
     * @example
     * // Get one Manga
     * const manga = await prisma.manga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MangaFindFirstOrThrowArgs>(args?: SelectSubset<T, MangaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manga
     * const manga = await prisma.manga.findMany()
     * 
     * // Get first 10 Manga
     * const manga = await prisma.manga.findMany({ take: 10 })
     * 
     * // Only select the `mangaid`
     * const mangaWithMangaidOnly = await prisma.manga.findMany({ select: { mangaid: true } })
     * 
     */
    findMany<T extends MangaFindManyArgs>(args?: SelectSubset<T, MangaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manga.
     * @param {MangaCreateArgs} args - Arguments to create a Manga.
     * @example
     * // Create one Manga
     * const Manga = await prisma.manga.create({
     *   data: {
     *     // ... data to create a Manga
     *   }
     * })
     * 
     */
    create<T extends MangaCreateArgs>(args: SelectSubset<T, MangaCreateArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manga.
     * @param {MangaCreateManyArgs} args - Arguments to create many Manga.
     * @example
     * // Create many Manga
     * const manga = await prisma.manga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MangaCreateManyArgs>(args?: SelectSubset<T, MangaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Manga and returns the data saved in the database.
     * @param {MangaCreateManyAndReturnArgs} args - Arguments to create many Manga.
     * @example
     * // Create many Manga
     * const manga = await prisma.manga.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Manga and only return the `mangaid`
     * const mangaWithMangaidOnly = await prisma.manga.createManyAndReturn({
     *   select: { mangaid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MangaCreateManyAndReturnArgs>(args?: SelectSubset<T, MangaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manga.
     * @param {MangaDeleteArgs} args - Arguments to delete one Manga.
     * @example
     * // Delete one Manga
     * const Manga = await prisma.manga.delete({
     *   where: {
     *     // ... filter to delete one Manga
     *   }
     * })
     * 
     */
    delete<T extends MangaDeleteArgs>(args: SelectSubset<T, MangaDeleteArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manga.
     * @param {MangaUpdateArgs} args - Arguments to update one Manga.
     * @example
     * // Update one Manga
     * const manga = await prisma.manga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MangaUpdateArgs>(args: SelectSubset<T, MangaUpdateArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manga.
     * @param {MangaDeleteManyArgs} args - Arguments to filter Manga to delete.
     * @example
     * // Delete a few Manga
     * const { count } = await prisma.manga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MangaDeleteManyArgs>(args?: SelectSubset<T, MangaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manga
     * const manga = await prisma.manga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MangaUpdateManyArgs>(args: SelectSubset<T, MangaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manga and returns the data updated in the database.
     * @param {MangaUpdateManyAndReturnArgs} args - Arguments to update many Manga.
     * @example
     * // Update many Manga
     * const manga = await prisma.manga.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Manga and only return the `mangaid`
     * const mangaWithMangaidOnly = await prisma.manga.updateManyAndReturn({
     *   select: { mangaid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MangaUpdateManyAndReturnArgs>(args: SelectSubset<T, MangaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manga.
     * @param {MangaUpsertArgs} args - Arguments to update or create a Manga.
     * @example
     * // Update or create a Manga
     * const manga = await prisma.manga.upsert({
     *   create: {
     *     // ... data to create a Manga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manga we want to update
     *   }
     * })
     */
    upsert<T extends MangaUpsertArgs>(args: SelectSubset<T, MangaUpsertArgs<ExtArgs>>): Prisma__MangaClient<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaCountArgs} args - Arguments to filter Manga to count.
     * @example
     * // Count the number of Manga
     * const count = await prisma.manga.count({
     *   where: {
     *     // ... the filter for the Manga we want to count
     *   }
     * })
    **/
    count<T extends MangaCountArgs>(
      args?: Subset<T, MangaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MangaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MangaAggregateArgs>(args: Subset<T, MangaAggregateArgs>): Prisma.PrismaPromise<GetMangaAggregateType<T>>

    /**
     * Group by Manga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MangaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MangaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MangaGroupByArgs['orderBy'] }
        : { orderBy?: MangaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MangaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMangaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manga model
   */
  readonly fields: MangaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MangaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Anime<T extends Manga$AnimeArgs<ExtArgs> = {}>(args?: Subset<T, Manga$AnimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bookmarks<T extends Manga$BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Manga$BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ContentGroupLinks<T extends Manga$ContentGroupLinksArgs<ExtArgs> = {}>(args?: Subset<T, Manga$ContentGroupLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manga model
   */ 
  interface MangaFieldRefs {
    readonly mangaid: FieldRef<"Manga", 'String'>
    readonly authorid: FieldRef<"Manga", 'String'>
    readonly title: FieldRef<"Manga", 'String'>
    readonly description: FieldRef<"Manga", 'String'>
    readonly release_date: FieldRef<"Manga", 'DateTime'>
    readonly cover_iamge: FieldRef<"Manga", 'String'>
    readonly likes: FieldRef<"Manga", 'BigInt'>
    readonly dislikes: FieldRef<"Manga", 'BigInt'>
    readonly age_rating: FieldRef<"Manga", 'AgeRating'>
    readonly MediaGenre: FieldRef<"Manga", 'MediaGenre[]'>
  }
    

  // Custom InputTypes
  /**
   * Manga findUnique
   */
  export type MangaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter, which Manga to fetch.
     */
    where: MangaWhereUniqueInput
  }

  /**
   * Manga findUniqueOrThrow
   */
  export type MangaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter, which Manga to fetch.
     */
    where: MangaWhereUniqueInput
  }

  /**
   * Manga findFirst
   */
  export type MangaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter, which Manga to fetch.
     */
    where?: MangaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manga to fetch.
     */
    orderBy?: MangaOrderByWithRelationInput | MangaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manga.
     */
    cursor?: MangaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manga from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manga.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manga.
     */
    distinct?: MangaScalarFieldEnum | MangaScalarFieldEnum[]
  }

  /**
   * Manga findFirstOrThrow
   */
  export type MangaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter, which Manga to fetch.
     */
    where?: MangaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manga to fetch.
     */
    orderBy?: MangaOrderByWithRelationInput | MangaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manga.
     */
    cursor?: MangaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manga from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manga.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manga.
     */
    distinct?: MangaScalarFieldEnum | MangaScalarFieldEnum[]
  }

  /**
   * Manga findMany
   */
  export type MangaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter, which Manga to fetch.
     */
    where?: MangaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manga to fetch.
     */
    orderBy?: MangaOrderByWithRelationInput | MangaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Manga.
     */
    cursor?: MangaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manga from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manga.
     */
    skip?: number
    distinct?: MangaScalarFieldEnum | MangaScalarFieldEnum[]
  }

  /**
   * Manga create
   */
  export type MangaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * The data needed to create a Manga.
     */
    data: XOR<MangaCreateInput, MangaUncheckedCreateInput>
  }

  /**
   * Manga createMany
   */
  export type MangaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Manga.
     */
    data: MangaCreateManyInput | MangaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manga createManyAndReturn
   */
  export type MangaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * The data used to create many Manga.
     */
    data: MangaCreateManyInput | MangaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manga update
   */
  export type MangaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * The data needed to update a Manga.
     */
    data: XOR<MangaUpdateInput, MangaUncheckedUpdateInput>
    /**
     * Choose, which Manga to update.
     */
    where: MangaWhereUniqueInput
  }

  /**
   * Manga updateMany
   */
  export type MangaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Manga.
     */
    data: XOR<MangaUpdateManyMutationInput, MangaUncheckedUpdateManyInput>
    /**
     * Filter which Manga to update
     */
    where?: MangaWhereInput
    /**
     * Limit how many Manga to update.
     */
    limit?: number
  }

  /**
   * Manga updateManyAndReturn
   */
  export type MangaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * The data used to update Manga.
     */
    data: XOR<MangaUpdateManyMutationInput, MangaUncheckedUpdateManyInput>
    /**
     * Filter which Manga to update
     */
    where?: MangaWhereInput
    /**
     * Limit how many Manga to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manga upsert
   */
  export type MangaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * The filter to search for the Manga to update in case it exists.
     */
    where: MangaWhereUniqueInput
    /**
     * In case the Manga found by the `where` argument doesn't exist, create a new Manga with this data.
     */
    create: XOR<MangaCreateInput, MangaUncheckedCreateInput>
    /**
     * In case the Manga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MangaUpdateInput, MangaUncheckedUpdateInput>
  }

  /**
   * Manga delete
   */
  export type MangaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    /**
     * Filter which Manga to delete.
     */
    where: MangaWhereUniqueInput
  }

  /**
   * Manga deleteMany
   */
  export type MangaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manga to delete
     */
    where?: MangaWhereInput
    /**
     * Limit how many Manga to delete.
     */
    limit?: number
  }

  /**
   * Manga.Anime
   */
  export type Manga$AnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    cursor?: AnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Manga.Bookmarks
   */
  export type Manga$BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    cursor?: BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Manga.ContentGroupLinks
   */
  export type Manga$ContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    where?: ContentGroupMediaWhereInput
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    cursor?: ContentGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * Manga without action
   */
  export type MangaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
  }


  /**
   * Model Movies
   */

  export type AggregateMovies = {
    _count: MoviesCountAggregateOutputType | null
    _avg: MoviesAvgAggregateOutputType | null
    _sum: MoviesSumAggregateOutputType | null
    _min: MoviesMinAggregateOutputType | null
    _max: MoviesMaxAggregateOutputType | null
  }

  export type MoviesAvgAggregateOutputType = {
    media_id_reference: number | null
    likes: number | null
    dislikes: number | null
  }

  export type MoviesSumAggregateOutputType = {
    media_id_reference: number | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type MoviesMinAggregateOutputType = {
    movieid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    media_id_reference: number | null
    likes: bigint | null
    dislikes: bigint | null
    showbanner: string | null
    age_rating: $Enums.AgeRating | null
    authorid: string | null
    media_reference_type: $Enums.MediaType | null
  }

  export type MoviesMaxAggregateOutputType = {
    movieid: string | null
    title: string | null
    description: string | null
    release_date: Date | null
    media_id_reference: number | null
    likes: bigint | null
    dislikes: bigint | null
    showbanner: string | null
    age_rating: $Enums.AgeRating | null
    authorid: string | null
    media_reference_type: $Enums.MediaType | null
  }

  export type MoviesCountAggregateOutputType = {
    movieid: number
    title: number
    description: number
    release_date: number
    media_id_reference: number
    likes: number
    dislikes: number
    showbanner: number
    age_rating: number
    authorid: number
    media_reference_type: number
    MediaGenre: number
    _all: number
  }


  export type MoviesAvgAggregateInputType = {
    media_id_reference?: true
    likes?: true
    dislikes?: true
  }

  export type MoviesSumAggregateInputType = {
    media_id_reference?: true
    likes?: true
    dislikes?: true
  }

  export type MoviesMinAggregateInputType = {
    movieid?: true
    title?: true
    description?: true
    release_date?: true
    media_id_reference?: true
    likes?: true
    dislikes?: true
    showbanner?: true
    age_rating?: true
    authorid?: true
    media_reference_type?: true
  }

  export type MoviesMaxAggregateInputType = {
    movieid?: true
    title?: true
    description?: true
    release_date?: true
    media_id_reference?: true
    likes?: true
    dislikes?: true
    showbanner?: true
    age_rating?: true
    authorid?: true
    media_reference_type?: true
  }

  export type MoviesCountAggregateInputType = {
    movieid?: true
    title?: true
    description?: true
    release_date?: true
    media_id_reference?: true
    likes?: true
    dislikes?: true
    showbanner?: true
    age_rating?: true
    authorid?: true
    media_reference_type?: true
    MediaGenre?: true
    _all?: true
  }

  export type MoviesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to aggregate.
     */
    where?: MoviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MoviesOrderByWithRelationInput | MoviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MoviesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoviesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoviesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoviesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoviesMaxAggregateInputType
  }

  export type GetMoviesAggregateType<T extends MoviesAggregateArgs> = {
        [P in keyof T & keyof AggregateMovies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovies[P]>
      : GetScalarType<T[P], AggregateMovies[P]>
  }




  export type MoviesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoviesWhereInput
    orderBy?: MoviesOrderByWithAggregationInput | MoviesOrderByWithAggregationInput[]
    by: MoviesScalarFieldEnum[] | MoviesScalarFieldEnum
    having?: MoviesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoviesCountAggregateInputType | true
    _avg?: MoviesAvgAggregateInputType
    _sum?: MoviesSumAggregateInputType
    _min?: MoviesMinAggregateInputType
    _max?: MoviesMaxAggregateInputType
  }

  export type MoviesGroupByOutputType = {
    movieid: string
    title: string
    description: string | null
    release_date: Date | null
    media_id_reference: number | null
    likes: bigint
    dislikes: bigint
    showbanner: string | null
    age_rating: $Enums.AgeRating
    authorid: string
    media_reference_type: $Enums.MediaType
    MediaGenre: $Enums.MediaGenre[]
    _count: MoviesCountAggregateOutputType | null
    _avg: MoviesAvgAggregateOutputType | null
    _sum: MoviesSumAggregateOutputType | null
    _min: MoviesMinAggregateOutputType | null
    _max: MoviesMaxAggregateOutputType | null
  }

  type GetMoviesGroupByPayload<T extends MoviesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoviesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoviesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoviesGroupByOutputType[P]>
            : GetScalarType<T[P], MoviesGroupByOutputType[P]>
        }
      >
    >


  export type MoviesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    media_id_reference?: boolean
    likes?: boolean
    dislikes?: boolean
    showbanner?: boolean
    age_rating?: boolean
    authorid?: boolean
    media_reference_type?: boolean
    MediaGenre?: boolean
    Bookmarks?: boolean | Movies$BookmarksArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    ContentGroupLinks?: boolean | Movies$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | MoviesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movies"]>

  export type MoviesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    media_id_reference?: boolean
    likes?: boolean
    dislikes?: boolean
    showbanner?: boolean
    age_rating?: boolean
    authorid?: boolean
    media_reference_type?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movies"]>

  export type MoviesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    movieid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    media_id_reference?: boolean
    likes?: boolean
    dislikes?: boolean
    showbanner?: boolean
    age_rating?: boolean
    authorid?: boolean
    media_reference_type?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movies"]>

  export type MoviesSelectScalar = {
    movieid?: boolean
    title?: boolean
    description?: boolean
    release_date?: boolean
    media_id_reference?: boolean
    likes?: boolean
    dislikes?: boolean
    showbanner?: boolean
    age_rating?: boolean
    authorid?: boolean
    media_reference_type?: boolean
    MediaGenre?: boolean
  }

  export type MoviesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"movieid" | "title" | "description" | "release_date" | "media_id_reference" | "likes" | "dislikes" | "showbanner" | "age_rating" | "authorid" | "media_reference_type" | "MediaGenre", ExtArgs["result"]["movies"]>
  export type MoviesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookmarks?: boolean | Movies$BookmarksArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    ContentGroupLinks?: boolean | Movies$ContentGroupLinksArgs<ExtArgs>
    _count?: boolean | MoviesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoviesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MoviesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MoviesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movies"
    objects: {
      Bookmarks: Prisma.$BookmarksPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
      ContentGroupLinks: Prisma.$ContentGroupMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      movieid: string
      title: string
      description: string | null
      release_date: Date | null
      media_id_reference: number | null
      likes: bigint
      dislikes: bigint
      showbanner: string | null
      age_rating: $Enums.AgeRating
      authorid: string
      media_reference_type: $Enums.MediaType
      MediaGenre: $Enums.MediaGenre[]
    }, ExtArgs["result"]["movies"]>
    composites: {}
  }

  type MoviesGetPayload<S extends boolean | null | undefined | MoviesDefaultArgs> = $Result.GetResult<Prisma.$MoviesPayload, S>

  type MoviesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoviesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoviesCountAggregateInputType | true
    }

  export interface MoviesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movies'], meta: { name: 'Movies' } }
    /**
     * Find zero or one Movies that matches the filter.
     * @param {MoviesFindUniqueArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoviesFindUniqueArgs>(args: SelectSubset<T, MoviesFindUniqueArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Movies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoviesFindUniqueOrThrowArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoviesFindUniqueOrThrowArgs>(args: SelectSubset<T, MoviesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesFindFirstArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoviesFindFirstArgs>(args?: SelectSubset<T, MoviesFindFirstArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesFindFirstOrThrowArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoviesFindFirstOrThrowArgs>(args?: SelectSubset<T, MoviesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movies.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movies.findMany({ take: 10 })
     * 
     * // Only select the `movieid`
     * const moviesWithMovieidOnly = await prisma.movies.findMany({ select: { movieid: true } })
     * 
     */
    findMany<T extends MoviesFindManyArgs>(args?: SelectSubset<T, MoviesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Movies.
     * @param {MoviesCreateArgs} args - Arguments to create a Movies.
     * @example
     * // Create one Movies
     * const Movies = await prisma.movies.create({
     *   data: {
     *     // ... data to create a Movies
     *   }
     * })
     * 
     */
    create<T extends MoviesCreateArgs>(args: SelectSubset<T, MoviesCreateArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Movies.
     * @param {MoviesCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movies = await prisma.movies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoviesCreateManyArgs>(args?: SelectSubset<T, MoviesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MoviesCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movies = await prisma.movies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `movieid`
     * const moviesWithMovieidOnly = await prisma.movies.createManyAndReturn({
     *   select: { movieid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoviesCreateManyAndReturnArgs>(args?: SelectSubset<T, MoviesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Movies.
     * @param {MoviesDeleteArgs} args - Arguments to delete one Movies.
     * @example
     * // Delete one Movies
     * const Movies = await prisma.movies.delete({
     *   where: {
     *     // ... filter to delete one Movies
     *   }
     * })
     * 
     */
    delete<T extends MoviesDeleteArgs>(args: SelectSubset<T, MoviesDeleteArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Movies.
     * @param {MoviesUpdateArgs} args - Arguments to update one Movies.
     * @example
     * // Update one Movies
     * const movies = await prisma.movies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoviesUpdateArgs>(args: SelectSubset<T, MoviesUpdateArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Movies.
     * @param {MoviesDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoviesDeleteManyArgs>(args?: SelectSubset<T, MoviesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movies = await prisma.movies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoviesUpdateManyArgs>(args: SelectSubset<T, MoviesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies and returns the data updated in the database.
     * @param {MoviesUpdateManyAndReturnArgs} args - Arguments to update many Movies.
     * @example
     * // Update many Movies
     * const movies = await prisma.movies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Movies and only return the `movieid`
     * const moviesWithMovieidOnly = await prisma.movies.updateManyAndReturn({
     *   select: { movieid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoviesUpdateManyAndReturnArgs>(args: SelectSubset<T, MoviesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Movies.
     * @param {MoviesUpsertArgs} args - Arguments to update or create a Movies.
     * @example
     * // Update or create a Movies
     * const movies = await prisma.movies.upsert({
     *   create: {
     *     // ... data to create a Movies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movies we want to update
     *   }
     * })
     */
    upsert<T extends MoviesUpsertArgs>(args: SelectSubset<T, MoviesUpsertArgs<ExtArgs>>): Prisma__MoviesClient<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movies.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MoviesCountArgs>(
      args?: Subset<T, MoviesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoviesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoviesAggregateArgs>(args: Subset<T, MoviesAggregateArgs>): Prisma.PrismaPromise<GetMoviesAggregateType<T>>

    /**
     * Group by Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoviesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoviesGroupByArgs['orderBy'] }
        : { orderBy?: MoviesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoviesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoviesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movies model
   */
  readonly fields: MoviesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoviesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bookmarks<T extends Movies$BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Movies$BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ContentGroupLinks<T extends Movies$ContentGroupLinksArgs<ExtArgs> = {}>(args?: Subset<T, Movies$ContentGroupLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movies model
   */ 
  interface MoviesFieldRefs {
    readonly movieid: FieldRef<"Movies", 'String'>
    readonly title: FieldRef<"Movies", 'String'>
    readonly description: FieldRef<"Movies", 'String'>
    readonly release_date: FieldRef<"Movies", 'DateTime'>
    readonly media_id_reference: FieldRef<"Movies", 'Int'>
    readonly likes: FieldRef<"Movies", 'BigInt'>
    readonly dislikes: FieldRef<"Movies", 'BigInt'>
    readonly showbanner: FieldRef<"Movies", 'String'>
    readonly age_rating: FieldRef<"Movies", 'AgeRating'>
    readonly authorid: FieldRef<"Movies", 'String'>
    readonly media_reference_type: FieldRef<"Movies", 'MediaType'>
    readonly MediaGenre: FieldRef<"Movies", 'MediaGenre[]'>
  }
    

  // Custom InputTypes
  /**
   * Movies findUnique
   */
  export type MoviesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where: MoviesWhereUniqueInput
  }

  /**
   * Movies findUniqueOrThrow
   */
  export type MoviesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where: MoviesWhereUniqueInput
  }

  /**
   * Movies findFirst
   */
  export type MoviesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MoviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MoviesOrderByWithRelationInput | MoviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MoviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * Movies findFirstOrThrow
   */
  export type MoviesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MoviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MoviesOrderByWithRelationInput | MoviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MoviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * Movies findMany
   */
  export type MoviesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MoviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MoviesOrderByWithRelationInput | MoviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MoviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * Movies create
   */
  export type MoviesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * The data needed to create a Movies.
     */
    data: XOR<MoviesCreateInput, MoviesUncheckedCreateInput>
  }

  /**
   * Movies createMany
   */
  export type MoviesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MoviesCreateManyInput | MoviesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movies createManyAndReturn
   */
  export type MoviesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MoviesCreateManyInput | MoviesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movies update
   */
  export type MoviesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * The data needed to update a Movies.
     */
    data: XOR<MoviesUpdateInput, MoviesUncheckedUpdateInput>
    /**
     * Choose, which Movies to update.
     */
    where: MoviesWhereUniqueInput
  }

  /**
   * Movies updateMany
   */
  export type MoviesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MoviesUpdateManyMutationInput, MoviesUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MoviesWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
  }

  /**
   * Movies updateManyAndReturn
   */
  export type MoviesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * The data used to update Movies.
     */
    data: XOR<MoviesUpdateManyMutationInput, MoviesUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MoviesWhereInput
    /**
     * Limit how many Movies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movies upsert
   */
  export type MoviesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * The filter to search for the Movies to update in case it exists.
     */
    where: MoviesWhereUniqueInput
    /**
     * In case the Movies found by the `where` argument doesn't exist, create a new Movies with this data.
     */
    create: XOR<MoviesCreateInput, MoviesUncheckedCreateInput>
    /**
     * In case the Movies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoviesUpdateInput, MoviesUncheckedUpdateInput>
  }

  /**
   * Movies delete
   */
  export type MoviesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    /**
     * Filter which Movies to delete.
     */
    where: MoviesWhereUniqueInput
  }

  /**
   * Movies deleteMany
   */
  export type MoviesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MoviesWhereInput
    /**
     * Limit how many Movies to delete.
     */
    limit?: number
  }

  /**
   * Movies.Bookmarks
   */
  export type Movies$BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    cursor?: BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Movies.ContentGroupLinks
   */
  export type Movies$ContentGroupLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGroupMedia
     */
    select?: ContentGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGroupMedia
     */
    omit?: ContentGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGroupMediaInclude<ExtArgs> | null
    where?: ContentGroupMediaWhereInput
    orderBy?: ContentGroupMediaOrderByWithRelationInput | ContentGroupMediaOrderByWithRelationInput[]
    cursor?: ContentGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentGroupMediaScalarFieldEnum | ContentGroupMediaScalarFieldEnum[]
  }

  /**
   * Movies without action
   */
  export type MoviesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
  }


  /**
   * Model Polls
   */

  export type AggregatePolls = {
    _count: PollsCountAggregateOutputType | null
    _avg: PollsAvgAggregateOutputType | null
    _sum: PollsSumAggregateOutputType | null
    _min: PollsMinAggregateOutputType | null
    _max: PollsMaxAggregateOutputType | null
  }

  export type PollsAvgAggregateOutputType = {
    pollid: number | null
    likes: number | null
    dislikes: number | null
    views: number | null
  }

  export type PollsSumAggregateOutputType = {
    pollid: number | null
    likes: bigint | null
    dislikes: bigint | null
    views: number | null
  }

  export type PollsMinAggregateOutputType = {
    pollid: number | null
    author: string | null
    title: string | null
    description: string | null
    likes: bigint | null
    dislikes: bigint | null
    date: Date | null
    category: string | null
    status: string | null
    progress: string | null
    views: number | null
  }

  export type PollsMaxAggregateOutputType = {
    pollid: number | null
    author: string | null
    title: string | null
    description: string | null
    likes: bigint | null
    dislikes: bigint | null
    date: Date | null
    category: string | null
    status: string | null
    progress: string | null
    views: number | null
  }

  export type PollsCountAggregateOutputType = {
    pollid: number
    author: number
    title: number
    description: number
    likes: number
    dislikes: number
    date: number
    category: number
    status: number
    progress: number
    views: number
    _all: number
  }


  export type PollsAvgAggregateInputType = {
    pollid?: true
    likes?: true
    dislikes?: true
    views?: true
  }

  export type PollsSumAggregateInputType = {
    pollid?: true
    likes?: true
    dislikes?: true
    views?: true
  }

  export type PollsMinAggregateInputType = {
    pollid?: true
    author?: true
    title?: true
    description?: true
    likes?: true
    dislikes?: true
    date?: true
    category?: true
    status?: true
    progress?: true
    views?: true
  }

  export type PollsMaxAggregateInputType = {
    pollid?: true
    author?: true
    title?: true
    description?: true
    likes?: true
    dislikes?: true
    date?: true
    category?: true
    status?: true
    progress?: true
    views?: true
  }

  export type PollsCountAggregateInputType = {
    pollid?: true
    author?: true
    title?: true
    description?: true
    likes?: true
    dislikes?: true
    date?: true
    category?: true
    status?: true
    progress?: true
    views?: true
    _all?: true
  }

  export type PollsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Polls to aggregate.
     */
    where?: PollsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollsOrderByWithRelationInput | PollsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Polls
    **/
    _count?: true | PollsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PollsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PollsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollsMaxAggregateInputType
  }

  export type GetPollsAggregateType<T extends PollsAggregateArgs> = {
        [P in keyof T & keyof AggregatePolls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolls[P]>
      : GetScalarType<T[P], AggregatePolls[P]>
  }




  export type PollsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollsWhereInput
    orderBy?: PollsOrderByWithAggregationInput | PollsOrderByWithAggregationInput[]
    by: PollsScalarFieldEnum[] | PollsScalarFieldEnum
    having?: PollsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollsCountAggregateInputType | true
    _avg?: PollsAvgAggregateInputType
    _sum?: PollsSumAggregateInputType
    _min?: PollsMinAggregateInputType
    _max?: PollsMaxAggregateInputType
  }

  export type PollsGroupByOutputType = {
    pollid: number
    author: string
    title: string
    description: string
    likes: bigint
    dislikes: bigint
    date: Date | null
    category: string
    status: string
    progress: string | null
    views: number
    _count: PollsCountAggregateOutputType | null
    _avg: PollsAvgAggregateOutputType | null
    _sum: PollsSumAggregateOutputType | null
    _min: PollsMinAggregateOutputType | null
    _max: PollsMaxAggregateOutputType | null
  }

  type GetPollsGroupByPayload<T extends PollsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollsGroupByOutputType[P]>
            : GetScalarType<T[P], PollsGroupByOutputType[P]>
        }
      >
    >


  export type PollsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pollid?: boolean
    author?: boolean
    title?: boolean
    description?: boolean
    likes?: boolean
    dislikes?: boolean
    date?: boolean
    category?: boolean
    status?: boolean
    progress?: boolean
    views?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["polls"]>

  export type PollsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pollid?: boolean
    author?: boolean
    title?: boolean
    description?: boolean
    likes?: boolean
    dislikes?: boolean
    date?: boolean
    category?: boolean
    status?: boolean
    progress?: boolean
    views?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["polls"]>

  export type PollsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pollid?: boolean
    author?: boolean
    title?: boolean
    description?: boolean
    likes?: boolean
    dislikes?: boolean
    date?: boolean
    category?: boolean
    status?: boolean
    progress?: boolean
    views?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["polls"]>

  export type PollsSelectScalar = {
    pollid?: boolean
    author?: boolean
    title?: boolean
    description?: boolean
    likes?: boolean
    dislikes?: boolean
    date?: boolean
    category?: boolean
    status?: boolean
    progress?: boolean
    views?: boolean
  }

  export type PollsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pollid" | "author" | "title" | "description" | "likes" | "dislikes" | "date" | "category" | "status" | "progress" | "views", ExtArgs["result"]["polls"]>
  export type PollsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PollsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PollsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PollsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Polls"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pollid: number
      author: string
      title: string
      description: string
      likes: bigint
      dislikes: bigint
      date: Date | null
      category: string
      status: string
      progress: string | null
      views: number
    }, ExtArgs["result"]["polls"]>
    composites: {}
  }

  type PollsGetPayload<S extends boolean | null | undefined | PollsDefaultArgs> = $Result.GetResult<Prisma.$PollsPayload, S>

  type PollsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PollsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PollsCountAggregateInputType | true
    }

  export interface PollsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Polls'], meta: { name: 'Polls' } }
    /**
     * Find zero or one Polls that matches the filter.
     * @param {PollsFindUniqueArgs} args - Arguments to find a Polls
     * @example
     * // Get one Polls
     * const polls = await prisma.polls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollsFindUniqueArgs>(args: SelectSubset<T, PollsFindUniqueArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Polls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollsFindUniqueOrThrowArgs} args - Arguments to find a Polls
     * @example
     * // Get one Polls
     * const polls = await prisma.polls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollsFindUniqueOrThrowArgs>(args: SelectSubset<T, PollsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Polls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsFindFirstArgs} args - Arguments to find a Polls
     * @example
     * // Get one Polls
     * const polls = await prisma.polls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollsFindFirstArgs>(args?: SelectSubset<T, PollsFindFirstArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Polls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsFindFirstOrThrowArgs} args - Arguments to find a Polls
     * @example
     * // Get one Polls
     * const polls = await prisma.polls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollsFindFirstOrThrowArgs>(args?: SelectSubset<T, PollsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Polls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Polls
     * const polls = await prisma.polls.findMany()
     * 
     * // Get first 10 Polls
     * const polls = await prisma.polls.findMany({ take: 10 })
     * 
     * // Only select the `pollid`
     * const pollsWithPollidOnly = await prisma.polls.findMany({ select: { pollid: true } })
     * 
     */
    findMany<T extends PollsFindManyArgs>(args?: SelectSubset<T, PollsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Polls.
     * @param {PollsCreateArgs} args - Arguments to create a Polls.
     * @example
     * // Create one Polls
     * const Polls = await prisma.polls.create({
     *   data: {
     *     // ... data to create a Polls
     *   }
     * })
     * 
     */
    create<T extends PollsCreateArgs>(args: SelectSubset<T, PollsCreateArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Polls.
     * @param {PollsCreateManyArgs} args - Arguments to create many Polls.
     * @example
     * // Create many Polls
     * const polls = await prisma.polls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollsCreateManyArgs>(args?: SelectSubset<T, PollsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Polls and returns the data saved in the database.
     * @param {PollsCreateManyAndReturnArgs} args - Arguments to create many Polls.
     * @example
     * // Create many Polls
     * const polls = await prisma.polls.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Polls and only return the `pollid`
     * const pollsWithPollidOnly = await prisma.polls.createManyAndReturn({
     *   select: { pollid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollsCreateManyAndReturnArgs>(args?: SelectSubset<T, PollsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Polls.
     * @param {PollsDeleteArgs} args - Arguments to delete one Polls.
     * @example
     * // Delete one Polls
     * const Polls = await prisma.polls.delete({
     *   where: {
     *     // ... filter to delete one Polls
     *   }
     * })
     * 
     */
    delete<T extends PollsDeleteArgs>(args: SelectSubset<T, PollsDeleteArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Polls.
     * @param {PollsUpdateArgs} args - Arguments to update one Polls.
     * @example
     * // Update one Polls
     * const polls = await prisma.polls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollsUpdateArgs>(args: SelectSubset<T, PollsUpdateArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Polls.
     * @param {PollsDeleteManyArgs} args - Arguments to filter Polls to delete.
     * @example
     * // Delete a few Polls
     * const { count } = await prisma.polls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollsDeleteManyArgs>(args?: SelectSubset<T, PollsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Polls
     * const polls = await prisma.polls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollsUpdateManyArgs>(args: SelectSubset<T, PollsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Polls and returns the data updated in the database.
     * @param {PollsUpdateManyAndReturnArgs} args - Arguments to update many Polls.
     * @example
     * // Update many Polls
     * const polls = await prisma.polls.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Polls and only return the `pollid`
     * const pollsWithPollidOnly = await prisma.polls.updateManyAndReturn({
     *   select: { pollid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PollsUpdateManyAndReturnArgs>(args: SelectSubset<T, PollsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Polls.
     * @param {PollsUpsertArgs} args - Arguments to update or create a Polls.
     * @example
     * // Update or create a Polls
     * const polls = await prisma.polls.upsert({
     *   create: {
     *     // ... data to create a Polls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Polls we want to update
     *   }
     * })
     */
    upsert<T extends PollsUpsertArgs>(args: SelectSubset<T, PollsUpsertArgs<ExtArgs>>): Prisma__PollsClient<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsCountArgs} args - Arguments to filter Polls to count.
     * @example
     * // Count the number of Polls
     * const count = await prisma.polls.count({
     *   where: {
     *     // ... the filter for the Polls we want to count
     *   }
     * })
    **/
    count<T extends PollsCountArgs>(
      args?: Subset<T, PollsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollsAggregateArgs>(args: Subset<T, PollsAggregateArgs>): Prisma.PrismaPromise<GetPollsAggregateType<T>>

    /**
     * Group by Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollsGroupByArgs['orderBy'] }
        : { orderBy?: PollsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Polls model
   */
  readonly fields: PollsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Polls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Polls model
   */ 
  interface PollsFieldRefs {
    readonly pollid: FieldRef<"Polls", 'Int'>
    readonly author: FieldRef<"Polls", 'String'>
    readonly title: FieldRef<"Polls", 'String'>
    readonly description: FieldRef<"Polls", 'String'>
    readonly likes: FieldRef<"Polls", 'BigInt'>
    readonly dislikes: FieldRef<"Polls", 'BigInt'>
    readonly date: FieldRef<"Polls", 'DateTime'>
    readonly category: FieldRef<"Polls", 'String'>
    readonly status: FieldRef<"Polls", 'String'>
    readonly progress: FieldRef<"Polls", 'String'>
    readonly views: FieldRef<"Polls", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Polls findUnique
   */
  export type PollsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where: PollsWhereUniqueInput
  }

  /**
   * Polls findUniqueOrThrow
   */
  export type PollsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where: PollsWhereUniqueInput
  }

  /**
   * Polls findFirst
   */
  export type PollsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where?: PollsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollsOrderByWithRelationInput | PollsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Polls.
     */
    cursor?: PollsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Polls.
     */
    distinct?: PollsScalarFieldEnum | PollsScalarFieldEnum[]
  }

  /**
   * Polls findFirstOrThrow
   */
  export type PollsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where?: PollsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollsOrderByWithRelationInput | PollsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Polls.
     */
    cursor?: PollsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Polls.
     */
    distinct?: PollsScalarFieldEnum | PollsScalarFieldEnum[]
  }

  /**
   * Polls findMany
   */
  export type PollsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter, which Polls to fetch.
     */
    where?: PollsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollsOrderByWithRelationInput | PollsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Polls.
     */
    cursor?: PollsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Polls.
     */
    skip?: number
    distinct?: PollsScalarFieldEnum | PollsScalarFieldEnum[]
  }

  /**
   * Polls create
   */
  export type PollsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * The data needed to create a Polls.
     */
    data: XOR<PollsCreateInput, PollsUncheckedCreateInput>
  }

  /**
   * Polls createMany
   */
  export type PollsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Polls.
     */
    data: PollsCreateManyInput | PollsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Polls createManyAndReturn
   */
  export type PollsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * The data used to create many Polls.
     */
    data: PollsCreateManyInput | PollsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Polls update
   */
  export type PollsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * The data needed to update a Polls.
     */
    data: XOR<PollsUpdateInput, PollsUncheckedUpdateInput>
    /**
     * Choose, which Polls to update.
     */
    where: PollsWhereUniqueInput
  }

  /**
   * Polls updateMany
   */
  export type PollsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Polls.
     */
    data: XOR<PollsUpdateManyMutationInput, PollsUncheckedUpdateManyInput>
    /**
     * Filter which Polls to update
     */
    where?: PollsWhereInput
    /**
     * Limit how many Polls to update.
     */
    limit?: number
  }

  /**
   * Polls updateManyAndReturn
   */
  export type PollsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * The data used to update Polls.
     */
    data: XOR<PollsUpdateManyMutationInput, PollsUncheckedUpdateManyInput>
    /**
     * Filter which Polls to update
     */
    where?: PollsWhereInput
    /**
     * Limit how many Polls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Polls upsert
   */
  export type PollsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * The filter to search for the Polls to update in case it exists.
     */
    where: PollsWhereUniqueInput
    /**
     * In case the Polls found by the `where` argument doesn't exist, create a new Polls with this data.
     */
    create: XOR<PollsCreateInput, PollsUncheckedCreateInput>
    /**
     * In case the Polls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollsUpdateInput, PollsUncheckedUpdateInput>
  }

  /**
   * Polls delete
   */
  export type PollsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    /**
     * Filter which Polls to delete.
     */
    where: PollsWhereUniqueInput
  }

  /**
   * Polls deleteMany
   */
  export type PollsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Polls to delete
     */
    where?: PollsWhereInput
    /**
     * Limit how many Polls to delete.
     */
    limit?: number
  }

  /**
   * Polls without action
   */
  export type PollsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
  }


  /**
   * Model Reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    reviewid: number | null
    likes: number | null
    dislikes: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    reviewid: number | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type ReviewsMinAggregateOutputType = {
    reviewid: number | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    userid: string | null
    review_text: string | null
    review_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type ReviewsMaxAggregateOutputType = {
    reviewid: number | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    userid: string | null
    review_text: string | null
    review_date: Date | null
    likes: bigint | null
    dislikes: bigint | null
  }

  export type ReviewsCountAggregateOutputType = {
    reviewid: number
    parentid: number
    mediatype: number
    userid: number
    review_text: number
    review_date: number
    likes: number
    dislikes: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    reviewid?: true
    likes?: true
    dislikes?: true
  }

  export type ReviewsSumAggregateInputType = {
    reviewid?: true
    likes?: true
    dislikes?: true
  }

  export type ReviewsMinAggregateInputType = {
    reviewid?: true
    parentid?: true
    mediatype?: true
    userid?: true
    review_text?: true
    review_date?: true
    likes?: true
    dislikes?: true
  }

  export type ReviewsMaxAggregateInputType = {
    reviewid?: true
    parentid?: true
    mediatype?: true
    userid?: true
    review_text?: true
    review_date?: true
    likes?: true
    dislikes?: true
  }

  export type ReviewsCountAggregateInputType = {
    reviewid?: true
    parentid?: true
    mediatype?: true
    userid?: true
    review_text?: true
    review_date?: true
    likes?: true
    dislikes?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to aggregate.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type ReviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithAggregationInput | ReviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: ReviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    reviewid: number
    parentid: string
    mediatype: $Enums.MediaType
    userid: string
    review_text: string
    review_date: Date
    likes: bigint
    dislikes: bigint
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends ReviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type ReviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewid?: boolean
    parentid?: boolean
    mediatype?: boolean
    userid?: boolean
    review_text?: boolean
    review_date?: boolean
    likes?: boolean
    dislikes?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewid?: boolean
    parentid?: boolean
    mediatype?: boolean
    userid?: boolean
    review_text?: boolean
    review_date?: boolean
    likes?: boolean
    dislikes?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewid?: boolean
    parentid?: boolean
    mediatype?: boolean
    userid?: boolean
    review_text?: boolean
    review_date?: boolean
    likes?: boolean
    dislikes?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type ReviewsSelectScalar = {
    reviewid?: boolean
    parentid?: boolean
    mediatype?: boolean
    userid?: boolean
    review_text?: boolean
    review_date?: boolean
    likes?: boolean
    dislikes?: boolean
  }

  export type ReviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"reviewid" | "parentid" | "mediatype" | "userid" | "review_text" | "review_date" | "likes" | "dislikes", ExtArgs["result"]["reviews"]>
  export type ReviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ReviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ReviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ReviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reviews"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reviewid: number
      parentid: string
      mediatype: $Enums.MediaType
      userid: string
      review_text: string
      review_date: Date
      likes: bigint
      dislikes: bigint
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type ReviewsGetPayload<S extends boolean | null | undefined | ReviewsDefaultArgs> = $Result.GetResult<Prisma.$ReviewsPayload, S>

  type ReviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface ReviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reviews'], meta: { name: 'Reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {ReviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewsFindUniqueArgs>(args: SelectSubset<T, ReviewsFindUniqueArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewsFindFirstArgs>(args?: SelectSubset<T, ReviewsFindFirstArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `reviewid`
     * const reviewsWithReviewidOnly = await prisma.reviews.findMany({ select: { reviewid: true } })
     * 
     */
    findMany<T extends ReviewsFindManyArgs>(args?: SelectSubset<T, ReviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {ReviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends ReviewsCreateArgs>(args: SelectSubset<T, ReviewsCreateArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewsCreateManyArgs>(args?: SelectSubset<T, ReviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `reviewid`
     * const reviewsWithReviewidOnly = await prisma.reviews.createManyAndReturn({
     *   select: { reviewid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {ReviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends ReviewsDeleteArgs>(args: SelectSubset<T, ReviewsDeleteArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {ReviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewsUpdateArgs>(args: SelectSubset<T, ReviewsUpdateArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewsDeleteManyArgs>(args?: SelectSubset<T, ReviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewsUpdateManyArgs>(args: SelectSubset<T, ReviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `reviewid`
     * const reviewsWithReviewidOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { reviewid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {ReviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends ReviewsUpsertArgs>(args: SelectSubset<T, ReviewsUpsertArgs<ExtArgs>>): Prisma__ReviewsClient<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewsCountArgs>(
      args?: Subset<T, ReviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewsGroupByArgs['orderBy'] }
        : { orderBy?: ReviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reviews model
   */
  readonly fields: ReviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reviews model
   */ 
  interface ReviewsFieldRefs {
    readonly reviewid: FieldRef<"Reviews", 'Int'>
    readonly parentid: FieldRef<"Reviews", 'String'>
    readonly mediatype: FieldRef<"Reviews", 'MediaType'>
    readonly userid: FieldRef<"Reviews", 'String'>
    readonly review_text: FieldRef<"Reviews", 'String'>
    readonly review_date: FieldRef<"Reviews", 'DateTime'>
    readonly likes: FieldRef<"Reviews", 'BigInt'>
    readonly dislikes: FieldRef<"Reviews", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Reviews findUnique
   */
  export type ReviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findUniqueOrThrow
   */
  export type ReviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews findFirst
   */
  export type ReviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findFirstOrThrow
   */
  export type ReviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews findMany
   */
  export type ReviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Reviews create
   */
  export type ReviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a Reviews.
     */
    data: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
  }

  /**
   * Reviews createMany
   */
  export type ReviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewsCreateManyInput | ReviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reviews createManyAndReturn
   */
  export type ReviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewsCreateManyInput | ReviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reviews update
   */
  export type ReviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a Reviews.
     */
    data: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
    /**
     * Choose, which Reviews to update.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews updateMany
   */
  export type ReviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Reviews updateManyAndReturn
   */
  export type ReviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reviews upsert
   */
  export type ReviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the Reviews to update in case it exists.
     */
    where: ReviewsWhereUniqueInput
    /**
     * In case the Reviews found by the `where` argument doesn't exist, create a new Reviews with this data.
     */
    create: XOR<ReviewsCreateInput, ReviewsUncheckedCreateInput>
    /**
     * In case the Reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewsUpdateInput, ReviewsUncheckedUpdateInput>
  }

  /**
   * Reviews delete
   */
  export type ReviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    /**
     * Filter which Reviews to delete.
     */
    where: ReviewsWhereUniqueInput
  }

  /**
   * Reviews deleteMany
   */
  export type ReviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewsWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Reviews without action
   */
  export type ReviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
  }


  /**
   * Model Shopping_Cart
   */

  export type AggregateShopping_Cart = {
    _count: Shopping_CartCountAggregateOutputType | null
    _avg: Shopping_CartAvgAggregateOutputType | null
    _sum: Shopping_CartSumAggregateOutputType | null
    _min: Shopping_CartMinAggregateOutputType | null
    _max: Shopping_CartMaxAggregateOutputType | null
  }

  export type Shopping_CartAvgAggregateOutputType = {
    quantity: number | null
  }

  export type Shopping_CartSumAggregateOutputType = {
    quantity: number | null
  }

  export type Shopping_CartMinAggregateOutputType = {
    userid: string | null
    storeid: string | null
    quantity: number | null
  }

  export type Shopping_CartMaxAggregateOutputType = {
    userid: string | null
    storeid: string | null
    quantity: number | null
  }

  export type Shopping_CartCountAggregateOutputType = {
    userid: number
    storeid: number
    quantity: number
    _all: number
  }


  export type Shopping_CartAvgAggregateInputType = {
    quantity?: true
  }

  export type Shopping_CartSumAggregateInputType = {
    quantity?: true
  }

  export type Shopping_CartMinAggregateInputType = {
    userid?: true
    storeid?: true
    quantity?: true
  }

  export type Shopping_CartMaxAggregateInputType = {
    userid?: true
    storeid?: true
    quantity?: true
  }

  export type Shopping_CartCountAggregateInputType = {
    userid?: true
    storeid?: true
    quantity?: true
    _all?: true
  }

  export type Shopping_CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shopping_Cart to aggregate.
     */
    where?: Shopping_CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shopping_Carts to fetch.
     */
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Shopping_CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shopping_Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shopping_Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shopping_Carts
    **/
    _count?: true | Shopping_CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shopping_CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shopping_CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shopping_CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shopping_CartMaxAggregateInputType
  }

  export type GetShopping_CartAggregateType<T extends Shopping_CartAggregateArgs> = {
        [P in keyof T & keyof AggregateShopping_Cart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopping_Cart[P]>
      : GetScalarType<T[P], AggregateShopping_Cart[P]>
  }




  export type Shopping_CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Shopping_CartWhereInput
    orderBy?: Shopping_CartOrderByWithAggregationInput | Shopping_CartOrderByWithAggregationInput[]
    by: Shopping_CartScalarFieldEnum[] | Shopping_CartScalarFieldEnum
    having?: Shopping_CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shopping_CartCountAggregateInputType | true
    _avg?: Shopping_CartAvgAggregateInputType
    _sum?: Shopping_CartSumAggregateInputType
    _min?: Shopping_CartMinAggregateInputType
    _max?: Shopping_CartMaxAggregateInputType
  }

  export type Shopping_CartGroupByOutputType = {
    userid: string
    storeid: string
    quantity: number | null
    _count: Shopping_CartCountAggregateOutputType | null
    _avg: Shopping_CartAvgAggregateOutputType | null
    _sum: Shopping_CartSumAggregateOutputType | null
    _min: Shopping_CartMinAggregateOutputType | null
    _max: Shopping_CartMaxAggregateOutputType | null
  }

  type GetShopping_CartGroupByPayload<T extends Shopping_CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shopping_CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shopping_CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shopping_CartGroupByOutputType[P]>
            : GetScalarType<T[P], Shopping_CartGroupByOutputType[P]>
        }
      >
    >


  export type Shopping_CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    storeid?: boolean
    quantity?: boolean
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping_Cart"]>

  export type Shopping_CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    storeid?: boolean
    quantity?: boolean
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping_Cart"]>

  export type Shopping_CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    storeid?: boolean
    quantity?: boolean
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping_Cart"]>

  export type Shopping_CartSelectScalar = {
    userid?: boolean
    storeid?: boolean
    quantity?: boolean
  }

  export type Shopping_CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "storeid" | "quantity", ExtArgs["result"]["shopping_Cart"]>
  export type Shopping_CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Shopping_CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type Shopping_CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Store?: boolean | StoreDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $Shopping_CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shopping_Cart"
    objects: {
      Store: Prisma.$StorePayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      storeid: string
      quantity: number | null
    }, ExtArgs["result"]["shopping_Cart"]>
    composites: {}
  }

  type Shopping_CartGetPayload<S extends boolean | null | undefined | Shopping_CartDefaultArgs> = $Result.GetResult<Prisma.$Shopping_CartPayload, S>

  type Shopping_CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Shopping_CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Shopping_CartCountAggregateInputType | true
    }

  export interface Shopping_CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shopping_Cart'], meta: { name: 'Shopping_Cart' } }
    /**
     * Find zero or one Shopping_Cart that matches the filter.
     * @param {Shopping_CartFindUniqueArgs} args - Arguments to find a Shopping_Cart
     * @example
     * // Get one Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Shopping_CartFindUniqueArgs>(args: SelectSubset<T, Shopping_CartFindUniqueArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shopping_Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Shopping_CartFindUniqueOrThrowArgs} args - Arguments to find a Shopping_Cart
     * @example
     * // Get one Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Shopping_CartFindUniqueOrThrowArgs>(args: SelectSubset<T, Shopping_CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopping_Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartFindFirstArgs} args - Arguments to find a Shopping_Cart
     * @example
     * // Get one Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Shopping_CartFindFirstArgs>(args?: SelectSubset<T, Shopping_CartFindFirstArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopping_Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartFindFirstOrThrowArgs} args - Arguments to find a Shopping_Cart
     * @example
     * // Get one Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Shopping_CartFindFirstOrThrowArgs>(args?: SelectSubset<T, Shopping_CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shopping_Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shopping_Carts
     * const shopping_Carts = await prisma.shopping_Cart.findMany()
     * 
     * // Get first 10 Shopping_Carts
     * const shopping_Carts = await prisma.shopping_Cart.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const shopping_CartWithUseridOnly = await prisma.shopping_Cart.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends Shopping_CartFindManyArgs>(args?: SelectSubset<T, Shopping_CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shopping_Cart.
     * @param {Shopping_CartCreateArgs} args - Arguments to create a Shopping_Cart.
     * @example
     * // Create one Shopping_Cart
     * const Shopping_Cart = await prisma.shopping_Cart.create({
     *   data: {
     *     // ... data to create a Shopping_Cart
     *   }
     * })
     * 
     */
    create<T extends Shopping_CartCreateArgs>(args: SelectSubset<T, Shopping_CartCreateArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shopping_Carts.
     * @param {Shopping_CartCreateManyArgs} args - Arguments to create many Shopping_Carts.
     * @example
     * // Create many Shopping_Carts
     * const shopping_Cart = await prisma.shopping_Cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Shopping_CartCreateManyArgs>(args?: SelectSubset<T, Shopping_CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shopping_Carts and returns the data saved in the database.
     * @param {Shopping_CartCreateManyAndReturnArgs} args - Arguments to create many Shopping_Carts.
     * @example
     * // Create many Shopping_Carts
     * const shopping_Cart = await prisma.shopping_Cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shopping_Carts and only return the `userid`
     * const shopping_CartWithUseridOnly = await prisma.shopping_Cart.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Shopping_CartCreateManyAndReturnArgs>(args?: SelectSubset<T, Shopping_CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shopping_Cart.
     * @param {Shopping_CartDeleteArgs} args - Arguments to delete one Shopping_Cart.
     * @example
     * // Delete one Shopping_Cart
     * const Shopping_Cart = await prisma.shopping_Cart.delete({
     *   where: {
     *     // ... filter to delete one Shopping_Cart
     *   }
     * })
     * 
     */
    delete<T extends Shopping_CartDeleteArgs>(args: SelectSubset<T, Shopping_CartDeleteArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shopping_Cart.
     * @param {Shopping_CartUpdateArgs} args - Arguments to update one Shopping_Cart.
     * @example
     * // Update one Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Shopping_CartUpdateArgs>(args: SelectSubset<T, Shopping_CartUpdateArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shopping_Carts.
     * @param {Shopping_CartDeleteManyArgs} args - Arguments to filter Shopping_Carts to delete.
     * @example
     * // Delete a few Shopping_Carts
     * const { count } = await prisma.shopping_Cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Shopping_CartDeleteManyArgs>(args?: SelectSubset<T, Shopping_CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shopping_Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shopping_Carts
     * const shopping_Cart = await prisma.shopping_Cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Shopping_CartUpdateManyArgs>(args: SelectSubset<T, Shopping_CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shopping_Carts and returns the data updated in the database.
     * @param {Shopping_CartUpdateManyAndReturnArgs} args - Arguments to update many Shopping_Carts.
     * @example
     * // Update many Shopping_Carts
     * const shopping_Cart = await prisma.shopping_Cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shopping_Carts and only return the `userid`
     * const shopping_CartWithUseridOnly = await prisma.shopping_Cart.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Shopping_CartUpdateManyAndReturnArgs>(args: SelectSubset<T, Shopping_CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shopping_Cart.
     * @param {Shopping_CartUpsertArgs} args - Arguments to update or create a Shopping_Cart.
     * @example
     * // Update or create a Shopping_Cart
     * const shopping_Cart = await prisma.shopping_Cart.upsert({
     *   create: {
     *     // ... data to create a Shopping_Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shopping_Cart we want to update
     *   }
     * })
     */
    upsert<T extends Shopping_CartUpsertArgs>(args: SelectSubset<T, Shopping_CartUpsertArgs<ExtArgs>>): Prisma__Shopping_CartClient<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shopping_Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartCountArgs} args - Arguments to filter Shopping_Carts to count.
     * @example
     * // Count the number of Shopping_Carts
     * const count = await prisma.shopping_Cart.count({
     *   where: {
     *     // ... the filter for the Shopping_Carts we want to count
     *   }
     * })
    **/
    count<T extends Shopping_CartCountArgs>(
      args?: Subset<T, Shopping_CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shopping_CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shopping_Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shopping_CartAggregateArgs>(args: Subset<T, Shopping_CartAggregateArgs>): Prisma.PrismaPromise<GetShopping_CartAggregateType<T>>

    /**
     * Group by Shopping_Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Shopping_CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Shopping_CartGroupByArgs['orderBy'] }
        : { orderBy?: Shopping_CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Shopping_CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_CartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shopping_Cart model
   */
  readonly fields: Shopping_CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shopping_Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Shopping_CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shopping_Cart model
   */ 
  interface Shopping_CartFieldRefs {
    readonly userid: FieldRef<"Shopping_Cart", 'String'>
    readonly storeid: FieldRef<"Shopping_Cart", 'String'>
    readonly quantity: FieldRef<"Shopping_Cart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Shopping_Cart findUnique
   */
  export type Shopping_CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter, which Shopping_Cart to fetch.
     */
    where: Shopping_CartWhereUniqueInput
  }

  /**
   * Shopping_Cart findUniqueOrThrow
   */
  export type Shopping_CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter, which Shopping_Cart to fetch.
     */
    where: Shopping_CartWhereUniqueInput
  }

  /**
   * Shopping_Cart findFirst
   */
  export type Shopping_CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter, which Shopping_Cart to fetch.
     */
    where?: Shopping_CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shopping_Carts to fetch.
     */
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shopping_Carts.
     */
    cursor?: Shopping_CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shopping_Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shopping_Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shopping_Carts.
     */
    distinct?: Shopping_CartScalarFieldEnum | Shopping_CartScalarFieldEnum[]
  }

  /**
   * Shopping_Cart findFirstOrThrow
   */
  export type Shopping_CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter, which Shopping_Cart to fetch.
     */
    where?: Shopping_CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shopping_Carts to fetch.
     */
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shopping_Carts.
     */
    cursor?: Shopping_CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shopping_Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shopping_Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shopping_Carts.
     */
    distinct?: Shopping_CartScalarFieldEnum | Shopping_CartScalarFieldEnum[]
  }

  /**
   * Shopping_Cart findMany
   */
  export type Shopping_CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter, which Shopping_Carts to fetch.
     */
    where?: Shopping_CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shopping_Carts to fetch.
     */
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shopping_Carts.
     */
    cursor?: Shopping_CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shopping_Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shopping_Carts.
     */
    skip?: number
    distinct?: Shopping_CartScalarFieldEnum | Shopping_CartScalarFieldEnum[]
  }

  /**
   * Shopping_Cart create
   */
  export type Shopping_CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Shopping_Cart.
     */
    data: XOR<Shopping_CartCreateInput, Shopping_CartUncheckedCreateInput>
  }

  /**
   * Shopping_Cart createMany
   */
  export type Shopping_CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shopping_Carts.
     */
    data: Shopping_CartCreateManyInput | Shopping_CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shopping_Cart createManyAndReturn
   */
  export type Shopping_CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * The data used to create many Shopping_Carts.
     */
    data: Shopping_CartCreateManyInput | Shopping_CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shopping_Cart update
   */
  export type Shopping_CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Shopping_Cart.
     */
    data: XOR<Shopping_CartUpdateInput, Shopping_CartUncheckedUpdateInput>
    /**
     * Choose, which Shopping_Cart to update.
     */
    where: Shopping_CartWhereUniqueInput
  }

  /**
   * Shopping_Cart updateMany
   */
  export type Shopping_CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shopping_Carts.
     */
    data: XOR<Shopping_CartUpdateManyMutationInput, Shopping_CartUncheckedUpdateManyInput>
    /**
     * Filter which Shopping_Carts to update
     */
    where?: Shopping_CartWhereInput
    /**
     * Limit how many Shopping_Carts to update.
     */
    limit?: number
  }

  /**
   * Shopping_Cart updateManyAndReturn
   */
  export type Shopping_CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * The data used to update Shopping_Carts.
     */
    data: XOR<Shopping_CartUpdateManyMutationInput, Shopping_CartUncheckedUpdateManyInput>
    /**
     * Filter which Shopping_Carts to update
     */
    where?: Shopping_CartWhereInput
    /**
     * Limit how many Shopping_Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shopping_Cart upsert
   */
  export type Shopping_CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Shopping_Cart to update in case it exists.
     */
    where: Shopping_CartWhereUniqueInput
    /**
     * In case the Shopping_Cart found by the `where` argument doesn't exist, create a new Shopping_Cart with this data.
     */
    create: XOR<Shopping_CartCreateInput, Shopping_CartUncheckedCreateInput>
    /**
     * In case the Shopping_Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Shopping_CartUpdateInput, Shopping_CartUncheckedUpdateInput>
  }

  /**
   * Shopping_Cart delete
   */
  export type Shopping_CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    /**
     * Filter which Shopping_Cart to delete.
     */
    where: Shopping_CartWhereUniqueInput
  }

  /**
   * Shopping_Cart deleteMany
   */
  export type Shopping_CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shopping_Carts to delete
     */
    where?: Shopping_CartWhereInput
    /**
     * Limit how many Shopping_Carts to delete.
     */
    limit?: number
  }

  /**
   * Shopping_Cart without action
   */
  export type Shopping_CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    num_in_stock: number | null
    original_price: Decimal | null
    discount_price: Decimal | null
    discount_percent: number | null
    shipping_price: Decimal | null
    num_of_carts: number | null
    media_id_reference: number | null
    sales: number | null
  }

  export type StoreSumAggregateOutputType = {
    num_in_stock: number | null
    original_price: Decimal | null
    discount_price: Decimal | null
    discount_percent: number | null
    shipping_price: Decimal | null
    num_of_carts: number | null
    media_id_reference: number | null
    sales: number | null
  }

  export type StoreMinAggregateOutputType = {
    storeid: string | null
    sellerid: string | null
    title: string | null
    num_in_stock: number | null
    release_date: Date | null
    original_price: Decimal | null
    discount_price: Decimal | null
    discount_percent: number | null
    shipping_price: Decimal | null
    description: string | null
    num_of_carts: number | null
    images: string | null
    media_id_reference: number | null
    sales: number | null
    reference_media_type: string | null
  }

  export type StoreMaxAggregateOutputType = {
    storeid: string | null
    sellerid: string | null
    title: string | null
    num_in_stock: number | null
    release_date: Date | null
    original_price: Decimal | null
    discount_price: Decimal | null
    discount_percent: number | null
    shipping_price: Decimal | null
    description: string | null
    num_of_carts: number | null
    images: string | null
    media_id_reference: number | null
    sales: number | null
    reference_media_type: string | null
  }

  export type StoreCountAggregateOutputType = {
    storeid: number
    sellerid: number
    title: number
    num_in_stock: number
    release_date: number
    original_price: number
    discount_price: number
    discount_percent: number
    shipping_price: number
    description: number
    num_of_carts: number
    images: number
    media_id_reference: number
    sales: number
    reference_media_type: number
    MediaGenre: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    num_in_stock?: true
    original_price?: true
    discount_price?: true
    discount_percent?: true
    shipping_price?: true
    num_of_carts?: true
    media_id_reference?: true
    sales?: true
  }

  export type StoreSumAggregateInputType = {
    num_in_stock?: true
    original_price?: true
    discount_price?: true
    discount_percent?: true
    shipping_price?: true
    num_of_carts?: true
    media_id_reference?: true
    sales?: true
  }

  export type StoreMinAggregateInputType = {
    storeid?: true
    sellerid?: true
    title?: true
    num_in_stock?: true
    release_date?: true
    original_price?: true
    discount_price?: true
    discount_percent?: true
    shipping_price?: true
    description?: true
    num_of_carts?: true
    images?: true
    media_id_reference?: true
    sales?: true
    reference_media_type?: true
  }

  export type StoreMaxAggregateInputType = {
    storeid?: true
    sellerid?: true
    title?: true
    num_in_stock?: true
    release_date?: true
    original_price?: true
    discount_price?: true
    discount_percent?: true
    shipping_price?: true
    description?: true
    num_of_carts?: true
    images?: true
    media_id_reference?: true
    sales?: true
    reference_media_type?: true
  }

  export type StoreCountAggregateInputType = {
    storeid?: true
    sellerid?: true
    title?: true
    num_in_stock?: true
    release_date?: true
    original_price?: true
    discount_price?: true
    discount_percent?: true
    shipping_price?: true
    description?: true
    num_of_carts?: true
    images?: true
    media_id_reference?: true
    sales?: true
    reference_media_type?: true
    MediaGenre?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    storeid: string
    sellerid: string
    title: string
    num_in_stock: number
    release_date: Date | null
    original_price: Decimal
    discount_price: Decimal
    discount_percent: number
    shipping_price: Decimal
    description: string
    num_of_carts: number
    images: string | null
    media_id_reference: number | null
    sales: number
    reference_media_type: string | null
    MediaGenre: $Enums.MediaGenre[]
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storeid?: boolean
    sellerid?: boolean
    title?: boolean
    num_in_stock?: boolean
    release_date?: boolean
    original_price?: boolean
    discount_price?: boolean
    discount_percent?: boolean
    shipping_price?: boolean
    description?: boolean
    num_of_carts?: boolean
    images?: boolean
    media_id_reference?: boolean
    sales?: boolean
    reference_media_type?: boolean
    MediaGenre?: boolean
    Shopping_Cart?: boolean | Store$Shopping_CartArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storeid?: boolean
    sellerid?: boolean
    title?: boolean
    num_in_stock?: boolean
    release_date?: boolean
    original_price?: boolean
    discount_price?: boolean
    discount_percent?: boolean
    shipping_price?: boolean
    description?: boolean
    num_of_carts?: boolean
    images?: boolean
    media_id_reference?: boolean
    sales?: boolean
    reference_media_type?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storeid?: boolean
    sellerid?: boolean
    title?: boolean
    num_in_stock?: boolean
    release_date?: boolean
    original_price?: boolean
    discount_price?: boolean
    discount_percent?: boolean
    shipping_price?: boolean
    description?: boolean
    num_of_carts?: boolean
    images?: boolean
    media_id_reference?: boolean
    sales?: boolean
    reference_media_type?: boolean
    MediaGenre?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    storeid?: boolean
    sellerid?: boolean
    title?: boolean
    num_in_stock?: boolean
    release_date?: boolean
    original_price?: boolean
    discount_price?: boolean
    discount_percent?: boolean
    shipping_price?: boolean
    description?: boolean
    num_of_carts?: boolean
    images?: boolean
    media_id_reference?: boolean
    sales?: boolean
    reference_media_type?: boolean
    MediaGenre?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"storeid" | "sellerid" | "title" | "num_in_stock" | "release_date" | "original_price" | "discount_price" | "discount_percent" | "shipping_price" | "description" | "num_of_carts" | "images" | "media_id_reference" | "sales" | "reference_media_type" | "MediaGenre", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Shopping_Cart?: boolean | Store$Shopping_CartArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      Shopping_Cart: Prisma.$Shopping_CartPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      storeid: string
      sellerid: string
      title: string
      num_in_stock: number
      release_date: Date | null
      original_price: Prisma.Decimal
      discount_price: Prisma.Decimal
      discount_percent: number
      shipping_price: Prisma.Decimal
      description: string
      num_of_carts: number
      images: string | null
      media_id_reference: number | null
      sales: number
      reference_media_type: string | null
      MediaGenre: $Enums.MediaGenre[]
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `storeid`
     * const storeWithStoreidOnly = await prisma.store.findMany({ select: { storeid: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `storeid`
     * const storeWithStoreidOnly = await prisma.store.createManyAndReturn({
     *   select: { storeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `storeid`
     * const storeWithStoreidOnly = await prisma.store.updateManyAndReturn({
     *   select: { storeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Shopping_Cart<T extends Store$Shopping_CartArgs<ExtArgs> = {}>(args?: Subset<T, Store$Shopping_CartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */ 
  interface StoreFieldRefs {
    readonly storeid: FieldRef<"Store", 'String'>
    readonly sellerid: FieldRef<"Store", 'String'>
    readonly title: FieldRef<"Store", 'String'>
    readonly num_in_stock: FieldRef<"Store", 'Int'>
    readonly release_date: FieldRef<"Store", 'DateTime'>
    readonly original_price: FieldRef<"Store", 'Decimal'>
    readonly discount_price: FieldRef<"Store", 'Decimal'>
    readonly discount_percent: FieldRef<"Store", 'Float'>
    readonly shipping_price: FieldRef<"Store", 'Decimal'>
    readonly description: FieldRef<"Store", 'String'>
    readonly num_of_carts: FieldRef<"Store", 'Int'>
    readonly images: FieldRef<"Store", 'String'>
    readonly media_id_reference: FieldRef<"Store", 'Int'>
    readonly sales: FieldRef<"Store", 'Int'>
    readonly reference_media_type: FieldRef<"Store", 'String'>
    readonly MediaGenre: FieldRef<"Store", 'MediaGenre[]'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.Shopping_Cart
   */
  export type Store$Shopping_CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    where?: Shopping_CartWhereInput
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    cursor?: Shopping_CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shopping_CartScalarFieldEnum | Shopping_CartScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model Subscription_Tiers
   */

  export type AggregateSubscription_Tiers = {
    _count: Subscription_TiersCountAggregateOutputType | null
    _avg: Subscription_TiersAvgAggregateOutputType | null
    _sum: Subscription_TiersSumAggregateOutputType | null
    _min: Subscription_TiersMinAggregateOutputType | null
    _max: Subscription_TiersMaxAggregateOutputType | null
  }

  export type Subscription_TiersAvgAggregateOutputType = {
    tierid: number | null
    price: number | null
    votepower: number | null
    cloudlimit: number | null
    store_discount: number | null
    game_discount: number | null
  }

  export type Subscription_TiersSumAggregateOutputType = {
    tierid: number | null
    price: number | null
    votepower: number | null
    cloudlimit: number | null
    store_discount: number | null
    game_discount: number | null
  }

  export type Subscription_TiersMinAggregateOutputType = {
    tierid: number | null
    name: string | null
    price: number | null
    votepower: number | null
    cloudlimit: number | null
    icon: string | null
    store_discount: number | null
    game_discount: number | null
    userid: string | null
  }

  export type Subscription_TiersMaxAggregateOutputType = {
    tierid: number | null
    name: string | null
    price: number | null
    votepower: number | null
    cloudlimit: number | null
    icon: string | null
    store_discount: number | null
    game_discount: number | null
    userid: string | null
  }

  export type Subscription_TiersCountAggregateOutputType = {
    tierid: number
    name: number
    price: number
    votepower: number
    cloudlimit: number
    icon: number
    store_discount: number
    game_discount: number
    permissions: number
    features: number
    userid: number
    _all: number
  }


  export type Subscription_TiersAvgAggregateInputType = {
    tierid?: true
    price?: true
    votepower?: true
    cloudlimit?: true
    store_discount?: true
    game_discount?: true
  }

  export type Subscription_TiersSumAggregateInputType = {
    tierid?: true
    price?: true
    votepower?: true
    cloudlimit?: true
    store_discount?: true
    game_discount?: true
  }

  export type Subscription_TiersMinAggregateInputType = {
    tierid?: true
    name?: true
    price?: true
    votepower?: true
    cloudlimit?: true
    icon?: true
    store_discount?: true
    game_discount?: true
    userid?: true
  }

  export type Subscription_TiersMaxAggregateInputType = {
    tierid?: true
    name?: true
    price?: true
    votepower?: true
    cloudlimit?: true
    icon?: true
    store_discount?: true
    game_discount?: true
    userid?: true
  }

  export type Subscription_TiersCountAggregateInputType = {
    tierid?: true
    name?: true
    price?: true
    votepower?: true
    cloudlimit?: true
    icon?: true
    store_discount?: true
    game_discount?: true
    permissions?: true
    features?: true
    userid?: true
    _all?: true
  }

  export type Subscription_TiersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription_Tiers to aggregate.
     */
    where?: Subscription_TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscription_Tiers to fetch.
     */
    orderBy?: Subscription_TiersOrderByWithRelationInput | Subscription_TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Subscription_TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscription_Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscription_Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscription_Tiers
    **/
    _count?: true | Subscription_TiersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subscription_TiersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subscription_TiersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subscription_TiersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subscription_TiersMaxAggregateInputType
  }

  export type GetSubscription_TiersAggregateType<T extends Subscription_TiersAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription_Tiers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription_Tiers[P]>
      : GetScalarType<T[P], AggregateSubscription_Tiers[P]>
  }




  export type Subscription_TiersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Subscription_TiersWhereInput
    orderBy?: Subscription_TiersOrderByWithAggregationInput | Subscription_TiersOrderByWithAggregationInput[]
    by: Subscription_TiersScalarFieldEnum[] | Subscription_TiersScalarFieldEnum
    having?: Subscription_TiersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subscription_TiersCountAggregateInputType | true
    _avg?: Subscription_TiersAvgAggregateInputType
    _sum?: Subscription_TiersSumAggregateInputType
    _min?: Subscription_TiersMinAggregateInputType
    _max?: Subscription_TiersMaxAggregateInputType
  }

  export type Subscription_TiersGroupByOutputType = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon: string | null
    store_discount: number
    game_discount: number
    permissions: $Enums.navItems[]
    features: string[]
    userid: string | null
    _count: Subscription_TiersCountAggregateOutputType | null
    _avg: Subscription_TiersAvgAggregateOutputType | null
    _sum: Subscription_TiersSumAggregateOutputType | null
    _min: Subscription_TiersMinAggregateOutputType | null
    _max: Subscription_TiersMaxAggregateOutputType | null
  }

  type GetSubscription_TiersGroupByPayload<T extends Subscription_TiersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Subscription_TiersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subscription_TiersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subscription_TiersGroupByOutputType[P]>
            : GetScalarType<T[P], Subscription_TiersGroupByOutputType[P]>
        }
      >
    >


  export type Subscription_TiersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tierid?: boolean
    name?: boolean
    price?: boolean
    votepower?: boolean
    cloudlimit?: boolean
    icon?: boolean
    store_discount?: boolean
    game_discount?: boolean
    permissions?: boolean
    features?: boolean
    userid?: boolean
    Users?: boolean | Subscription_Tiers$UsersArgs<ExtArgs>
    _count?: boolean | Subscription_TiersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription_Tiers"]>

  export type Subscription_TiersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tierid?: boolean
    name?: boolean
    price?: boolean
    votepower?: boolean
    cloudlimit?: boolean
    icon?: boolean
    store_discount?: boolean
    game_discount?: boolean
    permissions?: boolean
    features?: boolean
    userid?: boolean
  }, ExtArgs["result"]["subscription_Tiers"]>

  export type Subscription_TiersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tierid?: boolean
    name?: boolean
    price?: boolean
    votepower?: boolean
    cloudlimit?: boolean
    icon?: boolean
    store_discount?: boolean
    game_discount?: boolean
    permissions?: boolean
    features?: boolean
    userid?: boolean
  }, ExtArgs["result"]["subscription_Tiers"]>

  export type Subscription_TiersSelectScalar = {
    tierid?: boolean
    name?: boolean
    price?: boolean
    votepower?: boolean
    cloudlimit?: boolean
    icon?: boolean
    store_discount?: boolean
    game_discount?: boolean
    permissions?: boolean
    features?: boolean
    userid?: boolean
  }

  export type Subscription_TiersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tierid" | "name" | "price" | "votepower" | "cloudlimit" | "icon" | "store_discount" | "game_discount" | "permissions" | "features" | "userid", ExtArgs["result"]["subscription_Tiers"]>
  export type Subscription_TiersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Subscription_Tiers$UsersArgs<ExtArgs>
    _count?: boolean | Subscription_TiersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Subscription_TiersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type Subscription_TiersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $Subscription_TiersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription_Tiers"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tierid: number
      name: string
      price: number
      votepower: number
      cloudlimit: number
      icon: string | null
      store_discount: number
      game_discount: number
      permissions: $Enums.navItems[]
      features: string[]
      userid: string | null
    }, ExtArgs["result"]["subscription_Tiers"]>
    composites: {}
  }

  type Subscription_TiersGetPayload<S extends boolean | null | undefined | Subscription_TiersDefaultArgs> = $Result.GetResult<Prisma.$Subscription_TiersPayload, S>

  type Subscription_TiersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Subscription_TiersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Subscription_TiersCountAggregateInputType | true
    }

  export interface Subscription_TiersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription_Tiers'], meta: { name: 'Subscription_Tiers' } }
    /**
     * Find zero or one Subscription_Tiers that matches the filter.
     * @param {Subscription_TiersFindUniqueArgs} args - Arguments to find a Subscription_Tiers
     * @example
     * // Get one Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Subscription_TiersFindUniqueArgs>(args: SelectSubset<T, Subscription_TiersFindUniqueArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription_Tiers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Subscription_TiersFindUniqueOrThrowArgs} args - Arguments to find a Subscription_Tiers
     * @example
     * // Get one Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Subscription_TiersFindUniqueOrThrowArgs>(args: SelectSubset<T, Subscription_TiersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription_Tiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersFindFirstArgs} args - Arguments to find a Subscription_Tiers
     * @example
     * // Get one Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Subscription_TiersFindFirstArgs>(args?: SelectSubset<T, Subscription_TiersFindFirstArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription_Tiers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersFindFirstOrThrowArgs} args - Arguments to find a Subscription_Tiers
     * @example
     * // Get one Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Subscription_TiersFindFirstOrThrowArgs>(args?: SelectSubset<T, Subscription_TiersFindFirstOrThrowArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscription_Tiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findMany()
     * 
     * // Get first 10 Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.findMany({ take: 10 })
     * 
     * // Only select the `tierid`
     * const subscription_TiersWithTieridOnly = await prisma.subscription_Tiers.findMany({ select: { tierid: true } })
     * 
     */
    findMany<T extends Subscription_TiersFindManyArgs>(args?: SelectSubset<T, Subscription_TiersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription_Tiers.
     * @param {Subscription_TiersCreateArgs} args - Arguments to create a Subscription_Tiers.
     * @example
     * // Create one Subscription_Tiers
     * const Subscription_Tiers = await prisma.subscription_Tiers.create({
     *   data: {
     *     // ... data to create a Subscription_Tiers
     *   }
     * })
     * 
     */
    create<T extends Subscription_TiersCreateArgs>(args: SelectSubset<T, Subscription_TiersCreateArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscription_Tiers.
     * @param {Subscription_TiersCreateManyArgs} args - Arguments to create many Subscription_Tiers.
     * @example
     * // Create many Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Subscription_TiersCreateManyArgs>(args?: SelectSubset<T, Subscription_TiersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscription_Tiers and returns the data saved in the database.
     * @param {Subscription_TiersCreateManyAndReturnArgs} args - Arguments to create many Subscription_Tiers.
     * @example
     * // Create many Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscription_Tiers and only return the `tierid`
     * const subscription_TiersWithTieridOnly = await prisma.subscription_Tiers.createManyAndReturn({
     *   select: { tierid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Subscription_TiersCreateManyAndReturnArgs>(args?: SelectSubset<T, Subscription_TiersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription_Tiers.
     * @param {Subscription_TiersDeleteArgs} args - Arguments to delete one Subscription_Tiers.
     * @example
     * // Delete one Subscription_Tiers
     * const Subscription_Tiers = await prisma.subscription_Tiers.delete({
     *   where: {
     *     // ... filter to delete one Subscription_Tiers
     *   }
     * })
     * 
     */
    delete<T extends Subscription_TiersDeleteArgs>(args: SelectSubset<T, Subscription_TiersDeleteArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription_Tiers.
     * @param {Subscription_TiersUpdateArgs} args - Arguments to update one Subscription_Tiers.
     * @example
     * // Update one Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Subscription_TiersUpdateArgs>(args: SelectSubset<T, Subscription_TiersUpdateArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscription_Tiers.
     * @param {Subscription_TiersDeleteManyArgs} args - Arguments to filter Subscription_Tiers to delete.
     * @example
     * // Delete a few Subscription_Tiers
     * const { count } = await prisma.subscription_Tiers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Subscription_TiersDeleteManyArgs>(args?: SelectSubset<T, Subscription_TiersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscription_Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Subscription_TiersUpdateManyArgs>(args: SelectSubset<T, Subscription_TiersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscription_Tiers and returns the data updated in the database.
     * @param {Subscription_TiersUpdateManyAndReturnArgs} args - Arguments to update many Subscription_Tiers.
     * @example
     * // Update many Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscription_Tiers and only return the `tierid`
     * const subscription_TiersWithTieridOnly = await prisma.subscription_Tiers.updateManyAndReturn({
     *   select: { tierid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Subscription_TiersUpdateManyAndReturnArgs>(args: SelectSubset<T, Subscription_TiersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription_Tiers.
     * @param {Subscription_TiersUpsertArgs} args - Arguments to update or create a Subscription_Tiers.
     * @example
     * // Update or create a Subscription_Tiers
     * const subscription_Tiers = await prisma.subscription_Tiers.upsert({
     *   create: {
     *     // ... data to create a Subscription_Tiers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription_Tiers we want to update
     *   }
     * })
     */
    upsert<T extends Subscription_TiersUpsertArgs>(args: SelectSubset<T, Subscription_TiersUpsertArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscription_Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersCountArgs} args - Arguments to filter Subscription_Tiers to count.
     * @example
     * // Count the number of Subscription_Tiers
     * const count = await prisma.subscription_Tiers.count({
     *   where: {
     *     // ... the filter for the Subscription_Tiers we want to count
     *   }
     * })
    **/
    count<T extends Subscription_TiersCountArgs>(
      args?: Subset<T, Subscription_TiersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subscription_TiersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription_Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subscription_TiersAggregateArgs>(args: Subset<T, Subscription_TiersAggregateArgs>): Prisma.PrismaPromise<GetSubscription_TiersAggregateType<T>>

    /**
     * Group by Subscription_Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subscription_TiersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Subscription_TiersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Subscription_TiersGroupByArgs['orderBy'] }
        : { orderBy?: Subscription_TiersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Subscription_TiersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscription_TiersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription_Tiers model
   */
  readonly fields: Subscription_TiersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription_Tiers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Subscription_TiersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Subscription_Tiers$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Subscription_Tiers$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription_Tiers model
   */ 
  interface Subscription_TiersFieldRefs {
    readonly tierid: FieldRef<"Subscription_Tiers", 'Int'>
    readonly name: FieldRef<"Subscription_Tiers", 'String'>
    readonly price: FieldRef<"Subscription_Tiers", 'Int'>
    readonly votepower: FieldRef<"Subscription_Tiers", 'Int'>
    readonly cloudlimit: FieldRef<"Subscription_Tiers", 'Int'>
    readonly icon: FieldRef<"Subscription_Tiers", 'String'>
    readonly store_discount: FieldRef<"Subscription_Tiers", 'Int'>
    readonly game_discount: FieldRef<"Subscription_Tiers", 'Int'>
    readonly permissions: FieldRef<"Subscription_Tiers", 'navItems[]'>
    readonly features: FieldRef<"Subscription_Tiers", 'String[]'>
    readonly userid: FieldRef<"Subscription_Tiers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription_Tiers findUnique
   */
  export type Subscription_TiersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter, which Subscription_Tiers to fetch.
     */
    where: Subscription_TiersWhereUniqueInput
  }

  /**
   * Subscription_Tiers findUniqueOrThrow
   */
  export type Subscription_TiersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter, which Subscription_Tiers to fetch.
     */
    where: Subscription_TiersWhereUniqueInput
  }

  /**
   * Subscription_Tiers findFirst
   */
  export type Subscription_TiersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter, which Subscription_Tiers to fetch.
     */
    where?: Subscription_TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscription_Tiers to fetch.
     */
    orderBy?: Subscription_TiersOrderByWithRelationInput | Subscription_TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscription_Tiers.
     */
    cursor?: Subscription_TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscription_Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscription_Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscription_Tiers.
     */
    distinct?: Subscription_TiersScalarFieldEnum | Subscription_TiersScalarFieldEnum[]
  }

  /**
   * Subscription_Tiers findFirstOrThrow
   */
  export type Subscription_TiersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter, which Subscription_Tiers to fetch.
     */
    where?: Subscription_TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscription_Tiers to fetch.
     */
    orderBy?: Subscription_TiersOrderByWithRelationInput | Subscription_TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscription_Tiers.
     */
    cursor?: Subscription_TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscription_Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscription_Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscription_Tiers.
     */
    distinct?: Subscription_TiersScalarFieldEnum | Subscription_TiersScalarFieldEnum[]
  }

  /**
   * Subscription_Tiers findMany
   */
  export type Subscription_TiersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter, which Subscription_Tiers to fetch.
     */
    where?: Subscription_TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscription_Tiers to fetch.
     */
    orderBy?: Subscription_TiersOrderByWithRelationInput | Subscription_TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscription_Tiers.
     */
    cursor?: Subscription_TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscription_Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscription_Tiers.
     */
    skip?: number
    distinct?: Subscription_TiersScalarFieldEnum | Subscription_TiersScalarFieldEnum[]
  }

  /**
   * Subscription_Tiers create
   */
  export type Subscription_TiersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription_Tiers.
     */
    data: XOR<Subscription_TiersCreateInput, Subscription_TiersUncheckedCreateInput>
  }

  /**
   * Subscription_Tiers createMany
   */
  export type Subscription_TiersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscription_Tiers.
     */
    data: Subscription_TiersCreateManyInput | Subscription_TiersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription_Tiers createManyAndReturn
   */
  export type Subscription_TiersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * The data used to create many Subscription_Tiers.
     */
    data: Subscription_TiersCreateManyInput | Subscription_TiersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription_Tiers update
   */
  export type Subscription_TiersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription_Tiers.
     */
    data: XOR<Subscription_TiersUpdateInput, Subscription_TiersUncheckedUpdateInput>
    /**
     * Choose, which Subscription_Tiers to update.
     */
    where: Subscription_TiersWhereUniqueInput
  }

  /**
   * Subscription_Tiers updateMany
   */
  export type Subscription_TiersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscription_Tiers.
     */
    data: XOR<Subscription_TiersUpdateManyMutationInput, Subscription_TiersUncheckedUpdateManyInput>
    /**
     * Filter which Subscription_Tiers to update
     */
    where?: Subscription_TiersWhereInput
    /**
     * Limit how many Subscription_Tiers to update.
     */
    limit?: number
  }

  /**
   * Subscription_Tiers updateManyAndReturn
   */
  export type Subscription_TiersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * The data used to update Subscription_Tiers.
     */
    data: XOR<Subscription_TiersUpdateManyMutationInput, Subscription_TiersUncheckedUpdateManyInput>
    /**
     * Filter which Subscription_Tiers to update
     */
    where?: Subscription_TiersWhereInput
    /**
     * Limit how many Subscription_Tiers to update.
     */
    limit?: number
  }

  /**
   * Subscription_Tiers upsert
   */
  export type Subscription_TiersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription_Tiers to update in case it exists.
     */
    where: Subscription_TiersWhereUniqueInput
    /**
     * In case the Subscription_Tiers found by the `where` argument doesn't exist, create a new Subscription_Tiers with this data.
     */
    create: XOR<Subscription_TiersCreateInput, Subscription_TiersUncheckedCreateInput>
    /**
     * In case the Subscription_Tiers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Subscription_TiersUpdateInput, Subscription_TiersUncheckedUpdateInput>
  }

  /**
   * Subscription_Tiers delete
   */
  export type Subscription_TiersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    /**
     * Filter which Subscription_Tiers to delete.
     */
    where: Subscription_TiersWhereUniqueInput
  }

  /**
   * Subscription_Tiers deleteMany
   */
  export type Subscription_TiersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription_Tiers to delete
     */
    where?: Subscription_TiersWhereInput
    /**
     * Limit how many Subscription_Tiers to delete.
     */
    limit?: number
  }

  /**
   * Subscription_Tiers.Users
   */
  export type Subscription_Tiers$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Subscription_Tiers without action
   */
  export type Subscription_TiersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
  }


  /**
   * Model TitleTranslation
   */

  export type AggregateTitleTranslation = {
    _count: TitleTranslationCountAggregateOutputType | null
    _avg: TitleTranslationAvgAggregateOutputType | null
    _sum: TitleTranslationSumAggregateOutputType | null
    _min: TitleTranslationMinAggregateOutputType | null
    _max: TitleTranslationMaxAggregateOutputType | null
  }

  export type TitleTranslationAvgAggregateOutputType = {
    translationid: number | null
    parentid: number | null
  }

  export type TitleTranslationSumAggregateOutputType = {
    translationid: number | null
    parentid: number | null
  }

  export type TitleTranslationMinAggregateOutputType = {
    translationid: number | null
    parentid: number | null
    mediatype: $Enums.MediaType | null
    title: string | null
    language: string | null
  }

  export type TitleTranslationMaxAggregateOutputType = {
    translationid: number | null
    parentid: number | null
    mediatype: $Enums.MediaType | null
    title: string | null
    language: string | null
  }

  export type TitleTranslationCountAggregateOutputType = {
    translationid: number
    parentid: number
    mediatype: number
    title: number
    language: number
    _all: number
  }


  export type TitleTranslationAvgAggregateInputType = {
    translationid?: true
    parentid?: true
  }

  export type TitleTranslationSumAggregateInputType = {
    translationid?: true
    parentid?: true
  }

  export type TitleTranslationMinAggregateInputType = {
    translationid?: true
    parentid?: true
    mediatype?: true
    title?: true
    language?: true
  }

  export type TitleTranslationMaxAggregateInputType = {
    translationid?: true
    parentid?: true
    mediatype?: true
    title?: true
    language?: true
  }

  export type TitleTranslationCountAggregateInputType = {
    translationid?: true
    parentid?: true
    mediatype?: true
    title?: true
    language?: true
    _all?: true
  }

  export type TitleTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TitleTranslation to aggregate.
     */
    where?: TitleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleTranslations to fetch.
     */
    orderBy?: TitleTranslationOrderByWithRelationInput | TitleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TitleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TitleTranslations
    **/
    _count?: true | TitleTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TitleTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TitleTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TitleTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TitleTranslationMaxAggregateInputType
  }

  export type GetTitleTranslationAggregateType<T extends TitleTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTitleTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitleTranslation[P]>
      : GetScalarType<T[P], AggregateTitleTranslation[P]>
  }




  export type TitleTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TitleTranslationWhereInput
    orderBy?: TitleTranslationOrderByWithAggregationInput | TitleTranslationOrderByWithAggregationInput[]
    by: TitleTranslationScalarFieldEnum[] | TitleTranslationScalarFieldEnum
    having?: TitleTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TitleTranslationCountAggregateInputType | true
    _avg?: TitleTranslationAvgAggregateInputType
    _sum?: TitleTranslationSumAggregateInputType
    _min?: TitleTranslationMinAggregateInputType
    _max?: TitleTranslationMaxAggregateInputType
  }

  export type TitleTranslationGroupByOutputType = {
    translationid: number
    parentid: number
    mediatype: $Enums.MediaType
    title: string
    language: string
    _count: TitleTranslationCountAggregateOutputType | null
    _avg: TitleTranslationAvgAggregateOutputType | null
    _sum: TitleTranslationSumAggregateOutputType | null
    _min: TitleTranslationMinAggregateOutputType | null
    _max: TitleTranslationMaxAggregateOutputType | null
  }

  type GetTitleTranslationGroupByPayload<T extends TitleTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TitleTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TitleTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TitleTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TitleTranslationGroupByOutputType[P]>
        }
      >
    >


  export type TitleTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    translationid?: boolean
    parentid?: boolean
    mediatype?: boolean
    title?: boolean
    language?: boolean
  }, ExtArgs["result"]["titleTranslation"]>

  export type TitleTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    translationid?: boolean
    parentid?: boolean
    mediatype?: boolean
    title?: boolean
    language?: boolean
  }, ExtArgs["result"]["titleTranslation"]>

  export type TitleTranslationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    translationid?: boolean
    parentid?: boolean
    mediatype?: boolean
    title?: boolean
    language?: boolean
  }, ExtArgs["result"]["titleTranslation"]>

  export type TitleTranslationSelectScalar = {
    translationid?: boolean
    parentid?: boolean
    mediatype?: boolean
    title?: boolean
    language?: boolean
  }

  export type TitleTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"translationid" | "parentid" | "mediatype" | "title" | "language", ExtArgs["result"]["titleTranslation"]>

  export type $TitleTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TitleTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      translationid: number
      parentid: number
      mediatype: $Enums.MediaType
      title: string
      language: string
    }, ExtArgs["result"]["titleTranslation"]>
    composites: {}
  }

  type TitleTranslationGetPayload<S extends boolean | null | undefined | TitleTranslationDefaultArgs> = $Result.GetResult<Prisma.$TitleTranslationPayload, S>

  type TitleTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TitleTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TitleTranslationCountAggregateInputType | true
    }

  export interface TitleTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TitleTranslation'], meta: { name: 'TitleTranslation' } }
    /**
     * Find zero or one TitleTranslation that matches the filter.
     * @param {TitleTranslationFindUniqueArgs} args - Arguments to find a TitleTranslation
     * @example
     * // Get one TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TitleTranslationFindUniqueArgs>(args: SelectSubset<T, TitleTranslationFindUniqueArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TitleTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TitleTranslationFindUniqueOrThrowArgs} args - Arguments to find a TitleTranslation
     * @example
     * // Get one TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TitleTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TitleTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TitleTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationFindFirstArgs} args - Arguments to find a TitleTranslation
     * @example
     * // Get one TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TitleTranslationFindFirstArgs>(args?: SelectSubset<T, TitleTranslationFindFirstArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TitleTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationFindFirstOrThrowArgs} args - Arguments to find a TitleTranslation
     * @example
     * // Get one TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TitleTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TitleTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TitleTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TitleTranslations
     * const titleTranslations = await prisma.titleTranslation.findMany()
     * 
     * // Get first 10 TitleTranslations
     * const titleTranslations = await prisma.titleTranslation.findMany({ take: 10 })
     * 
     * // Only select the `translationid`
     * const titleTranslationWithTranslationidOnly = await prisma.titleTranslation.findMany({ select: { translationid: true } })
     * 
     */
    findMany<T extends TitleTranslationFindManyArgs>(args?: SelectSubset<T, TitleTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TitleTranslation.
     * @param {TitleTranslationCreateArgs} args - Arguments to create a TitleTranslation.
     * @example
     * // Create one TitleTranslation
     * const TitleTranslation = await prisma.titleTranslation.create({
     *   data: {
     *     // ... data to create a TitleTranslation
     *   }
     * })
     * 
     */
    create<T extends TitleTranslationCreateArgs>(args: SelectSubset<T, TitleTranslationCreateArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TitleTranslations.
     * @param {TitleTranslationCreateManyArgs} args - Arguments to create many TitleTranslations.
     * @example
     * // Create many TitleTranslations
     * const titleTranslation = await prisma.titleTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TitleTranslationCreateManyArgs>(args?: SelectSubset<T, TitleTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TitleTranslations and returns the data saved in the database.
     * @param {TitleTranslationCreateManyAndReturnArgs} args - Arguments to create many TitleTranslations.
     * @example
     * // Create many TitleTranslations
     * const titleTranslation = await prisma.titleTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TitleTranslations and only return the `translationid`
     * const titleTranslationWithTranslationidOnly = await prisma.titleTranslation.createManyAndReturn({
     *   select: { translationid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TitleTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TitleTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TitleTranslation.
     * @param {TitleTranslationDeleteArgs} args - Arguments to delete one TitleTranslation.
     * @example
     * // Delete one TitleTranslation
     * const TitleTranslation = await prisma.titleTranslation.delete({
     *   where: {
     *     // ... filter to delete one TitleTranslation
     *   }
     * })
     * 
     */
    delete<T extends TitleTranslationDeleteArgs>(args: SelectSubset<T, TitleTranslationDeleteArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TitleTranslation.
     * @param {TitleTranslationUpdateArgs} args - Arguments to update one TitleTranslation.
     * @example
     * // Update one TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TitleTranslationUpdateArgs>(args: SelectSubset<T, TitleTranslationUpdateArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TitleTranslations.
     * @param {TitleTranslationDeleteManyArgs} args - Arguments to filter TitleTranslations to delete.
     * @example
     * // Delete a few TitleTranslations
     * const { count } = await prisma.titleTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TitleTranslationDeleteManyArgs>(args?: SelectSubset<T, TitleTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TitleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TitleTranslations
     * const titleTranslation = await prisma.titleTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TitleTranslationUpdateManyArgs>(args: SelectSubset<T, TitleTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TitleTranslations and returns the data updated in the database.
     * @param {TitleTranslationUpdateManyAndReturnArgs} args - Arguments to update many TitleTranslations.
     * @example
     * // Update many TitleTranslations
     * const titleTranslation = await prisma.titleTranslation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TitleTranslations and only return the `translationid`
     * const titleTranslationWithTranslationidOnly = await prisma.titleTranslation.updateManyAndReturn({
     *   select: { translationid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TitleTranslationUpdateManyAndReturnArgs>(args: SelectSubset<T, TitleTranslationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TitleTranslation.
     * @param {TitleTranslationUpsertArgs} args - Arguments to update or create a TitleTranslation.
     * @example
     * // Update or create a TitleTranslation
     * const titleTranslation = await prisma.titleTranslation.upsert({
     *   create: {
     *     // ... data to create a TitleTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TitleTranslation we want to update
     *   }
     * })
     */
    upsert<T extends TitleTranslationUpsertArgs>(args: SelectSubset<T, TitleTranslationUpsertArgs<ExtArgs>>): Prisma__TitleTranslationClient<$Result.GetResult<Prisma.$TitleTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TitleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationCountArgs} args - Arguments to filter TitleTranslations to count.
     * @example
     * // Count the number of TitleTranslations
     * const count = await prisma.titleTranslation.count({
     *   where: {
     *     // ... the filter for the TitleTranslations we want to count
     *   }
     * })
    **/
    count<T extends TitleTranslationCountArgs>(
      args?: Subset<T, TitleTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TitleTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TitleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TitleTranslationAggregateArgs>(args: Subset<T, TitleTranslationAggregateArgs>): Prisma.PrismaPromise<GetTitleTranslationAggregateType<T>>

    /**
     * Group by TitleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitleTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TitleTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TitleTranslationGroupByArgs['orderBy'] }
        : { orderBy?: TitleTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TitleTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitleTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TitleTranslation model
   */
  readonly fields: TitleTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TitleTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TitleTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TitleTranslation model
   */ 
  interface TitleTranslationFieldRefs {
    readonly translationid: FieldRef<"TitleTranslation", 'Int'>
    readonly parentid: FieldRef<"TitleTranslation", 'Int'>
    readonly mediatype: FieldRef<"TitleTranslation", 'MediaType'>
    readonly title: FieldRef<"TitleTranslation", 'String'>
    readonly language: FieldRef<"TitleTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TitleTranslation findUnique
   */
  export type TitleTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TitleTranslation to fetch.
     */
    where: TitleTranslationWhereUniqueInput
  }

  /**
   * TitleTranslation findUniqueOrThrow
   */
  export type TitleTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TitleTranslation to fetch.
     */
    where: TitleTranslationWhereUniqueInput
  }

  /**
   * TitleTranslation findFirst
   */
  export type TitleTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TitleTranslation to fetch.
     */
    where?: TitleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleTranslations to fetch.
     */
    orderBy?: TitleTranslationOrderByWithRelationInput | TitleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleTranslations.
     */
    cursor?: TitleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleTranslations.
     */
    distinct?: TitleTranslationScalarFieldEnum | TitleTranslationScalarFieldEnum[]
  }

  /**
   * TitleTranslation findFirstOrThrow
   */
  export type TitleTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TitleTranslation to fetch.
     */
    where?: TitleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleTranslations to fetch.
     */
    orderBy?: TitleTranslationOrderByWithRelationInput | TitleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TitleTranslations.
     */
    cursor?: TitleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TitleTranslations.
     */
    distinct?: TitleTranslationScalarFieldEnum | TitleTranslationScalarFieldEnum[]
  }

  /**
   * TitleTranslation findMany
   */
  export type TitleTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TitleTranslations to fetch.
     */
    where?: TitleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TitleTranslations to fetch.
     */
    orderBy?: TitleTranslationOrderByWithRelationInput | TitleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TitleTranslations.
     */
    cursor?: TitleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TitleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TitleTranslations.
     */
    skip?: number
    distinct?: TitleTranslationScalarFieldEnum | TitleTranslationScalarFieldEnum[]
  }

  /**
   * TitleTranslation create
   */
  export type TitleTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a TitleTranslation.
     */
    data: XOR<TitleTranslationCreateInput, TitleTranslationUncheckedCreateInput>
  }

  /**
   * TitleTranslation createMany
   */
  export type TitleTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TitleTranslations.
     */
    data: TitleTranslationCreateManyInput | TitleTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TitleTranslation createManyAndReturn
   */
  export type TitleTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * The data used to create many TitleTranslations.
     */
    data: TitleTranslationCreateManyInput | TitleTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TitleTranslation update
   */
  export type TitleTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a TitleTranslation.
     */
    data: XOR<TitleTranslationUpdateInput, TitleTranslationUncheckedUpdateInput>
    /**
     * Choose, which TitleTranslation to update.
     */
    where: TitleTranslationWhereUniqueInput
  }

  /**
   * TitleTranslation updateMany
   */
  export type TitleTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TitleTranslations.
     */
    data: XOR<TitleTranslationUpdateManyMutationInput, TitleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TitleTranslations to update
     */
    where?: TitleTranslationWhereInput
    /**
     * Limit how many TitleTranslations to update.
     */
    limit?: number
  }

  /**
   * TitleTranslation updateManyAndReturn
   */
  export type TitleTranslationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * The data used to update TitleTranslations.
     */
    data: XOR<TitleTranslationUpdateManyMutationInput, TitleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TitleTranslations to update
     */
    where?: TitleTranslationWhereInput
    /**
     * Limit how many TitleTranslations to update.
     */
    limit?: number
  }

  /**
   * TitleTranslation upsert
   */
  export type TitleTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the TitleTranslation to update in case it exists.
     */
    where: TitleTranslationWhereUniqueInput
    /**
     * In case the TitleTranslation found by the `where` argument doesn't exist, create a new TitleTranslation with this data.
     */
    create: XOR<TitleTranslationCreateInput, TitleTranslationUncheckedCreateInput>
    /**
     * In case the TitleTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TitleTranslationUpdateInput, TitleTranslationUncheckedUpdateInput>
  }

  /**
   * TitleTranslation delete
   */
  export type TitleTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
    /**
     * Filter which TitleTranslation to delete.
     */
    where: TitleTranslationWhereUniqueInput
  }

  /**
   * TitleTranslation deleteMany
   */
  export type TitleTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TitleTranslations to delete
     */
    where?: TitleTranslationWhereInput
    /**
     * Limit how many TitleTranslations to delete.
     */
    limit?: number
  }

  /**
   * TitleTranslation without action
   */
  export type TitleTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TitleTranslation
     */
    select?: TitleTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TitleTranslation
     */
    omit?: TitleTranslationOmit<ExtArgs> | null
  }


  /**
   * Model User_Activity
   */

  export type AggregateUser_Activity = {
    _count: User_ActivityCountAggregateOutputType | null
    _avg: User_ActivityAvgAggregateOutputType | null
    _sum: User_ActivitySumAggregateOutputType | null
    _min: User_ActivityMinAggregateOutputType | null
    _max: User_ActivityMaxAggregateOutputType | null
  }

  export type User_ActivityAvgAggregateOutputType = {
    stopping_point: number | null
  }

  export type User_ActivitySumAggregateOutputType = {
    stopping_point: number | null
  }

  export type User_ActivityMinAggregateOutputType = {
    userid: string | null
    child_content: string | null
    parent_content: string | null
    mediatype: $Enums.MediaType | null
    stopping_point: number | null
    date_watched: Date | null
  }

  export type User_ActivityMaxAggregateOutputType = {
    userid: string | null
    child_content: string | null
    parent_content: string | null
    mediatype: $Enums.MediaType | null
    stopping_point: number | null
    date_watched: Date | null
  }

  export type User_ActivityCountAggregateOutputType = {
    userid: number
    child_content: number
    parent_content: number
    mediatype: number
    stopping_point: number
    date_watched: number
    _all: number
  }


  export type User_ActivityAvgAggregateInputType = {
    stopping_point?: true
  }

  export type User_ActivitySumAggregateInputType = {
    stopping_point?: true
  }

  export type User_ActivityMinAggregateInputType = {
    userid?: true
    child_content?: true
    parent_content?: true
    mediatype?: true
    stopping_point?: true
    date_watched?: true
  }

  export type User_ActivityMaxAggregateInputType = {
    userid?: true
    child_content?: true
    parent_content?: true
    mediatype?: true
    stopping_point?: true
    date_watched?: true
  }

  export type User_ActivityCountAggregateInputType = {
    userid?: true
    child_content?: true
    parent_content?: true
    mediatype?: true
    stopping_point?: true
    date_watched?: true
    _all?: true
  }

  export type User_ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Activity to aggregate.
     */
    where?: User_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Activities to fetch.
     */
    orderBy?: User_ActivityOrderByWithRelationInput | User_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Activities
    **/
    _count?: true | User_ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_ActivityMaxAggregateInputType
  }

  export type GetUser_ActivityAggregateType<T extends User_ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Activity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Activity[P]>
      : GetScalarType<T[P], AggregateUser_Activity[P]>
  }




  export type User_ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_ActivityWhereInput
    orderBy?: User_ActivityOrderByWithAggregationInput | User_ActivityOrderByWithAggregationInput[]
    by: User_ActivityScalarFieldEnum[] | User_ActivityScalarFieldEnum
    having?: User_ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_ActivityCountAggregateInputType | true
    _avg?: User_ActivityAvgAggregateInputType
    _sum?: User_ActivitySumAggregateInputType
    _min?: User_ActivityMinAggregateInputType
    _max?: User_ActivityMaxAggregateInputType
  }

  export type User_ActivityGroupByOutputType = {
    userid: string
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched: Date
    _count: User_ActivityCountAggregateOutputType | null
    _avg: User_ActivityAvgAggregateOutputType | null
    _sum: User_ActivitySumAggregateOutputType | null
    _min: User_ActivityMinAggregateOutputType | null
    _max: User_ActivityMaxAggregateOutputType | null
  }

  type GetUser_ActivityGroupByPayload<T extends User_ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], User_ActivityGroupByOutputType[P]>
        }
      >
    >


  export type User_ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    child_content?: boolean
    parent_content?: boolean
    mediatype?: boolean
    stopping_point?: boolean
    date_watched?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Activity"]>

  export type User_ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    child_content?: boolean
    parent_content?: boolean
    mediatype?: boolean
    stopping_point?: boolean
    date_watched?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Activity"]>

  export type User_ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    child_content?: boolean
    parent_content?: boolean
    mediatype?: boolean
    stopping_point?: boolean
    date_watched?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Activity"]>

  export type User_ActivitySelectScalar = {
    userid?: boolean
    child_content?: boolean
    parent_content?: boolean
    mediatype?: boolean
    stopping_point?: boolean
    date_watched?: boolean
  }

  export type User_ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "child_content" | "parent_content" | "mediatype" | "stopping_point" | "date_watched", ExtArgs["result"]["user_Activity"]>
  export type User_ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $User_ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User_Activity"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      child_content: string
      parent_content: string
      mediatype: $Enums.MediaType
      stopping_point: number
      date_watched: Date
    }, ExtArgs["result"]["user_Activity"]>
    composites: {}
  }

  type User_ActivityGetPayload<S extends boolean | null | undefined | User_ActivityDefaultArgs> = $Result.GetResult<Prisma.$User_ActivityPayload, S>

  type User_ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<User_ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_ActivityCountAggregateInputType | true
    }

  export interface User_ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User_Activity'], meta: { name: 'User_Activity' } }
    /**
     * Find zero or one User_Activity that matches the filter.
     * @param {User_ActivityFindUniqueArgs} args - Arguments to find a User_Activity
     * @example
     * // Get one User_Activity
     * const user_Activity = await prisma.user_Activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends User_ActivityFindUniqueArgs>(args: SelectSubset<T, User_ActivityFindUniqueArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {User_ActivityFindUniqueOrThrowArgs} args - Arguments to find a User_Activity
     * @example
     * // Get one User_Activity
     * const user_Activity = await prisma.user_Activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends User_ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, User_ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityFindFirstArgs} args - Arguments to find a User_Activity
     * @example
     * // Get one User_Activity
     * const user_Activity = await prisma.user_Activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends User_ActivityFindFirstArgs>(args?: SelectSubset<T, User_ActivityFindFirstArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityFindFirstOrThrowArgs} args - Arguments to find a User_Activity
     * @example
     * // Get one User_Activity
     * const user_Activity = await prisma.user_Activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends User_ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, User_ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Activities
     * const user_Activities = await prisma.user_Activity.findMany()
     * 
     * // Get first 10 User_Activities
     * const user_Activities = await prisma.user_Activity.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const user_ActivityWithUseridOnly = await prisma.user_Activity.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends User_ActivityFindManyArgs>(args?: SelectSubset<T, User_ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_Activity.
     * @param {User_ActivityCreateArgs} args - Arguments to create a User_Activity.
     * @example
     * // Create one User_Activity
     * const User_Activity = await prisma.user_Activity.create({
     *   data: {
     *     // ... data to create a User_Activity
     *   }
     * })
     * 
     */
    create<T extends User_ActivityCreateArgs>(args: SelectSubset<T, User_ActivityCreateArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_Activities.
     * @param {User_ActivityCreateManyArgs} args - Arguments to create many User_Activities.
     * @example
     * // Create many User_Activities
     * const user_Activity = await prisma.user_Activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends User_ActivityCreateManyArgs>(args?: SelectSubset<T, User_ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_Activities and returns the data saved in the database.
     * @param {User_ActivityCreateManyAndReturnArgs} args - Arguments to create many User_Activities.
     * @example
     * // Create many User_Activities
     * const user_Activity = await prisma.user_Activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_Activities and only return the `userid`
     * const user_ActivityWithUseridOnly = await prisma.user_Activity.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends User_ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, User_ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_Activity.
     * @param {User_ActivityDeleteArgs} args - Arguments to delete one User_Activity.
     * @example
     * // Delete one User_Activity
     * const User_Activity = await prisma.user_Activity.delete({
     *   where: {
     *     // ... filter to delete one User_Activity
     *   }
     * })
     * 
     */
    delete<T extends User_ActivityDeleteArgs>(args: SelectSubset<T, User_ActivityDeleteArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_Activity.
     * @param {User_ActivityUpdateArgs} args - Arguments to update one User_Activity.
     * @example
     * // Update one User_Activity
     * const user_Activity = await prisma.user_Activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends User_ActivityUpdateArgs>(args: SelectSubset<T, User_ActivityUpdateArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_Activities.
     * @param {User_ActivityDeleteManyArgs} args - Arguments to filter User_Activities to delete.
     * @example
     * // Delete a few User_Activities
     * const { count } = await prisma.user_Activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends User_ActivityDeleteManyArgs>(args?: SelectSubset<T, User_ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Activities
     * const user_Activity = await prisma.user_Activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends User_ActivityUpdateManyArgs>(args: SelectSubset<T, User_ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Activities and returns the data updated in the database.
     * @param {User_ActivityUpdateManyAndReturnArgs} args - Arguments to update many User_Activities.
     * @example
     * // Update many User_Activities
     * const user_Activity = await prisma.user_Activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_Activities and only return the `userid`
     * const user_ActivityWithUseridOnly = await prisma.user_Activity.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends User_ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, User_ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_Activity.
     * @param {User_ActivityUpsertArgs} args - Arguments to update or create a User_Activity.
     * @example
     * // Update or create a User_Activity
     * const user_Activity = await prisma.user_Activity.upsert({
     *   create: {
     *     // ... data to create a User_Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Activity we want to update
     *   }
     * })
     */
    upsert<T extends User_ActivityUpsertArgs>(args: SelectSubset<T, User_ActivityUpsertArgs<ExtArgs>>): Prisma__User_ActivityClient<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityCountArgs} args - Arguments to filter User_Activities to count.
     * @example
     * // Count the number of User_Activities
     * const count = await prisma.user_Activity.count({
     *   where: {
     *     // ... the filter for the User_Activities we want to count
     *   }
     * })
    **/
    count<T extends User_ActivityCountArgs>(
      args?: Subset<T, User_ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_ActivityAggregateArgs>(args: Subset<T, User_ActivityAggregateArgs>): Prisma.PrismaPromise<GetUser_ActivityAggregateType<T>>

    /**
     * Group by User_Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_ActivityGroupByArgs['orderBy'] }
        : { orderBy?: User_ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_ActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User_Activity model
   */
  readonly fields: User_ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__User_ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User_Activity model
   */ 
  interface User_ActivityFieldRefs {
    readonly userid: FieldRef<"User_Activity", 'String'>
    readonly child_content: FieldRef<"User_Activity", 'String'>
    readonly parent_content: FieldRef<"User_Activity", 'String'>
    readonly mediatype: FieldRef<"User_Activity", 'MediaType'>
    readonly stopping_point: FieldRef<"User_Activity", 'Int'>
    readonly date_watched: FieldRef<"User_Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User_Activity findUnique
   */
  export type User_ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter, which User_Activity to fetch.
     */
    where: User_ActivityWhereUniqueInput
  }

  /**
   * User_Activity findUniqueOrThrow
   */
  export type User_ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter, which User_Activity to fetch.
     */
    where: User_ActivityWhereUniqueInput
  }

  /**
   * User_Activity findFirst
   */
  export type User_ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter, which User_Activity to fetch.
     */
    where?: User_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Activities to fetch.
     */
    orderBy?: User_ActivityOrderByWithRelationInput | User_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Activities.
     */
    cursor?: User_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Activities.
     */
    distinct?: User_ActivityScalarFieldEnum | User_ActivityScalarFieldEnum[]
  }

  /**
   * User_Activity findFirstOrThrow
   */
  export type User_ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter, which User_Activity to fetch.
     */
    where?: User_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Activities to fetch.
     */
    orderBy?: User_ActivityOrderByWithRelationInput | User_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Activities.
     */
    cursor?: User_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Activities.
     */
    distinct?: User_ActivityScalarFieldEnum | User_ActivityScalarFieldEnum[]
  }

  /**
   * User_Activity findMany
   */
  export type User_ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter, which User_Activities to fetch.
     */
    where?: User_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Activities to fetch.
     */
    orderBy?: User_ActivityOrderByWithRelationInput | User_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Activities.
     */
    cursor?: User_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Activities.
     */
    skip?: number
    distinct?: User_ActivityScalarFieldEnum | User_ActivityScalarFieldEnum[]
  }

  /**
   * User_Activity create
   */
  export type User_ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a User_Activity.
     */
    data: XOR<User_ActivityCreateInput, User_ActivityUncheckedCreateInput>
  }

  /**
   * User_Activity createMany
   */
  export type User_ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many User_Activities.
     */
    data: User_ActivityCreateManyInput | User_ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User_Activity createManyAndReturn
   */
  export type User_ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many User_Activities.
     */
    data: User_ActivityCreateManyInput | User_ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Activity update
   */
  export type User_ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a User_Activity.
     */
    data: XOR<User_ActivityUpdateInput, User_ActivityUncheckedUpdateInput>
    /**
     * Choose, which User_Activity to update.
     */
    where: User_ActivityWhereUniqueInput
  }

  /**
   * User_Activity updateMany
   */
  export type User_ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update User_Activities.
     */
    data: XOR<User_ActivityUpdateManyMutationInput, User_ActivityUncheckedUpdateManyInput>
    /**
     * Filter which User_Activities to update
     */
    where?: User_ActivityWhereInput
    /**
     * Limit how many User_Activities to update.
     */
    limit?: number
  }

  /**
   * User_Activity updateManyAndReturn
   */
  export type User_ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * The data used to update User_Activities.
     */
    data: XOR<User_ActivityUpdateManyMutationInput, User_ActivityUncheckedUpdateManyInput>
    /**
     * Filter which User_Activities to update
     */
    where?: User_ActivityWhereInput
    /**
     * Limit how many User_Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Activity upsert
   */
  export type User_ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the User_Activity to update in case it exists.
     */
    where: User_ActivityWhereUniqueInput
    /**
     * In case the User_Activity found by the `where` argument doesn't exist, create a new User_Activity with this data.
     */
    create: XOR<User_ActivityCreateInput, User_ActivityUncheckedCreateInput>
    /**
     * In case the User_Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_ActivityUpdateInput, User_ActivityUncheckedUpdateInput>
  }

  /**
   * User_Activity delete
   */
  export type User_ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    /**
     * Filter which User_Activity to delete.
     */
    where: User_ActivityWhereUniqueInput
  }

  /**
   * User_Activity deleteMany
   */
  export type User_ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Activities to delete
     */
    where?: User_ActivityWhereInput
    /**
     * Limit how many User_Activities to delete.
     */
    limit?: number
  }

  /**
   * User_Activity without action
   */
  export type User_ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
  }


  /**
   * Model User_Bookmarks
   */

  export type AggregateUser_Bookmarks = {
    _count: User_BookmarksCountAggregateOutputType | null
    _min: User_BookmarksMinAggregateOutputType | null
    _max: User_BookmarksMaxAggregateOutputType | null
  }

  export type User_BookmarksMinAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    parentid: string | null
  }

  export type User_BookmarksMaxAggregateOutputType = {
    userid: string | null
    mediatype: $Enums.MediaType | null
    parentid: string | null
  }

  export type User_BookmarksCountAggregateOutputType = {
    userid: number
    mediatype: number
    parentid: number
    _all: number
  }


  export type User_BookmarksMinAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
  }

  export type User_BookmarksMaxAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
  }

  export type User_BookmarksCountAggregateInputType = {
    userid?: true
    mediatype?: true
    parentid?: true
    _all?: true
  }

  export type User_BookmarksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Bookmarks to aggregate.
     */
    where?: User_BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Bookmarks to fetch.
     */
    orderBy?: User_BookmarksOrderByWithRelationInput | User_BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Bookmarks
    **/
    _count?: true | User_BookmarksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_BookmarksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_BookmarksMaxAggregateInputType
  }

  export type GetUser_BookmarksAggregateType<T extends User_BookmarksAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Bookmarks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Bookmarks[P]>
      : GetScalarType<T[P], AggregateUser_Bookmarks[P]>
  }




  export type User_BookmarksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_BookmarksWhereInput
    orderBy?: User_BookmarksOrderByWithAggregationInput | User_BookmarksOrderByWithAggregationInput[]
    by: User_BookmarksScalarFieldEnum[] | User_BookmarksScalarFieldEnum
    having?: User_BookmarksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_BookmarksCountAggregateInputType | true
    _min?: User_BookmarksMinAggregateInputType
    _max?: User_BookmarksMaxAggregateInputType
  }

  export type User_BookmarksGroupByOutputType = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
    _count: User_BookmarksCountAggregateOutputType | null
    _min: User_BookmarksMinAggregateOutputType | null
    _max: User_BookmarksMaxAggregateOutputType | null
  }

  type GetUser_BookmarksGroupByPayload<T extends User_BookmarksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_BookmarksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_BookmarksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_BookmarksGroupByOutputType[P]>
            : GetScalarType<T[P], User_BookmarksGroupByOutputType[P]>
        }
      >
    >


  export type User_BookmarksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Bookmarks"]>

  export type User_BookmarksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Bookmarks"]>

  export type User_BookmarksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Bookmarks"]>

  export type User_BookmarksSelectScalar = {
    userid?: boolean
    mediatype?: boolean
    parentid?: boolean
  }

  export type User_BookmarksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "mediatype" | "parentid", ExtArgs["result"]["user_Bookmarks"]>
  export type User_BookmarksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_BookmarksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_BookmarksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $User_BookmarksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User_Bookmarks"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      mediatype: $Enums.MediaType
      parentid: string
    }, ExtArgs["result"]["user_Bookmarks"]>
    composites: {}
  }

  type User_BookmarksGetPayload<S extends boolean | null | undefined | User_BookmarksDefaultArgs> = $Result.GetResult<Prisma.$User_BookmarksPayload, S>

  type User_BookmarksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<User_BookmarksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_BookmarksCountAggregateInputType | true
    }

  export interface User_BookmarksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User_Bookmarks'], meta: { name: 'User_Bookmarks' } }
    /**
     * Find zero or one User_Bookmarks that matches the filter.
     * @param {User_BookmarksFindUniqueArgs} args - Arguments to find a User_Bookmarks
     * @example
     * // Get one User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends User_BookmarksFindUniqueArgs>(args: SelectSubset<T, User_BookmarksFindUniqueArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_Bookmarks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {User_BookmarksFindUniqueOrThrowArgs} args - Arguments to find a User_Bookmarks
     * @example
     * // Get one User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends User_BookmarksFindUniqueOrThrowArgs>(args: SelectSubset<T, User_BookmarksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksFindFirstArgs} args - Arguments to find a User_Bookmarks
     * @example
     * // Get one User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends User_BookmarksFindFirstArgs>(args?: SelectSubset<T, User_BookmarksFindFirstArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Bookmarks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksFindFirstOrThrowArgs} args - Arguments to find a User_Bookmarks
     * @example
     * // Get one User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends User_BookmarksFindFirstOrThrowArgs>(args?: SelectSubset<T, User_BookmarksFindFirstOrThrowArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findMany()
     * 
     * // Get first 10 User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const user_BookmarksWithUseridOnly = await prisma.user_Bookmarks.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends User_BookmarksFindManyArgs>(args?: SelectSubset<T, User_BookmarksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_Bookmarks.
     * @param {User_BookmarksCreateArgs} args - Arguments to create a User_Bookmarks.
     * @example
     * // Create one User_Bookmarks
     * const User_Bookmarks = await prisma.user_Bookmarks.create({
     *   data: {
     *     // ... data to create a User_Bookmarks
     *   }
     * })
     * 
     */
    create<T extends User_BookmarksCreateArgs>(args: SelectSubset<T, User_BookmarksCreateArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_Bookmarks.
     * @param {User_BookmarksCreateManyArgs} args - Arguments to create many User_Bookmarks.
     * @example
     * // Create many User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends User_BookmarksCreateManyArgs>(args?: SelectSubset<T, User_BookmarksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_Bookmarks and returns the data saved in the database.
     * @param {User_BookmarksCreateManyAndReturnArgs} args - Arguments to create many User_Bookmarks.
     * @example
     * // Create many User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_Bookmarks and only return the `userid`
     * const user_BookmarksWithUseridOnly = await prisma.user_Bookmarks.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends User_BookmarksCreateManyAndReturnArgs>(args?: SelectSubset<T, User_BookmarksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_Bookmarks.
     * @param {User_BookmarksDeleteArgs} args - Arguments to delete one User_Bookmarks.
     * @example
     * // Delete one User_Bookmarks
     * const User_Bookmarks = await prisma.user_Bookmarks.delete({
     *   where: {
     *     // ... filter to delete one User_Bookmarks
     *   }
     * })
     * 
     */
    delete<T extends User_BookmarksDeleteArgs>(args: SelectSubset<T, User_BookmarksDeleteArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_Bookmarks.
     * @param {User_BookmarksUpdateArgs} args - Arguments to update one User_Bookmarks.
     * @example
     * // Update one User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends User_BookmarksUpdateArgs>(args: SelectSubset<T, User_BookmarksUpdateArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_Bookmarks.
     * @param {User_BookmarksDeleteManyArgs} args - Arguments to filter User_Bookmarks to delete.
     * @example
     * // Delete a few User_Bookmarks
     * const { count } = await prisma.user_Bookmarks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends User_BookmarksDeleteManyArgs>(args?: SelectSubset<T, User_BookmarksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends User_BookmarksUpdateManyArgs>(args: SelectSubset<T, User_BookmarksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Bookmarks and returns the data updated in the database.
     * @param {User_BookmarksUpdateManyAndReturnArgs} args - Arguments to update many User_Bookmarks.
     * @example
     * // Update many User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_Bookmarks and only return the `userid`
     * const user_BookmarksWithUseridOnly = await prisma.user_Bookmarks.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends User_BookmarksUpdateManyAndReturnArgs>(args: SelectSubset<T, User_BookmarksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_Bookmarks.
     * @param {User_BookmarksUpsertArgs} args - Arguments to update or create a User_Bookmarks.
     * @example
     * // Update or create a User_Bookmarks
     * const user_Bookmarks = await prisma.user_Bookmarks.upsert({
     *   create: {
     *     // ... data to create a User_Bookmarks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Bookmarks we want to update
     *   }
     * })
     */
    upsert<T extends User_BookmarksUpsertArgs>(args: SelectSubset<T, User_BookmarksUpsertArgs<ExtArgs>>): Prisma__User_BookmarksClient<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksCountArgs} args - Arguments to filter User_Bookmarks to count.
     * @example
     * // Count the number of User_Bookmarks
     * const count = await prisma.user_Bookmarks.count({
     *   where: {
     *     // ... the filter for the User_Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends User_BookmarksCountArgs>(
      args?: Subset<T, User_BookmarksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_BookmarksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_BookmarksAggregateArgs>(args: Subset<T, User_BookmarksAggregateArgs>): Prisma.PrismaPromise<GetUser_BookmarksAggregateType<T>>

    /**
     * Group by User_Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BookmarksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_BookmarksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_BookmarksGroupByArgs['orderBy'] }
        : { orderBy?: User_BookmarksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_BookmarksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_BookmarksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User_Bookmarks model
   */
  readonly fields: User_BookmarksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Bookmarks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__User_BookmarksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User_Bookmarks model
   */ 
  interface User_BookmarksFieldRefs {
    readonly userid: FieldRef<"User_Bookmarks", 'String'>
    readonly mediatype: FieldRef<"User_Bookmarks", 'MediaType'>
    readonly parentid: FieldRef<"User_Bookmarks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User_Bookmarks findUnique
   */
  export type User_BookmarksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which User_Bookmarks to fetch.
     */
    where: User_BookmarksWhereUniqueInput
  }

  /**
   * User_Bookmarks findUniqueOrThrow
   */
  export type User_BookmarksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which User_Bookmarks to fetch.
     */
    where: User_BookmarksWhereUniqueInput
  }

  /**
   * User_Bookmarks findFirst
   */
  export type User_BookmarksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which User_Bookmarks to fetch.
     */
    where?: User_BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Bookmarks to fetch.
     */
    orderBy?: User_BookmarksOrderByWithRelationInput | User_BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Bookmarks.
     */
    cursor?: User_BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Bookmarks.
     */
    distinct?: User_BookmarksScalarFieldEnum | User_BookmarksScalarFieldEnum[]
  }

  /**
   * User_Bookmarks findFirstOrThrow
   */
  export type User_BookmarksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which User_Bookmarks to fetch.
     */
    where?: User_BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Bookmarks to fetch.
     */
    orderBy?: User_BookmarksOrderByWithRelationInput | User_BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Bookmarks.
     */
    cursor?: User_BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Bookmarks.
     */
    distinct?: User_BookmarksScalarFieldEnum | User_BookmarksScalarFieldEnum[]
  }

  /**
   * User_Bookmarks findMany
   */
  export type User_BookmarksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter, which User_Bookmarks to fetch.
     */
    where?: User_BookmarksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Bookmarks to fetch.
     */
    orderBy?: User_BookmarksOrderByWithRelationInput | User_BookmarksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Bookmarks.
     */
    cursor?: User_BookmarksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Bookmarks.
     */
    skip?: number
    distinct?: User_BookmarksScalarFieldEnum | User_BookmarksScalarFieldEnum[]
  }

  /**
   * User_Bookmarks create
   */
  export type User_BookmarksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * The data needed to create a User_Bookmarks.
     */
    data: XOR<User_BookmarksCreateInput, User_BookmarksUncheckedCreateInput>
  }

  /**
   * User_Bookmarks createMany
   */
  export type User_BookmarksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many User_Bookmarks.
     */
    data: User_BookmarksCreateManyInput | User_BookmarksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User_Bookmarks createManyAndReturn
   */
  export type User_BookmarksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * The data used to create many User_Bookmarks.
     */
    data: User_BookmarksCreateManyInput | User_BookmarksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Bookmarks update
   */
  export type User_BookmarksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * The data needed to update a User_Bookmarks.
     */
    data: XOR<User_BookmarksUpdateInput, User_BookmarksUncheckedUpdateInput>
    /**
     * Choose, which User_Bookmarks to update.
     */
    where: User_BookmarksWhereUniqueInput
  }

  /**
   * User_Bookmarks updateMany
   */
  export type User_BookmarksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update User_Bookmarks.
     */
    data: XOR<User_BookmarksUpdateManyMutationInput, User_BookmarksUncheckedUpdateManyInput>
    /**
     * Filter which User_Bookmarks to update
     */
    where?: User_BookmarksWhereInput
    /**
     * Limit how many User_Bookmarks to update.
     */
    limit?: number
  }

  /**
   * User_Bookmarks updateManyAndReturn
   */
  export type User_BookmarksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * The data used to update User_Bookmarks.
     */
    data: XOR<User_BookmarksUpdateManyMutationInput, User_BookmarksUncheckedUpdateManyInput>
    /**
     * Filter which User_Bookmarks to update
     */
    where?: User_BookmarksWhereInput
    /**
     * Limit how many User_Bookmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Bookmarks upsert
   */
  export type User_BookmarksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * The filter to search for the User_Bookmarks to update in case it exists.
     */
    where: User_BookmarksWhereUniqueInput
    /**
     * In case the User_Bookmarks found by the `where` argument doesn't exist, create a new User_Bookmarks with this data.
     */
    create: XOR<User_BookmarksCreateInput, User_BookmarksUncheckedCreateInput>
    /**
     * In case the User_Bookmarks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_BookmarksUpdateInput, User_BookmarksUncheckedUpdateInput>
  }

  /**
   * User_Bookmarks delete
   */
  export type User_BookmarksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    /**
     * Filter which User_Bookmarks to delete.
     */
    where: User_BookmarksWhereUniqueInput
  }

  /**
   * User_Bookmarks deleteMany
   */
  export type User_BookmarksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Bookmarks to delete
     */
    where?: User_BookmarksWhereInput
    /**
     * Limit how many User_Bookmarks to delete.
     */
    limit?: number
  }

  /**
   * User_Bookmarks without action
   */
  export type User_BookmarksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
  }


  /**
   * Model User_Ratings
   */

  export type AggregateUser_Ratings = {
    _count: User_RatingsCountAggregateOutputType | null
    _avg: User_RatingsAvgAggregateOutputType | null
    _sum: User_RatingsSumAggregateOutputType | null
    _min: User_RatingsMinAggregateOutputType | null
    _max: User_RatingsMaxAggregateOutputType | null
  }

  export type User_RatingsAvgAggregateOutputType = {
    rating: number | null
  }

  export type User_RatingsSumAggregateOutputType = {
    rating: number | null
  }

  export type User_RatingsMinAggregateOutputType = {
    userid: string | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    rating: number | null
  }

  export type User_RatingsMaxAggregateOutputType = {
    userid: string | null
    parentid: string | null
    mediatype: $Enums.MediaType | null
    rating: number | null
  }

  export type User_RatingsCountAggregateOutputType = {
    userid: number
    parentid: number
    mediatype: number
    rating: number
    _all: number
  }


  export type User_RatingsAvgAggregateInputType = {
    rating?: true
  }

  export type User_RatingsSumAggregateInputType = {
    rating?: true
  }

  export type User_RatingsMinAggregateInputType = {
    userid?: true
    parentid?: true
    mediatype?: true
    rating?: true
  }

  export type User_RatingsMaxAggregateInputType = {
    userid?: true
    parentid?: true
    mediatype?: true
    rating?: true
  }

  export type User_RatingsCountAggregateInputType = {
    userid?: true
    parentid?: true
    mediatype?: true
    rating?: true
    _all?: true
  }

  export type User_RatingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Ratings to aggregate.
     */
    where?: User_RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Ratings to fetch.
     */
    orderBy?: User_RatingsOrderByWithRelationInput | User_RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Ratings
    **/
    _count?: true | User_RatingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_RatingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_RatingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_RatingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_RatingsMaxAggregateInputType
  }

  export type GetUser_RatingsAggregateType<T extends User_RatingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Ratings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Ratings[P]>
      : GetScalarType<T[P], AggregateUser_Ratings[P]>
  }




  export type User_RatingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_RatingsWhereInput
    orderBy?: User_RatingsOrderByWithAggregationInput | User_RatingsOrderByWithAggregationInput[]
    by: User_RatingsScalarFieldEnum[] | User_RatingsScalarFieldEnum
    having?: User_RatingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_RatingsCountAggregateInputType | true
    _avg?: User_RatingsAvgAggregateInputType
    _sum?: User_RatingsSumAggregateInputType
    _min?: User_RatingsMinAggregateInputType
    _max?: User_RatingsMaxAggregateInputType
  }

  export type User_RatingsGroupByOutputType = {
    userid: string
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
    _count: User_RatingsCountAggregateOutputType | null
    _avg: User_RatingsAvgAggregateOutputType | null
    _sum: User_RatingsSumAggregateOutputType | null
    _min: User_RatingsMinAggregateOutputType | null
    _max: User_RatingsMaxAggregateOutputType | null
  }

  type GetUser_RatingsGroupByPayload<T extends User_RatingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_RatingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_RatingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_RatingsGroupByOutputType[P]>
            : GetScalarType<T[P], User_RatingsGroupByOutputType[P]>
        }
      >
    >


  export type User_RatingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    parentid?: boolean
    mediatype?: boolean
    rating?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Ratings"]>

  export type User_RatingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    parentid?: boolean
    mediatype?: boolean
    rating?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Ratings"]>

  export type User_RatingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    parentid?: boolean
    mediatype?: boolean
    rating?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Ratings"]>

  export type User_RatingsSelectScalar = {
    userid?: boolean
    parentid?: boolean
    mediatype?: boolean
    rating?: boolean
  }

  export type User_RatingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "parentid" | "mediatype" | "rating", ExtArgs["result"]["user_Ratings"]>
  export type User_RatingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_RatingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type User_RatingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $User_RatingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User_Ratings"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      parentid: string
      mediatype: $Enums.MediaType
      rating: number
    }, ExtArgs["result"]["user_Ratings"]>
    composites: {}
  }

  type User_RatingsGetPayload<S extends boolean | null | undefined | User_RatingsDefaultArgs> = $Result.GetResult<Prisma.$User_RatingsPayload, S>

  type User_RatingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<User_RatingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_RatingsCountAggregateInputType | true
    }

  export interface User_RatingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User_Ratings'], meta: { name: 'User_Ratings' } }
    /**
     * Find zero or one User_Ratings that matches the filter.
     * @param {User_RatingsFindUniqueArgs} args - Arguments to find a User_Ratings
     * @example
     * // Get one User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends User_RatingsFindUniqueArgs>(args: SelectSubset<T, User_RatingsFindUniqueArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_Ratings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {User_RatingsFindUniqueOrThrowArgs} args - Arguments to find a User_Ratings
     * @example
     * // Get one User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends User_RatingsFindUniqueOrThrowArgs>(args: SelectSubset<T, User_RatingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsFindFirstArgs} args - Arguments to find a User_Ratings
     * @example
     * // Get one User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends User_RatingsFindFirstArgs>(args?: SelectSubset<T, User_RatingsFindFirstArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_Ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsFindFirstOrThrowArgs} args - Arguments to find a User_Ratings
     * @example
     * // Get one User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends User_RatingsFindFirstOrThrowArgs>(args?: SelectSubset<T, User_RatingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findMany()
     * 
     * // Get first 10 User_Ratings
     * const user_Ratings = await prisma.user_Ratings.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const user_RatingsWithUseridOnly = await prisma.user_Ratings.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends User_RatingsFindManyArgs>(args?: SelectSubset<T, User_RatingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_Ratings.
     * @param {User_RatingsCreateArgs} args - Arguments to create a User_Ratings.
     * @example
     * // Create one User_Ratings
     * const User_Ratings = await prisma.user_Ratings.create({
     *   data: {
     *     // ... data to create a User_Ratings
     *   }
     * })
     * 
     */
    create<T extends User_RatingsCreateArgs>(args: SelectSubset<T, User_RatingsCreateArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_Ratings.
     * @param {User_RatingsCreateManyArgs} args - Arguments to create many User_Ratings.
     * @example
     * // Create many User_Ratings
     * const user_Ratings = await prisma.user_Ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends User_RatingsCreateManyArgs>(args?: SelectSubset<T, User_RatingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_Ratings and returns the data saved in the database.
     * @param {User_RatingsCreateManyAndReturnArgs} args - Arguments to create many User_Ratings.
     * @example
     * // Create many User_Ratings
     * const user_Ratings = await prisma.user_Ratings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_Ratings and only return the `userid`
     * const user_RatingsWithUseridOnly = await prisma.user_Ratings.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends User_RatingsCreateManyAndReturnArgs>(args?: SelectSubset<T, User_RatingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_Ratings.
     * @param {User_RatingsDeleteArgs} args - Arguments to delete one User_Ratings.
     * @example
     * // Delete one User_Ratings
     * const User_Ratings = await prisma.user_Ratings.delete({
     *   where: {
     *     // ... filter to delete one User_Ratings
     *   }
     * })
     * 
     */
    delete<T extends User_RatingsDeleteArgs>(args: SelectSubset<T, User_RatingsDeleteArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_Ratings.
     * @param {User_RatingsUpdateArgs} args - Arguments to update one User_Ratings.
     * @example
     * // Update one User_Ratings
     * const user_Ratings = await prisma.user_Ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends User_RatingsUpdateArgs>(args: SelectSubset<T, User_RatingsUpdateArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_Ratings.
     * @param {User_RatingsDeleteManyArgs} args - Arguments to filter User_Ratings to delete.
     * @example
     * // Delete a few User_Ratings
     * const { count } = await prisma.user_Ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends User_RatingsDeleteManyArgs>(args?: SelectSubset<T, User_RatingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Ratings
     * const user_Ratings = await prisma.user_Ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends User_RatingsUpdateManyArgs>(args: SelectSubset<T, User_RatingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Ratings and returns the data updated in the database.
     * @param {User_RatingsUpdateManyAndReturnArgs} args - Arguments to update many User_Ratings.
     * @example
     * // Update many User_Ratings
     * const user_Ratings = await prisma.user_Ratings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_Ratings and only return the `userid`
     * const user_RatingsWithUseridOnly = await prisma.user_Ratings.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends User_RatingsUpdateManyAndReturnArgs>(args: SelectSubset<T, User_RatingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_Ratings.
     * @param {User_RatingsUpsertArgs} args - Arguments to update or create a User_Ratings.
     * @example
     * // Update or create a User_Ratings
     * const user_Ratings = await prisma.user_Ratings.upsert({
     *   create: {
     *     // ... data to create a User_Ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Ratings we want to update
     *   }
     * })
     */
    upsert<T extends User_RatingsUpsertArgs>(args: SelectSubset<T, User_RatingsUpsertArgs<ExtArgs>>): Prisma__User_RatingsClient<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsCountArgs} args - Arguments to filter User_Ratings to count.
     * @example
     * // Count the number of User_Ratings
     * const count = await prisma.user_Ratings.count({
     *   where: {
     *     // ... the filter for the User_Ratings we want to count
     *   }
     * })
    **/
    count<T extends User_RatingsCountArgs>(
      args?: Subset<T, User_RatingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_RatingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_RatingsAggregateArgs>(args: Subset<T, User_RatingsAggregateArgs>): Prisma.PrismaPromise<GetUser_RatingsAggregateType<T>>

    /**
     * Group by User_Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_RatingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_RatingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_RatingsGroupByArgs['orderBy'] }
        : { orderBy?: User_RatingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_RatingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_RatingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User_Ratings model
   */
  readonly fields: User_RatingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__User_RatingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User_Ratings model
   */ 
  interface User_RatingsFieldRefs {
    readonly userid: FieldRef<"User_Ratings", 'String'>
    readonly parentid: FieldRef<"User_Ratings", 'String'>
    readonly mediatype: FieldRef<"User_Ratings", 'MediaType'>
    readonly rating: FieldRef<"User_Ratings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User_Ratings findUnique
   */
  export type User_RatingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter, which User_Ratings to fetch.
     */
    where: User_RatingsWhereUniqueInput
  }

  /**
   * User_Ratings findUniqueOrThrow
   */
  export type User_RatingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter, which User_Ratings to fetch.
     */
    where: User_RatingsWhereUniqueInput
  }

  /**
   * User_Ratings findFirst
   */
  export type User_RatingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter, which User_Ratings to fetch.
     */
    where?: User_RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Ratings to fetch.
     */
    orderBy?: User_RatingsOrderByWithRelationInput | User_RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Ratings.
     */
    cursor?: User_RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Ratings.
     */
    distinct?: User_RatingsScalarFieldEnum | User_RatingsScalarFieldEnum[]
  }

  /**
   * User_Ratings findFirstOrThrow
   */
  export type User_RatingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter, which User_Ratings to fetch.
     */
    where?: User_RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Ratings to fetch.
     */
    orderBy?: User_RatingsOrderByWithRelationInput | User_RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Ratings.
     */
    cursor?: User_RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Ratings.
     */
    distinct?: User_RatingsScalarFieldEnum | User_RatingsScalarFieldEnum[]
  }

  /**
   * User_Ratings findMany
   */
  export type User_RatingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter, which User_Ratings to fetch.
     */
    where?: User_RatingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Ratings to fetch.
     */
    orderBy?: User_RatingsOrderByWithRelationInput | User_RatingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Ratings.
     */
    cursor?: User_RatingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Ratings.
     */
    skip?: number
    distinct?: User_RatingsScalarFieldEnum | User_RatingsScalarFieldEnum[]
  }

  /**
   * User_Ratings create
   */
  export type User_RatingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * The data needed to create a User_Ratings.
     */
    data: XOR<User_RatingsCreateInput, User_RatingsUncheckedCreateInput>
  }

  /**
   * User_Ratings createMany
   */
  export type User_RatingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many User_Ratings.
     */
    data: User_RatingsCreateManyInput | User_RatingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User_Ratings createManyAndReturn
   */
  export type User_RatingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * The data used to create many User_Ratings.
     */
    data: User_RatingsCreateManyInput | User_RatingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Ratings update
   */
  export type User_RatingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * The data needed to update a User_Ratings.
     */
    data: XOR<User_RatingsUpdateInput, User_RatingsUncheckedUpdateInput>
    /**
     * Choose, which User_Ratings to update.
     */
    where: User_RatingsWhereUniqueInput
  }

  /**
   * User_Ratings updateMany
   */
  export type User_RatingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update User_Ratings.
     */
    data: XOR<User_RatingsUpdateManyMutationInput, User_RatingsUncheckedUpdateManyInput>
    /**
     * Filter which User_Ratings to update
     */
    where?: User_RatingsWhereInput
    /**
     * Limit how many User_Ratings to update.
     */
    limit?: number
  }

  /**
   * User_Ratings updateManyAndReturn
   */
  export type User_RatingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * The data used to update User_Ratings.
     */
    data: XOR<User_RatingsUpdateManyMutationInput, User_RatingsUncheckedUpdateManyInput>
    /**
     * Filter which User_Ratings to update
     */
    where?: User_RatingsWhereInput
    /**
     * Limit how many User_Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User_Ratings upsert
   */
  export type User_RatingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * The filter to search for the User_Ratings to update in case it exists.
     */
    where: User_RatingsWhereUniqueInput
    /**
     * In case the User_Ratings found by the `where` argument doesn't exist, create a new User_Ratings with this data.
     */
    create: XOR<User_RatingsCreateInput, User_RatingsUncheckedCreateInput>
    /**
     * In case the User_Ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_RatingsUpdateInput, User_RatingsUncheckedUpdateInput>
  }

  /**
   * User_Ratings delete
   */
  export type User_RatingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    /**
     * Filter which User_Ratings to delete.
     */
    where: User_RatingsWhereUniqueInput
  }

  /**
   * User_Ratings deleteMany
   */
  export type User_RatingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Ratings to delete
     */
    where?: User_RatingsWhereInput
    /**
     * Limit how many User_Ratings to delete.
     */
    limit?: number
  }

  /**
   * User_Ratings without action
   */
  export type User_RatingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    num_of_friends: number | null
    num_of_followers: number | null
    subscriptionTierId: number | null
    usedstorage: number | null
  }

  export type UsersSumAggregateOutputType = {
    num_of_friends: number | null
    num_of_followers: number | null
    subscriptionTierId: number | null
    usedstorage: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    userid: string | null
    username: string | null
    email: string | null
    password_hash: string | null
    date_joined: Date | null
    num_of_friends: number | null
    num_of_followers: number | null
    profile_picture: string | null
    user_bio: string | null
    two_factor: boolean | null
    email_notifications: boolean | null
    push_notifications: boolean | null
    subscriptionTierId: number | null
    usedstorage: bigint | null
    accountType: $Enums.AccountType | null
  }

  export type UsersMaxAggregateOutputType = {
    userid: string | null
    username: string | null
    email: string | null
    password_hash: string | null
    date_joined: Date | null
    num_of_friends: number | null
    num_of_followers: number | null
    profile_picture: string | null
    user_bio: string | null
    two_factor: boolean | null
    email_notifications: boolean | null
    push_notifications: boolean | null
    subscriptionTierId: number | null
    usedstorage: bigint | null
    accountType: $Enums.AccountType | null
  }

  export type UsersCountAggregateOutputType = {
    userid: number
    username: number
    email: number
    password_hash: number
    date_joined: number
    num_of_friends: number
    num_of_followers: number
    profile_picture: number
    user_bio: number
    two_factor: number
    email_notifications: number
    push_notifications: number
    subscriptionTierId: number
    usedstorage: number
    accountType: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    num_of_friends?: true
    num_of_followers?: true
    subscriptionTierId?: true
    usedstorage?: true
  }

  export type UsersSumAggregateInputType = {
    num_of_friends?: true
    num_of_followers?: true
    subscriptionTierId?: true
    usedstorage?: true
  }

  export type UsersMinAggregateInputType = {
    userid?: true
    username?: true
    email?: true
    password_hash?: true
    date_joined?: true
    num_of_friends?: true
    num_of_followers?: true
    profile_picture?: true
    user_bio?: true
    two_factor?: true
    email_notifications?: true
    push_notifications?: true
    subscriptionTierId?: true
    usedstorage?: true
    accountType?: true
  }

  export type UsersMaxAggregateInputType = {
    userid?: true
    username?: true
    email?: true
    password_hash?: true
    date_joined?: true
    num_of_friends?: true
    num_of_followers?: true
    profile_picture?: true
    user_bio?: true
    two_factor?: true
    email_notifications?: true
    push_notifications?: true
    subscriptionTierId?: true
    usedstorage?: true
    accountType?: true
  }

  export type UsersCountAggregateInputType = {
    userid?: true
    username?: true
    email?: true
    password_hash?: true
    date_joined?: true
    num_of_friends?: true
    num_of_followers?: true
    profile_picture?: true
    user_bio?: true
    two_factor?: true
    email_notifications?: true
    push_notifications?: true
    subscriptionTierId?: true
    usedstorage?: true
    accountType?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    userid: string
    username: string
    email: string
    password_hash: string
    date_joined: Date
    num_of_friends: number | null
    num_of_followers: number | null
    profile_picture: string | null
    user_bio: string | null
    two_factor: boolean
    email_notifications: boolean
    push_notifications: boolean
    subscriptionTierId: number | null
    usedstorage: bigint
    accountType: $Enums.AccountType
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    date_joined?: boolean
    num_of_friends?: boolean
    num_of_followers?: boolean
    profile_picture?: boolean
    user_bio?: boolean
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: boolean
    usedstorage?: boolean
    accountType?: boolean
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
    Anime?: boolean | Users$AnimeArgs<ExtArgs>
    Anime_Authors?: boolean | Users$Anime_AuthorsArgs<ExtArgs>
    Bookmarks?: boolean | Users$BookmarksArgs<ExtArgs>
    Comments?: boolean | Users$CommentsArgs<ExtArgs>
    Disliked_Content?: boolean | Users$Disliked_ContentArgs<ExtArgs>
    File?: boolean | Users$FileArgs<ExtArgs>
    FileShares?: boolean | Users$FileSharesArgs<ExtArgs>
    Folder?: boolean | Users$FolderArgs<ExtArgs>
    FolderShares?: boolean | Users$FolderSharesArgs<ExtArgs>
    Liked_Content?: boolean | Users$Liked_ContentArgs<ExtArgs>
    Manga?: boolean | Users$MangaArgs<ExtArgs>
    Movies?: boolean | Users$MoviesArgs<ExtArgs>
    Polls?: boolean | Users$PollsArgs<ExtArgs>
    Reviews?: boolean | Users$ReviewsArgs<ExtArgs>
    Shopping_Cart?: boolean | Users$Shopping_CartArgs<ExtArgs>
    Store?: boolean | Users$StoreArgs<ExtArgs>
    User_Activity?: boolean | Users$User_ActivityArgs<ExtArgs>
    User_Bookmarks?: boolean | Users$User_BookmarksArgs<ExtArgs>
    User_Ratings?: boolean | Users$User_RatingsArgs<ExtArgs>
    Videos?: boolean | Users$VideosArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    date_joined?: boolean
    num_of_friends?: boolean
    num_of_followers?: boolean
    profile_picture?: boolean
    user_bio?: boolean
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: boolean
    usedstorage?: boolean
    accountType?: boolean
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userid?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    date_joined?: boolean
    num_of_friends?: boolean
    num_of_followers?: boolean
    profile_picture?: boolean
    user_bio?: boolean
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: boolean
    usedstorage?: boolean
    accountType?: boolean
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    userid?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    date_joined?: boolean
    num_of_friends?: boolean
    num_of_followers?: boolean
    profile_picture?: boolean
    user_bio?: boolean
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: boolean
    usedstorage?: boolean
    accountType?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userid" | "username" | "email" | "password_hash" | "date_joined" | "num_of_friends" | "num_of_followers" | "profile_picture" | "user_bio" | "two_factor" | "email_notifications" | "push_notifications" | "subscriptionTierId" | "usedstorage" | "accountType", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
    Anime?: boolean | Users$AnimeArgs<ExtArgs>
    Anime_Authors?: boolean | Users$Anime_AuthorsArgs<ExtArgs>
    Bookmarks?: boolean | Users$BookmarksArgs<ExtArgs>
    Comments?: boolean | Users$CommentsArgs<ExtArgs>
    Disliked_Content?: boolean | Users$Disliked_ContentArgs<ExtArgs>
    File?: boolean | Users$FileArgs<ExtArgs>
    FileShares?: boolean | Users$FileSharesArgs<ExtArgs>
    Folder?: boolean | Users$FolderArgs<ExtArgs>
    FolderShares?: boolean | Users$FolderSharesArgs<ExtArgs>
    Liked_Content?: boolean | Users$Liked_ContentArgs<ExtArgs>
    Manga?: boolean | Users$MangaArgs<ExtArgs>
    Movies?: boolean | Users$MoviesArgs<ExtArgs>
    Polls?: boolean | Users$PollsArgs<ExtArgs>
    Reviews?: boolean | Users$ReviewsArgs<ExtArgs>
    Shopping_Cart?: boolean | Users$Shopping_CartArgs<ExtArgs>
    Store?: boolean | Users$StoreArgs<ExtArgs>
    User_Activity?: boolean | Users$User_ActivityArgs<ExtArgs>
    User_Bookmarks?: boolean | Users$User_BookmarksArgs<ExtArgs>
    User_Ratings?: boolean | Users$User_RatingsArgs<ExtArgs>
    Videos?: boolean | Users$VideosArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription_tier?: boolean | Users$subscription_tierArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      subscription_tier: Prisma.$Subscription_TiersPayload<ExtArgs> | null
      Anime: Prisma.$AnimePayload<ExtArgs>[]
      Anime_Authors: Prisma.$Anime_AuthorsPayload<ExtArgs>[]
      Bookmarks: Prisma.$BookmarksPayload<ExtArgs>[]
      Comments: Prisma.$CommentsPayload<ExtArgs>[]
      Disliked_Content: Prisma.$Disliked_ContentPayload<ExtArgs>[]
      File: Prisma.$FilePayload<ExtArgs>[]
      FileShares: Prisma.$FileSharesPayload<ExtArgs>[]
      Folder: Prisma.$FolderPayload<ExtArgs>[]
      FolderShares: Prisma.$FolderSharesPayload<ExtArgs>[]
      Liked_Content: Prisma.$Liked_ContentPayload<ExtArgs>[]
      Manga: Prisma.$MangaPayload<ExtArgs>[]
      Movies: Prisma.$MoviesPayload<ExtArgs>[]
      Polls: Prisma.$PollsPayload<ExtArgs>[]
      Reviews: Prisma.$ReviewsPayload<ExtArgs>[]
      Shopping_Cart: Prisma.$Shopping_CartPayload<ExtArgs>[]
      Store: Prisma.$StorePayload<ExtArgs>[]
      User_Activity: Prisma.$User_ActivityPayload<ExtArgs>[]
      User_Bookmarks: Prisma.$User_BookmarksPayload<ExtArgs>[]
      User_Ratings: Prisma.$User_RatingsPayload<ExtArgs>[]
      Videos: Prisma.$VideosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userid: string
      username: string
      email: string
      password_hash: string
      date_joined: Date
      num_of_friends: number | null
      num_of_followers: number | null
      profile_picture: string | null
      user_bio: string | null
      two_factor: boolean
      email_notifications: boolean
      push_notifications: boolean
      subscriptionTierId: number | null
      usedstorage: bigint
      accountType: $Enums.AccountType
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `userid`
     * const usersWithUseridOnly = await prisma.users.findMany({ select: { userid: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `userid`
     * const usersWithUseridOnly = await prisma.users.createManyAndReturn({
     *   select: { userid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `userid`
     * const usersWithUseridOnly = await prisma.users.updateManyAndReturn({
     *   select: { userid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription_tier<T extends Users$subscription_tierArgs<ExtArgs> = {}>(args?: Subset<T, Users$subscription_tierArgs<ExtArgs>>): Prisma__Subscription_TiersClient<$Result.GetResult<Prisma.$Subscription_TiersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Anime<T extends Users$AnimeArgs<ExtArgs> = {}>(args?: Subset<T, Users$AnimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Anime_Authors<T extends Users$Anime_AuthorsArgs<ExtArgs> = {}>(args?: Subset<T, Users$Anime_AuthorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Anime_AuthorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bookmarks<T extends Users$BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Users$BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comments<T extends Users$CommentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$CommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Disliked_Content<T extends Users$Disliked_ContentArgs<ExtArgs> = {}>(args?: Subset<T, Users$Disliked_ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Disliked_ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    File<T extends Users$FileArgs<ExtArgs> = {}>(args?: Subset<T, Users$FileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FileShares<T extends Users$FileSharesArgs<ExtArgs> = {}>(args?: Subset<T, Users$FileSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Folder<T extends Users$FolderArgs<ExtArgs> = {}>(args?: Subset<T, Users$FolderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FolderShares<T extends Users$FolderSharesArgs<ExtArgs> = {}>(args?: Subset<T, Users$FolderSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderSharesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Liked_Content<T extends Users$Liked_ContentArgs<ExtArgs> = {}>(args?: Subset<T, Users$Liked_ContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Liked_ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Manga<T extends Users$MangaArgs<ExtArgs> = {}>(args?: Subset<T, Users$MangaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MangaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Movies<T extends Users$MoviesArgs<ExtArgs> = {}>(args?: Subset<T, Users$MoviesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Polls<T extends Users$PollsArgs<ExtArgs> = {}>(args?: Subset<T, Users$PollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reviews<T extends Users$ReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Users$ReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Shopping_Cart<T extends Users$Shopping_CartArgs<ExtArgs> = {}>(args?: Subset<T, Users$Shopping_CartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Shopping_CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Store<T extends Users$StoreArgs<ExtArgs> = {}>(args?: Subset<T, Users$StoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Activity<T extends Users$User_ActivityArgs<ExtArgs> = {}>(args?: Subset<T, Users$User_ActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Bookmarks<T extends Users$User_BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Users$User_BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Ratings<T extends Users$User_RatingsArgs<ExtArgs> = {}>(args?: Subset<T, Users$User_RatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_RatingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Videos<T extends Users$VideosArgs<ExtArgs> = {}>(args?: Subset<T, Users$VideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly userid: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password_hash: FieldRef<"Users", 'String'>
    readonly date_joined: FieldRef<"Users", 'DateTime'>
    readonly num_of_friends: FieldRef<"Users", 'Int'>
    readonly num_of_followers: FieldRef<"Users", 'Int'>
    readonly profile_picture: FieldRef<"Users", 'String'>
    readonly user_bio: FieldRef<"Users", 'String'>
    readonly two_factor: FieldRef<"Users", 'Boolean'>
    readonly email_notifications: FieldRef<"Users", 'Boolean'>
    readonly push_notifications: FieldRef<"Users", 'Boolean'>
    readonly subscriptionTierId: FieldRef<"Users", 'Int'>
    readonly usedstorage: FieldRef<"Users", 'BigInt'>
    readonly accountType: FieldRef<"Users", 'AccountType'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.subscription_tier
   */
  export type Users$subscription_tierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription_Tiers
     */
    select?: Subscription_TiersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription_Tiers
     */
    omit?: Subscription_TiersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Subscription_TiersInclude<ExtArgs> | null
    where?: Subscription_TiersWhereInput
  }

  /**
   * Users.Anime
   */
  export type Users$AnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    cursor?: AnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Users.Anime_Authors
   */
  export type Users$Anime_AuthorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime_Authors
     */
    select?: Anime_AuthorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime_Authors
     */
    omit?: Anime_AuthorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Anime_AuthorsInclude<ExtArgs> | null
    where?: Anime_AuthorsWhereInput
    orderBy?: Anime_AuthorsOrderByWithRelationInput | Anime_AuthorsOrderByWithRelationInput[]
    cursor?: Anime_AuthorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Anime_AuthorsScalarFieldEnum | Anime_AuthorsScalarFieldEnum[]
  }

  /**
   * Users.Bookmarks
   */
  export type Users$BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    cursor?: BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Users.Comments
   */
  export type Users$CommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Users.Disliked_Content
   */
  export type Users$Disliked_ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disliked_Content
     */
    select?: Disliked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Disliked_Content
     */
    omit?: Disliked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Disliked_ContentInclude<ExtArgs> | null
    where?: Disliked_ContentWhereInput
    orderBy?: Disliked_ContentOrderByWithRelationInput | Disliked_ContentOrderByWithRelationInput[]
    cursor?: Disliked_ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Disliked_ContentScalarFieldEnum | Disliked_ContentScalarFieldEnum[]
  }

  /**
   * Users.File
   */
  export type Users$FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Users.FileShares
   */
  export type Users$FileSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileShares
     */
    select?: FileSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileShares
     */
    omit?: FileSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSharesInclude<ExtArgs> | null
    where?: FileSharesWhereInput
    orderBy?: FileSharesOrderByWithRelationInput | FileSharesOrderByWithRelationInput[]
    cursor?: FileSharesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileSharesScalarFieldEnum | FileSharesScalarFieldEnum[]
  }

  /**
   * Users.Folder
   */
  export type Users$FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Users.FolderShares
   */
  export type Users$FolderSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderShares
     */
    select?: FolderSharesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderShares
     */
    omit?: FolderSharesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderSharesInclude<ExtArgs> | null
    where?: FolderSharesWhereInput
    orderBy?: FolderSharesOrderByWithRelationInput | FolderSharesOrderByWithRelationInput[]
    cursor?: FolderSharesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderSharesScalarFieldEnum | FolderSharesScalarFieldEnum[]
  }

  /**
   * Users.Liked_Content
   */
  export type Users$Liked_ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liked_Content
     */
    select?: Liked_ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liked_Content
     */
    omit?: Liked_ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Liked_ContentInclude<ExtArgs> | null
    where?: Liked_ContentWhereInput
    orderBy?: Liked_ContentOrderByWithRelationInput | Liked_ContentOrderByWithRelationInput[]
    cursor?: Liked_ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Liked_ContentScalarFieldEnum | Liked_ContentScalarFieldEnum[]
  }

  /**
   * Users.Manga
   */
  export type Users$MangaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manga
     */
    select?: MangaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manga
     */
    omit?: MangaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MangaInclude<ExtArgs> | null
    where?: MangaWhereInput
    orderBy?: MangaOrderByWithRelationInput | MangaOrderByWithRelationInput[]
    cursor?: MangaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MangaScalarFieldEnum | MangaScalarFieldEnum[]
  }

  /**
   * Users.Movies
   */
  export type Users$MoviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movies
     */
    select?: MoviesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Movies
     */
    omit?: MoviesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoviesInclude<ExtArgs> | null
    where?: MoviesWhereInput
    orderBy?: MoviesOrderByWithRelationInput | MoviesOrderByWithRelationInput[]
    cursor?: MoviesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * Users.Polls
   */
  export type Users$PollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Polls
     */
    select?: PollsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Polls
     */
    omit?: PollsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollsInclude<ExtArgs> | null
    where?: PollsWhereInput
    orderBy?: PollsOrderByWithRelationInput | PollsOrderByWithRelationInput[]
    cursor?: PollsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollsScalarFieldEnum | PollsScalarFieldEnum[]
  }

  /**
   * Users.Reviews
   */
  export type Users$ReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reviews
     */
    select?: ReviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reviews
     */
    omit?: ReviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewsInclude<ExtArgs> | null
    where?: ReviewsWhereInput
    orderBy?: ReviewsOrderByWithRelationInput | ReviewsOrderByWithRelationInput[]
    cursor?: ReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * Users.Shopping_Cart
   */
  export type Users$Shopping_CartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping_Cart
     */
    select?: Shopping_CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping_Cart
     */
    omit?: Shopping_CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Shopping_CartInclude<ExtArgs> | null
    where?: Shopping_CartWhereInput
    orderBy?: Shopping_CartOrderByWithRelationInput | Shopping_CartOrderByWithRelationInput[]
    cursor?: Shopping_CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Shopping_CartScalarFieldEnum | Shopping_CartScalarFieldEnum[]
  }

  /**
   * Users.Store
   */
  export type Users$StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Users.User_Activity
   */
  export type Users$User_ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Activity
     */
    select?: User_ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Activity
     */
    omit?: User_ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_ActivityInclude<ExtArgs> | null
    where?: User_ActivityWhereInput
    orderBy?: User_ActivityOrderByWithRelationInput | User_ActivityOrderByWithRelationInput[]
    cursor?: User_ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_ActivityScalarFieldEnum | User_ActivityScalarFieldEnum[]
  }

  /**
   * Users.User_Bookmarks
   */
  export type Users$User_BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Bookmarks
     */
    select?: User_BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Bookmarks
     */
    omit?: User_BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_BookmarksInclude<ExtArgs> | null
    where?: User_BookmarksWhereInput
    orderBy?: User_BookmarksOrderByWithRelationInput | User_BookmarksOrderByWithRelationInput[]
    cursor?: User_BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_BookmarksScalarFieldEnum | User_BookmarksScalarFieldEnum[]
  }

  /**
   * Users.User_Ratings
   */
  export type Users$User_RatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Ratings
     */
    select?: User_RatingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User_Ratings
     */
    omit?: User_RatingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: User_RatingsInclude<ExtArgs> | null
    where?: User_RatingsWhereInput
    orderBy?: User_RatingsOrderByWithRelationInput | User_RatingsOrderByWithRelationInput[]
    cursor?: User_RatingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_RatingsScalarFieldEnum | User_RatingsScalarFieldEnum[]
  }

  /**
   * Users.Videos
   */
  export type Users$VideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    where?: VideosWhereInput
    orderBy?: VideosOrderByWithRelationInput | VideosOrderByWithRelationInput[]
    cursor?: VideosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Videos
   */

  export type AggregateVideos = {
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  export type VideosAvgAggregateOutputType = {
    likes: number | null
    dislikes: number | null
    duration: number | null
    views: number | null
  }

  export type VideosSumAggregateOutputType = {
    likes: bigint | null
    dislikes: bigint | null
    duration: bigint | null
    views: number | null
  }

  export type VideosMinAggregateOutputType = {
    videoid: string | null
    title: string | null
    authorid: string | null
    description: string | null
    release_date: Date | null
    media_type: $Enums.MediaType | null
    video_banner: string | null
    likes: bigint | null
    dislikes: bigint | null
    duration: bigint | null
    thumbnail: string | null
    views: number | null
  }

  export type VideosMaxAggregateOutputType = {
    videoid: string | null
    title: string | null
    authorid: string | null
    description: string | null
    release_date: Date | null
    media_type: $Enums.MediaType | null
    video_banner: string | null
    likes: bigint | null
    dislikes: bigint | null
    duration: bigint | null
    thumbnail: string | null
    views: number | null
  }

  export type VideosCountAggregateOutputType = {
    videoid: number
    title: number
    authorid: number
    description: number
    release_date: number
    media_type: number
    video_banner: number
    likes: number
    dislikes: number
    duration: number
    MediaGenre: number
    thumbnail: number
    views: number
    _all: number
  }


  export type VideosAvgAggregateInputType = {
    likes?: true
    dislikes?: true
    duration?: true
    views?: true
  }

  export type VideosSumAggregateInputType = {
    likes?: true
    dislikes?: true
    duration?: true
    views?: true
  }

  export type VideosMinAggregateInputType = {
    videoid?: true
    title?: true
    authorid?: true
    description?: true
    release_date?: true
    media_type?: true
    video_banner?: true
    likes?: true
    dislikes?: true
    duration?: true
    thumbnail?: true
    views?: true
  }

  export type VideosMaxAggregateInputType = {
    videoid?: true
    title?: true
    authorid?: true
    description?: true
    release_date?: true
    media_type?: true
    video_banner?: true
    likes?: true
    dislikes?: true
    duration?: true
    thumbnail?: true
    views?: true
  }

  export type VideosCountAggregateInputType = {
    videoid?: true
    title?: true
    authorid?: true
    description?: true
    release_date?: true
    media_type?: true
    video_banner?: true
    likes?: true
    dislikes?: true
    duration?: true
    MediaGenre?: true
    thumbnail?: true
    views?: true
    _all?: true
  }

  export type VideosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to aggregate.
     */
    where?: VideosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideosOrderByWithRelationInput | VideosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideosMaxAggregateInputType
  }

  export type GetVideosAggregateType<T extends VideosAggregateArgs> = {
        [P in keyof T & keyof AggregateVideos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideos[P]>
      : GetScalarType<T[P], AggregateVideos[P]>
  }




  export type VideosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideosWhereInput
    orderBy?: VideosOrderByWithAggregationInput | VideosOrderByWithAggregationInput[]
    by: VideosScalarFieldEnum[] | VideosScalarFieldEnum
    having?: VideosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideosCountAggregateInputType | true
    _avg?: VideosAvgAggregateInputType
    _sum?: VideosSumAggregateInputType
    _min?: VideosMinAggregateInputType
    _max?: VideosMaxAggregateInputType
  }

  export type VideosGroupByOutputType = {
    videoid: string
    title: string
    authorid: string
    description: string
    release_date: Date | null
    media_type: $Enums.MediaType
    video_banner: string
    likes: bigint
    dislikes: bigint
    duration: bigint | null
    MediaGenre: $Enums.MediaGenre[]
    thumbnail: string
    views: number
    _count: VideosCountAggregateOutputType | null
    _avg: VideosAvgAggregateOutputType | null
    _sum: VideosSumAggregateOutputType | null
    _min: VideosMinAggregateOutputType | null
    _max: VideosMaxAggregateOutputType | null
  }

  type GetVideosGroupByPayload<T extends VideosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideosGroupByOutputType[P]>
            : GetScalarType<T[P], VideosGroupByOutputType[P]>
        }
      >
    >


  export type VideosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoid?: boolean
    title?: boolean
    authorid?: boolean
    description?: boolean
    release_date?: boolean
    media_type?: boolean
    video_banner?: boolean
    likes?: boolean
    dislikes?: boolean
    duration?: boolean
    MediaGenre?: boolean
    thumbnail?: boolean
    views?: boolean
    Anime?: boolean | Videos$AnimeArgs<ExtArgs>
    Bookmarks?: boolean | Videos$BookmarksArgs<ExtArgs>
    Comments?: boolean | Videos$CommentsArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>

  export type VideosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoid?: boolean
    title?: boolean
    authorid?: boolean
    description?: boolean
    release_date?: boolean
    media_type?: boolean
    video_banner?: boolean
    likes?: boolean
    dislikes?: boolean
    duration?: boolean
    MediaGenre?: boolean
    thumbnail?: boolean
    views?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>

  export type VideosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    videoid?: boolean
    title?: boolean
    authorid?: boolean
    description?: boolean
    release_date?: boolean
    media_type?: boolean
    video_banner?: boolean
    likes?: boolean
    dislikes?: boolean
    duration?: boolean
    MediaGenre?: boolean
    thumbnail?: boolean
    views?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videos"]>

  export type VideosSelectScalar = {
    videoid?: boolean
    title?: boolean
    authorid?: boolean
    description?: boolean
    release_date?: boolean
    media_type?: boolean
    video_banner?: boolean
    likes?: boolean
    dislikes?: boolean
    duration?: boolean
    MediaGenre?: boolean
    thumbnail?: boolean
    views?: boolean
  }

  export type VideosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"videoid" | "title" | "authorid" | "description" | "release_date" | "media_type" | "video_banner" | "likes" | "dislikes" | "duration" | "MediaGenre" | "thumbnail" | "views", ExtArgs["result"]["videos"]>
  export type VideosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Anime?: boolean | Videos$AnimeArgs<ExtArgs>
    Bookmarks?: boolean | Videos$BookmarksArgs<ExtArgs>
    Comments?: boolean | Videos$CommentsArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | VideosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type VideosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $VideosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Videos"
    objects: {
      Anime: Prisma.$AnimePayload<ExtArgs>[]
      Bookmarks: Prisma.$BookmarksPayload<ExtArgs>[]
      Comments: Prisma.$CommentsPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      videoid: string
      title: string
      authorid: string
      description: string
      release_date: Date | null
      media_type: $Enums.MediaType
      video_banner: string
      likes: bigint
      dislikes: bigint
      duration: bigint | null
      MediaGenre: $Enums.MediaGenre[]
      thumbnail: string
      views: number
    }, ExtArgs["result"]["videos"]>
    composites: {}
  }

  type VideosGetPayload<S extends boolean | null | undefined | VideosDefaultArgs> = $Result.GetResult<Prisma.$VideosPayload, S>

  type VideosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideosCountAggregateInputType | true
    }

  export interface VideosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Videos'], meta: { name: 'Videos' } }
    /**
     * Find zero or one Videos that matches the filter.
     * @param {VideosFindUniqueArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideosFindUniqueArgs>(args: SelectSubset<T, VideosFindUniqueArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Videos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideosFindUniqueOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideosFindUniqueOrThrowArgs>(args: SelectSubset<T, VideosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosFindFirstArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideosFindFirstArgs>(args?: SelectSubset<T, VideosFindFirstArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosFindFirstOrThrowArgs} args - Arguments to find a Videos
     * @example
     * // Get one Videos
     * const videos = await prisma.videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideosFindFirstOrThrowArgs>(args?: SelectSubset<T, VideosFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.videos.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.videos.findMany({ take: 10 })
     * 
     * // Only select the `videoid`
     * const videosWithVideoidOnly = await prisma.videos.findMany({ select: { videoid: true } })
     * 
     */
    findMany<T extends VideosFindManyArgs>(args?: SelectSubset<T, VideosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Videos.
     * @param {VideosCreateArgs} args - Arguments to create a Videos.
     * @example
     * // Create one Videos
     * const Videos = await prisma.videos.create({
     *   data: {
     *     // ... data to create a Videos
     *   }
     * })
     * 
     */
    create<T extends VideosCreateArgs>(args: SelectSubset<T, VideosCreateArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideosCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const videos = await prisma.videos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideosCreateManyArgs>(args?: SelectSubset<T, VideosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideosCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const videos = await prisma.videos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `videoid`
     * const videosWithVideoidOnly = await prisma.videos.createManyAndReturn({
     *   select: { videoid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideosCreateManyAndReturnArgs>(args?: SelectSubset<T, VideosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Videos.
     * @param {VideosDeleteArgs} args - Arguments to delete one Videos.
     * @example
     * // Delete one Videos
     * const Videos = await prisma.videos.delete({
     *   where: {
     *     // ... filter to delete one Videos
     *   }
     * })
     * 
     */
    delete<T extends VideosDeleteArgs>(args: SelectSubset<T, VideosDeleteArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Videos.
     * @param {VideosUpdateArgs} args - Arguments to update one Videos.
     * @example
     * // Update one Videos
     * const videos = await prisma.videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideosUpdateArgs>(args: SelectSubset<T, VideosUpdateArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideosDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideosDeleteManyArgs>(args?: SelectSubset<T, VideosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideosUpdateManyArgs>(args: SelectSubset<T, VideosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideosUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const videos = await prisma.videos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `videoid`
     * const videosWithVideoidOnly = await prisma.videos.updateManyAndReturn({
     *   select: { videoid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideosUpdateManyAndReturnArgs>(args: SelectSubset<T, VideosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Videos.
     * @param {VideosUpsertArgs} args - Arguments to update or create a Videos.
     * @example
     * // Update or create a Videos
     * const videos = await prisma.videos.upsert({
     *   create: {
     *     // ... data to create a Videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videos we want to update
     *   }
     * })
     */
    upsert<T extends VideosUpsertArgs>(args: SelectSubset<T, VideosUpsertArgs<ExtArgs>>): Prisma__VideosClient<$Result.GetResult<Prisma.$VideosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.videos.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideosCountArgs>(
      args?: Subset<T, VideosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideosAggregateArgs>(args: Subset<T, VideosAggregateArgs>): Prisma.PrismaPromise<GetVideosAggregateType<T>>

    /**
     * Group by Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideosGroupByArgs['orderBy'] }
        : { orderBy?: VideosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Videos model
   */
  readonly fields: VideosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Anime<T extends Videos$AnimeArgs<ExtArgs> = {}>(args?: Subset<T, Videos$AnimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bookmarks<T extends Videos$BookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Videos$BookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comments<T extends Videos$CommentsArgs<ExtArgs> = {}>(args?: Subset<T, Videos$CommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Videos model
   */ 
  interface VideosFieldRefs {
    readonly videoid: FieldRef<"Videos", 'String'>
    readonly title: FieldRef<"Videos", 'String'>
    readonly authorid: FieldRef<"Videos", 'String'>
    readonly description: FieldRef<"Videos", 'String'>
    readonly release_date: FieldRef<"Videos", 'DateTime'>
    readonly media_type: FieldRef<"Videos", 'MediaType'>
    readonly video_banner: FieldRef<"Videos", 'String'>
    readonly likes: FieldRef<"Videos", 'BigInt'>
    readonly dislikes: FieldRef<"Videos", 'BigInt'>
    readonly duration: FieldRef<"Videos", 'BigInt'>
    readonly MediaGenre: FieldRef<"Videos", 'MediaGenre[]'>
    readonly thumbnail: FieldRef<"Videos", 'String'>
    readonly views: FieldRef<"Videos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Videos findUnique
   */
  export type VideosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where: VideosWhereUniqueInput
  }

  /**
   * Videos findUniqueOrThrow
   */
  export type VideosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where: VideosWhereUniqueInput
  }

  /**
   * Videos findFirst
   */
  export type VideosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideosOrderByWithRelationInput | VideosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * Videos findFirstOrThrow
   */
  export type VideosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideosOrderByWithRelationInput | VideosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * Videos findMany
   */
  export type VideosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideosOrderByWithRelationInput | VideosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideosScalarFieldEnum | VideosScalarFieldEnum[]
  }

  /**
   * Videos create
   */
  export type VideosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * The data needed to create a Videos.
     */
    data: XOR<VideosCreateInput, VideosUncheckedCreateInput>
  }

  /**
   * Videos createMany
   */
  export type VideosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideosCreateManyInput | VideosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Videos createManyAndReturn
   */
  export type VideosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideosCreateManyInput | VideosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Videos update
   */
  export type VideosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * The data needed to update a Videos.
     */
    data: XOR<VideosUpdateInput, VideosUncheckedUpdateInput>
    /**
     * Choose, which Videos to update.
     */
    where: VideosWhereUniqueInput
  }

  /**
   * Videos updateMany
   */
  export type VideosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideosUpdateManyMutationInput, VideosUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideosWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Videos updateManyAndReturn
   */
  export type VideosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideosUpdateManyMutationInput, VideosUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideosWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Videos upsert
   */
  export type VideosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * The filter to search for the Videos to update in case it exists.
     */
    where: VideosWhereUniqueInput
    /**
     * In case the Videos found by the `where` argument doesn't exist, create a new Videos with this data.
     */
    create: XOR<VideosCreateInput, VideosUncheckedCreateInput>
    /**
     * In case the Videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideosUpdateInput, VideosUncheckedUpdateInput>
  }

  /**
   * Videos delete
   */
  export type VideosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
    /**
     * Filter which Videos to delete.
     */
    where: VideosWhereUniqueInput
  }

  /**
   * Videos deleteMany
   */
  export type VideosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideosWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Videos.Anime
   */
  export type Videos$AnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    cursor?: AnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Videos.Bookmarks
   */
  export type Videos$BookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmarks
     */
    select?: BookmarksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmarks
     */
    omit?: BookmarksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarksInclude<ExtArgs> | null
    where?: BookmarksWhereInput
    orderBy?: BookmarksOrderByWithRelationInput | BookmarksOrderByWithRelationInput[]
    cursor?: BookmarksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarksScalarFieldEnum | BookmarksScalarFieldEnum[]
  }

  /**
   * Videos.Comments
   */
  export type Videos$CommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Videos without action
   */
  export type VideosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Videos
     */
    select?: VideosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Videos
     */
    omit?: VideosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideosInclude<ExtArgs> | null
  }


  /**
   * Model Website_Variables
   */

  export type AggregateWebsite_Variables = {
    _count: Website_VariablesCountAggregateOutputType | null
    _min: Website_VariablesMinAggregateOutputType | null
    _max: Website_VariablesMaxAggregateOutputType | null
  }

  export type Website_VariablesMinAggregateOutputType = {
    website_version: string | null
    footer_separator: string | null
    important_info: string | null
    rootContentPath: string | null
  }

  export type Website_VariablesMaxAggregateOutputType = {
    website_version: string | null
    footer_separator: string | null
    important_info: string | null
    rootContentPath: string | null
  }

  export type Website_VariablesCountAggregateOutputType = {
    website_version: number
    footer_items: number
    footer_separator: number
    important_info: number
    rootContentPath: number
    loggedin_nav_items: number
    loggedout_nav_items: number
    _all: number
  }


  export type Website_VariablesMinAggregateInputType = {
    website_version?: true
    footer_separator?: true
    important_info?: true
    rootContentPath?: true
  }

  export type Website_VariablesMaxAggregateInputType = {
    website_version?: true
    footer_separator?: true
    important_info?: true
    rootContentPath?: true
  }

  export type Website_VariablesCountAggregateInputType = {
    website_version?: true
    footer_items?: true
    footer_separator?: true
    important_info?: true
    rootContentPath?: true
    loggedin_nav_items?: true
    loggedout_nav_items?: true
    _all?: true
  }

  export type Website_VariablesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Website_Variables to aggregate.
     */
    where?: Website_VariablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Website_Variables to fetch.
     */
    orderBy?: Website_VariablesOrderByWithRelationInput | Website_VariablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Website_VariablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Website_Variables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Website_Variables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Website_Variables
    **/
    _count?: true | Website_VariablesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Website_VariablesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Website_VariablesMaxAggregateInputType
  }

  export type GetWebsite_VariablesAggregateType<T extends Website_VariablesAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsite_Variables]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsite_Variables[P]>
      : GetScalarType<T[P], AggregateWebsite_Variables[P]>
  }




  export type Website_VariablesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Website_VariablesWhereInput
    orderBy?: Website_VariablesOrderByWithAggregationInput | Website_VariablesOrderByWithAggregationInput[]
    by: Website_VariablesScalarFieldEnum[] | Website_VariablesScalarFieldEnum
    having?: Website_VariablesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Website_VariablesCountAggregateInputType | true
    _min?: Website_VariablesMinAggregateInputType
    _max?: Website_VariablesMaxAggregateInputType
  }

  export type Website_VariablesGroupByOutputType = {
    website_version: string
    footer_items: string[]
    footer_separator: string | null
    important_info: string | null
    rootContentPath: string | null
    loggedin_nav_items: $Enums.MediaType[]
    loggedout_nav_items: $Enums.MediaType[]
    _count: Website_VariablesCountAggregateOutputType | null
    _min: Website_VariablesMinAggregateOutputType | null
    _max: Website_VariablesMaxAggregateOutputType | null
  }

  type GetWebsite_VariablesGroupByPayload<T extends Website_VariablesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Website_VariablesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Website_VariablesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Website_VariablesGroupByOutputType[P]>
            : GetScalarType<T[P], Website_VariablesGroupByOutputType[P]>
        }
      >
    >


  export type Website_VariablesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    website_version?: boolean
    footer_items?: boolean
    footer_separator?: boolean
    important_info?: boolean
    rootContentPath?: boolean
    loggedin_nav_items?: boolean
    loggedout_nav_items?: boolean
  }, ExtArgs["result"]["website_Variables"]>

  export type Website_VariablesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    website_version?: boolean
    footer_items?: boolean
    footer_separator?: boolean
    important_info?: boolean
    rootContentPath?: boolean
    loggedin_nav_items?: boolean
    loggedout_nav_items?: boolean
  }, ExtArgs["result"]["website_Variables"]>

  export type Website_VariablesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    website_version?: boolean
    footer_items?: boolean
    footer_separator?: boolean
    important_info?: boolean
    rootContentPath?: boolean
    loggedin_nav_items?: boolean
    loggedout_nav_items?: boolean
  }, ExtArgs["result"]["website_Variables"]>

  export type Website_VariablesSelectScalar = {
    website_version?: boolean
    footer_items?: boolean
    footer_separator?: boolean
    important_info?: boolean
    rootContentPath?: boolean
    loggedin_nav_items?: boolean
    loggedout_nav_items?: boolean
  }

  export type Website_VariablesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"website_version" | "footer_items" | "footer_separator" | "important_info" | "rootContentPath" | "loggedin_nav_items" | "loggedout_nav_items", ExtArgs["result"]["website_Variables"]>

  export type $Website_VariablesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Website_Variables"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      website_version: string
      footer_items: string[]
      footer_separator: string | null
      important_info: string | null
      rootContentPath: string | null
      loggedin_nav_items: $Enums.MediaType[]
      loggedout_nav_items: $Enums.MediaType[]
    }, ExtArgs["result"]["website_Variables"]>
    composites: {}
  }

  type Website_VariablesGetPayload<S extends boolean | null | undefined | Website_VariablesDefaultArgs> = $Result.GetResult<Prisma.$Website_VariablesPayload, S>

  type Website_VariablesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Website_VariablesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Website_VariablesCountAggregateInputType | true
    }

  export interface Website_VariablesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Website_Variables'], meta: { name: 'Website_Variables' } }
    /**
     * Find zero or one Website_Variables that matches the filter.
     * @param {Website_VariablesFindUniqueArgs} args - Arguments to find a Website_Variables
     * @example
     * // Get one Website_Variables
     * const website_Variables = await prisma.website_Variables.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Website_VariablesFindUniqueArgs>(args: SelectSubset<T, Website_VariablesFindUniqueArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Website_Variables that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Website_VariablesFindUniqueOrThrowArgs} args - Arguments to find a Website_Variables
     * @example
     * // Get one Website_Variables
     * const website_Variables = await prisma.website_Variables.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Website_VariablesFindUniqueOrThrowArgs>(args: SelectSubset<T, Website_VariablesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Website_Variables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesFindFirstArgs} args - Arguments to find a Website_Variables
     * @example
     * // Get one Website_Variables
     * const website_Variables = await prisma.website_Variables.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Website_VariablesFindFirstArgs>(args?: SelectSubset<T, Website_VariablesFindFirstArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Website_Variables that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesFindFirstOrThrowArgs} args - Arguments to find a Website_Variables
     * @example
     * // Get one Website_Variables
     * const website_Variables = await prisma.website_Variables.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Website_VariablesFindFirstOrThrowArgs>(args?: SelectSubset<T, Website_VariablesFindFirstOrThrowArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Website_Variables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Website_Variables
     * const website_Variables = await prisma.website_Variables.findMany()
     * 
     * // Get first 10 Website_Variables
     * const website_Variables = await prisma.website_Variables.findMany({ take: 10 })
     * 
     * // Only select the `website_version`
     * const website_VariablesWithWebsite_versionOnly = await prisma.website_Variables.findMany({ select: { website_version: true } })
     * 
     */
    findMany<T extends Website_VariablesFindManyArgs>(args?: SelectSubset<T, Website_VariablesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Website_Variables.
     * @param {Website_VariablesCreateArgs} args - Arguments to create a Website_Variables.
     * @example
     * // Create one Website_Variables
     * const Website_Variables = await prisma.website_Variables.create({
     *   data: {
     *     // ... data to create a Website_Variables
     *   }
     * })
     * 
     */
    create<T extends Website_VariablesCreateArgs>(args: SelectSubset<T, Website_VariablesCreateArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Website_Variables.
     * @param {Website_VariablesCreateManyArgs} args - Arguments to create many Website_Variables.
     * @example
     * // Create many Website_Variables
     * const website_Variables = await prisma.website_Variables.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Website_VariablesCreateManyArgs>(args?: SelectSubset<T, Website_VariablesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Website_Variables and returns the data saved in the database.
     * @param {Website_VariablesCreateManyAndReturnArgs} args - Arguments to create many Website_Variables.
     * @example
     * // Create many Website_Variables
     * const website_Variables = await prisma.website_Variables.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Website_Variables and only return the `website_version`
     * const website_VariablesWithWebsite_versionOnly = await prisma.website_Variables.createManyAndReturn({
     *   select: { website_version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Website_VariablesCreateManyAndReturnArgs>(args?: SelectSubset<T, Website_VariablesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Website_Variables.
     * @param {Website_VariablesDeleteArgs} args - Arguments to delete one Website_Variables.
     * @example
     * // Delete one Website_Variables
     * const Website_Variables = await prisma.website_Variables.delete({
     *   where: {
     *     // ... filter to delete one Website_Variables
     *   }
     * })
     * 
     */
    delete<T extends Website_VariablesDeleteArgs>(args: SelectSubset<T, Website_VariablesDeleteArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Website_Variables.
     * @param {Website_VariablesUpdateArgs} args - Arguments to update one Website_Variables.
     * @example
     * // Update one Website_Variables
     * const website_Variables = await prisma.website_Variables.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Website_VariablesUpdateArgs>(args: SelectSubset<T, Website_VariablesUpdateArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Website_Variables.
     * @param {Website_VariablesDeleteManyArgs} args - Arguments to filter Website_Variables to delete.
     * @example
     * // Delete a few Website_Variables
     * const { count } = await prisma.website_Variables.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Website_VariablesDeleteManyArgs>(args?: SelectSubset<T, Website_VariablesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Website_Variables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Website_Variables
     * const website_Variables = await prisma.website_Variables.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Website_VariablesUpdateManyArgs>(args: SelectSubset<T, Website_VariablesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Website_Variables and returns the data updated in the database.
     * @param {Website_VariablesUpdateManyAndReturnArgs} args - Arguments to update many Website_Variables.
     * @example
     * // Update many Website_Variables
     * const website_Variables = await prisma.website_Variables.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Website_Variables and only return the `website_version`
     * const website_VariablesWithWebsite_versionOnly = await prisma.website_Variables.updateManyAndReturn({
     *   select: { website_version: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Website_VariablesUpdateManyAndReturnArgs>(args: SelectSubset<T, Website_VariablesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Website_Variables.
     * @param {Website_VariablesUpsertArgs} args - Arguments to update or create a Website_Variables.
     * @example
     * // Update or create a Website_Variables
     * const website_Variables = await prisma.website_Variables.upsert({
     *   create: {
     *     // ... data to create a Website_Variables
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Website_Variables we want to update
     *   }
     * })
     */
    upsert<T extends Website_VariablesUpsertArgs>(args: SelectSubset<T, Website_VariablesUpsertArgs<ExtArgs>>): Prisma__Website_VariablesClient<$Result.GetResult<Prisma.$Website_VariablesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Website_Variables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesCountArgs} args - Arguments to filter Website_Variables to count.
     * @example
     * // Count the number of Website_Variables
     * const count = await prisma.website_Variables.count({
     *   where: {
     *     // ... the filter for the Website_Variables we want to count
     *   }
     * })
    **/
    count<T extends Website_VariablesCountArgs>(
      args?: Subset<T, Website_VariablesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Website_VariablesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Website_Variables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Website_VariablesAggregateArgs>(args: Subset<T, Website_VariablesAggregateArgs>): Prisma.PrismaPromise<GetWebsite_VariablesAggregateType<T>>

    /**
     * Group by Website_Variables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Website_VariablesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Website_VariablesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Website_VariablesGroupByArgs['orderBy'] }
        : { orderBy?: Website_VariablesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Website_VariablesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsite_VariablesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Website_Variables model
   */
  readonly fields: Website_VariablesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Website_Variables.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Website_VariablesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Website_Variables model
   */ 
  interface Website_VariablesFieldRefs {
    readonly website_version: FieldRef<"Website_Variables", 'String'>
    readonly footer_items: FieldRef<"Website_Variables", 'String[]'>
    readonly footer_separator: FieldRef<"Website_Variables", 'String'>
    readonly important_info: FieldRef<"Website_Variables", 'String'>
    readonly rootContentPath: FieldRef<"Website_Variables", 'String'>
    readonly loggedin_nav_items: FieldRef<"Website_Variables", 'MediaType[]'>
    readonly loggedout_nav_items: FieldRef<"Website_Variables", 'MediaType[]'>
  }
    

  // Custom InputTypes
  /**
   * Website_Variables findUnique
   */
  export type Website_VariablesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter, which Website_Variables to fetch.
     */
    where: Website_VariablesWhereUniqueInput
  }

  /**
   * Website_Variables findUniqueOrThrow
   */
  export type Website_VariablesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter, which Website_Variables to fetch.
     */
    where: Website_VariablesWhereUniqueInput
  }

  /**
   * Website_Variables findFirst
   */
  export type Website_VariablesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter, which Website_Variables to fetch.
     */
    where?: Website_VariablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Website_Variables to fetch.
     */
    orderBy?: Website_VariablesOrderByWithRelationInput | Website_VariablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Website_Variables.
     */
    cursor?: Website_VariablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Website_Variables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Website_Variables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Website_Variables.
     */
    distinct?: Website_VariablesScalarFieldEnum | Website_VariablesScalarFieldEnum[]
  }

  /**
   * Website_Variables findFirstOrThrow
   */
  export type Website_VariablesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter, which Website_Variables to fetch.
     */
    where?: Website_VariablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Website_Variables to fetch.
     */
    orderBy?: Website_VariablesOrderByWithRelationInput | Website_VariablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Website_Variables.
     */
    cursor?: Website_VariablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Website_Variables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Website_Variables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Website_Variables.
     */
    distinct?: Website_VariablesScalarFieldEnum | Website_VariablesScalarFieldEnum[]
  }

  /**
   * Website_Variables findMany
   */
  export type Website_VariablesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter, which Website_Variables to fetch.
     */
    where?: Website_VariablesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Website_Variables to fetch.
     */
    orderBy?: Website_VariablesOrderByWithRelationInput | Website_VariablesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Website_Variables.
     */
    cursor?: Website_VariablesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Website_Variables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Website_Variables.
     */
    skip?: number
    distinct?: Website_VariablesScalarFieldEnum | Website_VariablesScalarFieldEnum[]
  }

  /**
   * Website_Variables create
   */
  export type Website_VariablesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * The data needed to create a Website_Variables.
     */
    data: XOR<Website_VariablesCreateInput, Website_VariablesUncheckedCreateInput>
  }

  /**
   * Website_Variables createMany
   */
  export type Website_VariablesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Website_Variables.
     */
    data: Website_VariablesCreateManyInput | Website_VariablesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Website_Variables createManyAndReturn
   */
  export type Website_VariablesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * The data used to create many Website_Variables.
     */
    data: Website_VariablesCreateManyInput | Website_VariablesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Website_Variables update
   */
  export type Website_VariablesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * The data needed to update a Website_Variables.
     */
    data: XOR<Website_VariablesUpdateInput, Website_VariablesUncheckedUpdateInput>
    /**
     * Choose, which Website_Variables to update.
     */
    where: Website_VariablesWhereUniqueInput
  }

  /**
   * Website_Variables updateMany
   */
  export type Website_VariablesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Website_Variables.
     */
    data: XOR<Website_VariablesUpdateManyMutationInput, Website_VariablesUncheckedUpdateManyInput>
    /**
     * Filter which Website_Variables to update
     */
    where?: Website_VariablesWhereInput
    /**
     * Limit how many Website_Variables to update.
     */
    limit?: number
  }

  /**
   * Website_Variables updateManyAndReturn
   */
  export type Website_VariablesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * The data used to update Website_Variables.
     */
    data: XOR<Website_VariablesUpdateManyMutationInput, Website_VariablesUncheckedUpdateManyInput>
    /**
     * Filter which Website_Variables to update
     */
    where?: Website_VariablesWhereInput
    /**
     * Limit how many Website_Variables to update.
     */
    limit?: number
  }

  /**
   * Website_Variables upsert
   */
  export type Website_VariablesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * The filter to search for the Website_Variables to update in case it exists.
     */
    where: Website_VariablesWhereUniqueInput
    /**
     * In case the Website_Variables found by the `where` argument doesn't exist, create a new Website_Variables with this data.
     */
    create: XOR<Website_VariablesCreateInput, Website_VariablesUncheckedCreateInput>
    /**
     * In case the Website_Variables was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Website_VariablesUpdateInput, Website_VariablesUncheckedUpdateInput>
  }

  /**
   * Website_Variables delete
   */
  export type Website_VariablesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
    /**
     * Filter which Website_Variables to delete.
     */
    where: Website_VariablesWhereUniqueInput
  }

  /**
   * Website_Variables deleteMany
   */
  export type Website_VariablesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Website_Variables to delete
     */
    where?: Website_VariablesWhereInput
    /**
     * Limit how many Website_Variables to delete.
     */
    limit?: number
  }

  /**
   * Website_Variables without action
   */
  export type Website_VariablesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website_Variables
     */
    select?: Website_VariablesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website_Variables
     */
    omit?: Website_VariablesOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnimeScalarFieldEnum: {
    animeid: 'animeid',
    description: 'description',
    trailerid: 'trailerid',
    upload_date: 'upload_date',
    release_date: 'release_date',
    likes: 'likes',
    dislikes: 'dislikes',
    activity: 'activity',
    authorid: 'authorid',
    average_rating: 'average_rating',
    anime_ratings: 'anime_ratings',
    age_rating: 'age_rating',
    mangaid: 'mangaid',
    title: 'title',
    type: 'type',
    MediaGenre: 'MediaGenre',
    anime_key_visual: 'anime_key_visual',
    visible: 'visible'
  };

  export type AnimeScalarFieldEnum = (typeof AnimeScalarFieldEnum)[keyof typeof AnimeScalarFieldEnum]


  export const Anime_AuthorsScalarFieldEnum: {
    animeid: 'animeid',
    authorid: 'authorid'
  };

  export type Anime_AuthorsScalarFieldEnum = (typeof Anime_AuthorsScalarFieldEnum)[keyof typeof Anime_AuthorsScalarFieldEnum]


  export const BookmarksScalarFieldEnum: {
    userid: 'userid',
    mediatype: 'mediatype',
    parentid: 'parentid'
  };

  export type BookmarksScalarFieldEnum = (typeof BookmarksScalarFieldEnum)[keyof typeof BookmarksScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    commentid: 'commentid',
    parentid: 'parentid',
    mediatype: 'mediatype',
    mediatime: 'mediatime',
    userid: 'userid',
    comment_text: 'comment_text',
    comment_date: 'comment_date',
    parent_comment_id: 'parent_comment_id',
    likes: 'likes',
    dislikes: 'dislikes'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const ContentGroupScalarFieldEnum: {
    seasonid: 'seasonid',
    season_number: 'season_number',
    release_date: 'release_date',
    visible: 'visible',
    season_path: 'season_path'
  };

  export type ContentGroupScalarFieldEnum = (typeof ContentGroupScalarFieldEnum)[keyof typeof ContentGroupScalarFieldEnum]


  export const ContentGroupMediaScalarFieldEnum: {
    id: 'id',
    seasonid: 'seasonid',
    mediaid: 'mediaid',
    mediatype: 'mediatype'
  };

  export type ContentGroupMediaScalarFieldEnum = (typeof ContentGroupMediaScalarFieldEnum)[keyof typeof ContentGroupMediaScalarFieldEnum]


  export const ContentUnitScalarFieldEnum: {
    episodeid: 'episodeid',
    contentgroupid: 'contentgroupid',
    title: 'title',
    description: 'description',
    release_date: 'release_date',
    likes: 'likes',
    dislikes: 'dislikes',
    visible: 'visible',
    episode_number: 'episode_number',
    views: 'views',
    duration: 'duration',
    episode_path: 'episode_path',
    thumbnail: 'thumbnail'
  };

  export type ContentUnitScalarFieldEnum = (typeof ContentUnitScalarFieldEnum)[keyof typeof ContentUnitScalarFieldEnum]


  export const Disliked_ContentScalarFieldEnum: {
    userid: 'userid',
    contentid: 'contentid',
    mediatype: 'mediatype'
  };

  export type Disliked_ContentScalarFieldEnum = (typeof Disliked_ContentScalarFieldEnum)[keyof typeof Disliked_ContentScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    path: 'path',
    extension: 'extension',
    folderId: 'folderId',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastAccessed: 'lastAccessed',
    isShared: 'isShared',
    ownerId: 'ownerId',
    tags: 'tags',
    checksum: 'checksum',
    downloadCount: 'downloadCount',
    previewEnabled: 'previewEnabled',
    isPublic: 'isPublic',
    filetype: 'filetype',
    location: 'location'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const FileSharesScalarFieldEnum: {
    userId: 'userId',
    fileId: 'fileId',
    accessLevel: 'accessLevel'
  };

  export type FileSharesScalarFieldEnum = (typeof FileSharesScalarFieldEnum)[keyof typeof FileSharesScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastAccessed: 'lastAccessed',
    ownerId: 'ownerId',
    tags: 'tags',
    accessCount: 'accessCount',
    totalSize: 'totalSize',
    parentFolderId: 'parentFolderId',
    filetype: 'filetype',
    location: 'location'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const FolderSharesScalarFieldEnum: {
    userId: 'userId',
    folderId: 'folderId',
    accessLevel: 'accessLevel'
  };

  export type FolderSharesScalarFieldEnum = (typeof FolderSharesScalarFieldEnum)[keyof typeof FolderSharesScalarFieldEnum]


  export const Liked_ContentScalarFieldEnum: {
    userid: 'userid',
    mediatype: 'mediatype',
    contentid: 'contentid'
  };

  export type Liked_ContentScalarFieldEnum = (typeof Liked_ContentScalarFieldEnum)[keyof typeof Liked_ContentScalarFieldEnum]


  export const MangaScalarFieldEnum: {
    mangaid: 'mangaid',
    authorid: 'authorid',
    title: 'title',
    description: 'description',
    release_date: 'release_date',
    cover_iamge: 'cover_iamge',
    likes: 'likes',
    dislikes: 'dislikes',
    age_rating: 'age_rating',
    MediaGenre: 'MediaGenre'
  };

  export type MangaScalarFieldEnum = (typeof MangaScalarFieldEnum)[keyof typeof MangaScalarFieldEnum]


  export const MoviesScalarFieldEnum: {
    movieid: 'movieid',
    title: 'title',
    description: 'description',
    release_date: 'release_date',
    media_id_reference: 'media_id_reference',
    likes: 'likes',
    dislikes: 'dislikes',
    showbanner: 'showbanner',
    age_rating: 'age_rating',
    authorid: 'authorid',
    media_reference_type: 'media_reference_type',
    MediaGenre: 'MediaGenre'
  };

  export type MoviesScalarFieldEnum = (typeof MoviesScalarFieldEnum)[keyof typeof MoviesScalarFieldEnum]


  export const PollsScalarFieldEnum: {
    pollid: 'pollid',
    author: 'author',
    title: 'title',
    description: 'description',
    likes: 'likes',
    dislikes: 'dislikes',
    date: 'date',
    category: 'category',
    status: 'status',
    progress: 'progress',
    views: 'views'
  };

  export type PollsScalarFieldEnum = (typeof PollsScalarFieldEnum)[keyof typeof PollsScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    reviewid: 'reviewid',
    parentid: 'parentid',
    mediatype: 'mediatype',
    userid: 'userid',
    review_text: 'review_text',
    review_date: 'review_date',
    likes: 'likes',
    dislikes: 'dislikes'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const Shopping_CartScalarFieldEnum: {
    userid: 'userid',
    storeid: 'storeid',
    quantity: 'quantity'
  };

  export type Shopping_CartScalarFieldEnum = (typeof Shopping_CartScalarFieldEnum)[keyof typeof Shopping_CartScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    storeid: 'storeid',
    sellerid: 'sellerid',
    title: 'title',
    num_in_stock: 'num_in_stock',
    release_date: 'release_date',
    original_price: 'original_price',
    discount_price: 'discount_price',
    discount_percent: 'discount_percent',
    shipping_price: 'shipping_price',
    description: 'description',
    num_of_carts: 'num_of_carts',
    images: 'images',
    media_id_reference: 'media_id_reference',
    sales: 'sales',
    reference_media_type: 'reference_media_type',
    MediaGenre: 'MediaGenre'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const Subscription_TiersScalarFieldEnum: {
    tierid: 'tierid',
    name: 'name',
    price: 'price',
    votepower: 'votepower',
    cloudlimit: 'cloudlimit',
    icon: 'icon',
    store_discount: 'store_discount',
    game_discount: 'game_discount',
    permissions: 'permissions',
    features: 'features',
    userid: 'userid'
  };

  export type Subscription_TiersScalarFieldEnum = (typeof Subscription_TiersScalarFieldEnum)[keyof typeof Subscription_TiersScalarFieldEnum]


  export const TitleTranslationScalarFieldEnum: {
    translationid: 'translationid',
    parentid: 'parentid',
    mediatype: 'mediatype',
    title: 'title',
    language: 'language'
  };

  export type TitleTranslationScalarFieldEnum = (typeof TitleTranslationScalarFieldEnum)[keyof typeof TitleTranslationScalarFieldEnum]


  export const User_ActivityScalarFieldEnum: {
    userid: 'userid',
    child_content: 'child_content',
    parent_content: 'parent_content',
    mediatype: 'mediatype',
    stopping_point: 'stopping_point',
    date_watched: 'date_watched'
  };

  export type User_ActivityScalarFieldEnum = (typeof User_ActivityScalarFieldEnum)[keyof typeof User_ActivityScalarFieldEnum]


  export const User_BookmarksScalarFieldEnum: {
    userid: 'userid',
    mediatype: 'mediatype',
    parentid: 'parentid'
  };

  export type User_BookmarksScalarFieldEnum = (typeof User_BookmarksScalarFieldEnum)[keyof typeof User_BookmarksScalarFieldEnum]


  export const User_RatingsScalarFieldEnum: {
    userid: 'userid',
    parentid: 'parentid',
    mediatype: 'mediatype',
    rating: 'rating'
  };

  export type User_RatingsScalarFieldEnum = (typeof User_RatingsScalarFieldEnum)[keyof typeof User_RatingsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    userid: 'userid',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    date_joined: 'date_joined',
    num_of_friends: 'num_of_friends',
    num_of_followers: 'num_of_followers',
    profile_picture: 'profile_picture',
    user_bio: 'user_bio',
    two_factor: 'two_factor',
    email_notifications: 'email_notifications',
    push_notifications: 'push_notifications',
    subscriptionTierId: 'subscriptionTierId',
    usedstorage: 'usedstorage',
    accountType: 'accountType'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VideosScalarFieldEnum: {
    videoid: 'videoid',
    title: 'title',
    authorid: 'authorid',
    description: 'description',
    release_date: 'release_date',
    media_type: 'media_type',
    video_banner: 'video_banner',
    likes: 'likes',
    dislikes: 'dislikes',
    duration: 'duration',
    MediaGenre: 'MediaGenre',
    thumbnail: 'thumbnail',
    views: 'views'
  };

  export type VideosScalarFieldEnum = (typeof VideosScalarFieldEnum)[keyof typeof VideosScalarFieldEnum]


  export const Website_VariablesScalarFieldEnum: {
    website_version: 'website_version',
    footer_items: 'footer_items',
    footer_separator: 'footer_separator',
    important_info: 'important_info',
    rootContentPath: 'rootContentPath',
    loggedin_nav_items: 'loggedin_nav_items',
    loggedout_nav_items: 'loggedout_nav_items'
  };

  export type Website_VariablesScalarFieldEnum = (typeof Website_VariablesScalarFieldEnum)[keyof typeof Website_VariablesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AgeRating'
   */
  export type EnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating'>
    


  /**
   * Reference to a field of type 'AgeRating[]'
   */
  export type ListEnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'MediaGenre[]'
   */
  export type ListEnumMediaGenreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaGenre[]'>
    


  /**
   * Reference to a field of type 'MediaGenre'
   */
  export type EnumMediaGenreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaGenre'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'navItems[]'
   */
  export type ListEnumnavItemsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'navItems[]'>
    


  /**
   * Reference to a field of type 'navItems'
   */
  export type EnumnavItemsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'navItems'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    
  /**
   * Deep Input Types
   */


  export type AnimeWhereInput = {
    AND?: AnimeWhereInput | AnimeWhereInput[]
    OR?: AnimeWhereInput[]
    NOT?: AnimeWhereInput | AnimeWhereInput[]
    animeid?: StringFilter<"Anime"> | string
    description?: StringNullableFilter<"Anime"> | string | null
    trailerid?: StringNullableFilter<"Anime"> | string | null
    upload_date?: DateTimeNullableFilter<"Anime"> | Date | string | null
    release_date?: DateTimeFilter<"Anime"> | Date | string
    likes?: BigIntFilter<"Anime"> | bigint | number
    dislikes?: BigIntFilter<"Anime"> | bigint | number
    activity?: IntFilter<"Anime"> | number
    authorid?: StringFilter<"Anime"> | string
    average_rating?: FloatFilter<"Anime"> | number
    anime_ratings?: IntFilter<"Anime"> | number
    age_rating?: EnumAgeRatingFilter<"Anime"> | $Enums.AgeRating
    mangaid?: StringNullableFilter<"Anime"> | string | null
    title?: StringFilter<"Anime"> | string
    type?: EnumMediaTypeFilter<"Anime"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Anime">
    anime_key_visual?: StringNullableFilter<"Anime"> | string | null
    visible?: BoolFilter<"Anime"> | boolean
    Manga?: XOR<MangaNullableScalarRelationFilter, MangaWhereInput> | null
    Videos?: XOR<VideosNullableScalarRelationFilter, VideosWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Anime_Authors?: Anime_AuthorsListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }

  export type AnimeOrderByWithRelationInput = {
    animeid?: SortOrder
    description?: SortOrderInput | SortOrder
    trailerid?: SortOrderInput | SortOrder
    upload_date?: SortOrderInput | SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    authorid?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
    age_rating?: SortOrder
    mangaid?: SortOrderInput | SortOrder
    title?: SortOrder
    type?: SortOrder
    MediaGenre?: SortOrder
    anime_key_visual?: SortOrderInput | SortOrder
    visible?: SortOrder
    Manga?: MangaOrderByWithRelationInput
    Videos?: VideosOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    Anime_Authors?: Anime_AuthorsOrderByRelationAggregateInput
    Bookmarks?: BookmarksOrderByRelationAggregateInput
    ContentGroupLinks?: ContentGroupMediaOrderByRelationAggregateInput
  }

  export type AnimeWhereUniqueInput = Prisma.AtLeast<{
    animeid?: string
    AND?: AnimeWhereInput | AnimeWhereInput[]
    OR?: AnimeWhereInput[]
    NOT?: AnimeWhereInput | AnimeWhereInput[]
    description?: StringNullableFilter<"Anime"> | string | null
    trailerid?: StringNullableFilter<"Anime"> | string | null
    upload_date?: DateTimeNullableFilter<"Anime"> | Date | string | null
    release_date?: DateTimeFilter<"Anime"> | Date | string
    likes?: BigIntFilter<"Anime"> | bigint | number
    dislikes?: BigIntFilter<"Anime"> | bigint | number
    activity?: IntFilter<"Anime"> | number
    authorid?: StringFilter<"Anime"> | string
    average_rating?: FloatFilter<"Anime"> | number
    anime_ratings?: IntFilter<"Anime"> | number
    age_rating?: EnumAgeRatingFilter<"Anime"> | $Enums.AgeRating
    mangaid?: StringNullableFilter<"Anime"> | string | null
    title?: StringFilter<"Anime"> | string
    type?: EnumMediaTypeFilter<"Anime"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Anime">
    anime_key_visual?: StringNullableFilter<"Anime"> | string | null
    visible?: BoolFilter<"Anime"> | boolean
    Manga?: XOR<MangaNullableScalarRelationFilter, MangaWhereInput> | null
    Videos?: XOR<VideosNullableScalarRelationFilter, VideosWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Anime_Authors?: Anime_AuthorsListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }, "animeid">

  export type AnimeOrderByWithAggregationInput = {
    animeid?: SortOrder
    description?: SortOrderInput | SortOrder
    trailerid?: SortOrderInput | SortOrder
    upload_date?: SortOrderInput | SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    authorid?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
    age_rating?: SortOrder
    mangaid?: SortOrderInput | SortOrder
    title?: SortOrder
    type?: SortOrder
    MediaGenre?: SortOrder
    anime_key_visual?: SortOrderInput | SortOrder
    visible?: SortOrder
    _count?: AnimeCountOrderByAggregateInput
    _avg?: AnimeAvgOrderByAggregateInput
    _max?: AnimeMaxOrderByAggregateInput
    _min?: AnimeMinOrderByAggregateInput
    _sum?: AnimeSumOrderByAggregateInput
  }

  export type AnimeScalarWhereWithAggregatesInput = {
    AND?: AnimeScalarWhereWithAggregatesInput | AnimeScalarWhereWithAggregatesInput[]
    OR?: AnimeScalarWhereWithAggregatesInput[]
    NOT?: AnimeScalarWhereWithAggregatesInput | AnimeScalarWhereWithAggregatesInput[]
    animeid?: StringWithAggregatesFilter<"Anime"> | string
    description?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    trailerid?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    upload_date?: DateTimeNullableWithAggregatesFilter<"Anime"> | Date | string | null
    release_date?: DateTimeWithAggregatesFilter<"Anime"> | Date | string
    likes?: BigIntWithAggregatesFilter<"Anime"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Anime"> | bigint | number
    activity?: IntWithAggregatesFilter<"Anime"> | number
    authorid?: StringWithAggregatesFilter<"Anime"> | string
    average_rating?: FloatWithAggregatesFilter<"Anime"> | number
    anime_ratings?: IntWithAggregatesFilter<"Anime"> | number
    age_rating?: EnumAgeRatingWithAggregatesFilter<"Anime"> | $Enums.AgeRating
    mangaid?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    title?: StringWithAggregatesFilter<"Anime"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"Anime"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Anime">
    anime_key_visual?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    visible?: BoolWithAggregatesFilter<"Anime"> | boolean
  }

  export type Anime_AuthorsWhereInput = {
    AND?: Anime_AuthorsWhereInput | Anime_AuthorsWhereInput[]
    OR?: Anime_AuthorsWhereInput[]
    NOT?: Anime_AuthorsWhereInput | Anime_AuthorsWhereInput[]
    animeid?: StringFilter<"Anime_Authors"> | string
    authorid?: StringFilter<"Anime_Authors"> | string
    Anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type Anime_AuthorsOrderByWithRelationInput = {
    animeid?: SortOrder
    authorid?: SortOrder
    Anime?: AnimeOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type Anime_AuthorsWhereUniqueInput = Prisma.AtLeast<{
    animeid_authorid?: Anime_AuthorsAnimeidAuthoridCompoundUniqueInput
    AND?: Anime_AuthorsWhereInput | Anime_AuthorsWhereInput[]
    OR?: Anime_AuthorsWhereInput[]
    NOT?: Anime_AuthorsWhereInput | Anime_AuthorsWhereInput[]
    animeid?: StringFilter<"Anime_Authors"> | string
    authorid?: StringFilter<"Anime_Authors"> | string
    Anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "animeid_authorid">

  export type Anime_AuthorsOrderByWithAggregationInput = {
    animeid?: SortOrder
    authorid?: SortOrder
    _count?: Anime_AuthorsCountOrderByAggregateInput
    _max?: Anime_AuthorsMaxOrderByAggregateInput
    _min?: Anime_AuthorsMinOrderByAggregateInput
  }

  export type Anime_AuthorsScalarWhereWithAggregatesInput = {
    AND?: Anime_AuthorsScalarWhereWithAggregatesInput | Anime_AuthorsScalarWhereWithAggregatesInput[]
    OR?: Anime_AuthorsScalarWhereWithAggregatesInput[]
    NOT?: Anime_AuthorsScalarWhereWithAggregatesInput | Anime_AuthorsScalarWhereWithAggregatesInput[]
    animeid?: StringWithAggregatesFilter<"Anime_Authors"> | string
    authorid?: StringWithAggregatesFilter<"Anime_Authors"> | string
  }

  export type BookmarksWhereInput = {
    AND?: BookmarksWhereInput | BookmarksWhereInput[]
    OR?: BookmarksWhereInput[]
    NOT?: BookmarksWhereInput | BookmarksWhereInput[]
    userid?: StringFilter<"Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"Bookmarks"> | string
    Anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    Manga?: XOR<MangaScalarRelationFilter, MangaWhereInput>
    Movies?: XOR<MoviesScalarRelationFilter, MoviesWhereInput>
    Videos?: XOR<VideosScalarRelationFilter, VideosWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type BookmarksOrderByWithRelationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
    Anime?: AnimeOrderByWithRelationInput
    Manga?: MangaOrderByWithRelationInput
    Movies?: MoviesOrderByWithRelationInput
    Videos?: VideosOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type BookmarksWhereUniqueInput = Prisma.AtLeast<{
    userid_parentid_mediatype?: BookmarksUseridParentidMediatypeCompoundUniqueInput
    AND?: BookmarksWhereInput | BookmarksWhereInput[]
    OR?: BookmarksWhereInput[]
    NOT?: BookmarksWhereInput | BookmarksWhereInput[]
    userid?: StringFilter<"Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"Bookmarks"> | string
    Anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    Manga?: XOR<MangaScalarRelationFilter, MangaWhereInput>
    Movies?: XOR<MoviesScalarRelationFilter, MoviesWhereInput>
    Videos?: XOR<VideosScalarRelationFilter, VideosWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_parentid_mediatype">

  export type BookmarksOrderByWithAggregationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
    _count?: BookmarksCountOrderByAggregateInput
    _max?: BookmarksMaxOrderByAggregateInput
    _min?: BookmarksMinOrderByAggregateInput
  }

  export type BookmarksScalarWhereWithAggregatesInput = {
    AND?: BookmarksScalarWhereWithAggregatesInput | BookmarksScalarWhereWithAggregatesInput[]
    OR?: BookmarksScalarWhereWithAggregatesInput[]
    NOT?: BookmarksScalarWhereWithAggregatesInput | BookmarksScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"Bookmarks"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"Bookmarks"> | $Enums.MediaType
    parentid?: StringWithAggregatesFilter<"Bookmarks"> | string
  }

  export type CommentsWhereInput = {
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    commentid?: IntFilter<"Comments"> | number
    parentid?: StringFilter<"Comments"> | string
    mediatype?: EnumMediaTypeFilter<"Comments"> | $Enums.MediaType
    mediatime?: IntFilter<"Comments"> | number
    userid?: StringFilter<"Comments"> | string
    comment_text?: StringFilter<"Comments"> | string
    comment_date?: DateTimeFilter<"Comments"> | Date | string
    parent_comment_id?: IntNullableFilter<"Comments"> | number | null
    likes?: BigIntFilter<"Comments"> | bigint | number
    dislikes?: BigIntFilter<"Comments"> | bigint | number
    ContentUnit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
    Videos?: XOR<VideosScalarRelationFilter, VideosWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type CommentsOrderByWithRelationInput = {
    commentid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    mediatime?: SortOrder
    userid?: SortOrder
    comment_text?: SortOrder
    comment_date?: SortOrder
    parent_comment_id?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    ContentUnit?: ContentUnitOrderByWithRelationInput
    Videos?: VideosOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type CommentsWhereUniqueInput = Prisma.AtLeast<{
    commentid?: number
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    parentid?: StringFilter<"Comments"> | string
    mediatype?: EnumMediaTypeFilter<"Comments"> | $Enums.MediaType
    mediatime?: IntFilter<"Comments"> | number
    userid?: StringFilter<"Comments"> | string
    comment_text?: StringFilter<"Comments"> | string
    comment_date?: DateTimeFilter<"Comments"> | Date | string
    parent_comment_id?: IntNullableFilter<"Comments"> | number | null
    likes?: BigIntFilter<"Comments"> | bigint | number
    dislikes?: BigIntFilter<"Comments"> | bigint | number
    ContentUnit?: XOR<ContentUnitScalarRelationFilter, ContentUnitWhereInput>
    Videos?: XOR<VideosScalarRelationFilter, VideosWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "commentid">

  export type CommentsOrderByWithAggregationInput = {
    commentid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    mediatime?: SortOrder
    userid?: SortOrder
    comment_text?: SortOrder
    comment_date?: SortOrder
    parent_comment_id?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    _count?: CommentsCountOrderByAggregateInput
    _avg?: CommentsAvgOrderByAggregateInput
    _max?: CommentsMaxOrderByAggregateInput
    _min?: CommentsMinOrderByAggregateInput
    _sum?: CommentsSumOrderByAggregateInput
  }

  export type CommentsScalarWhereWithAggregatesInput = {
    AND?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    OR?: CommentsScalarWhereWithAggregatesInput[]
    NOT?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    commentid?: IntWithAggregatesFilter<"Comments"> | number
    parentid?: StringWithAggregatesFilter<"Comments"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"Comments"> | $Enums.MediaType
    mediatime?: IntWithAggregatesFilter<"Comments"> | number
    userid?: StringWithAggregatesFilter<"Comments"> | string
    comment_text?: StringWithAggregatesFilter<"Comments"> | string
    comment_date?: DateTimeWithAggregatesFilter<"Comments"> | Date | string
    parent_comment_id?: IntNullableWithAggregatesFilter<"Comments"> | number | null
    likes?: BigIntWithAggregatesFilter<"Comments"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Comments"> | bigint | number
  }

  export type ContentGroupWhereInput = {
    AND?: ContentGroupWhereInput | ContentGroupWhereInput[]
    OR?: ContentGroupWhereInput[]
    NOT?: ContentGroupWhereInput | ContentGroupWhereInput[]
    seasonid?: StringFilter<"ContentGroup"> | string
    season_number?: IntFilter<"ContentGroup"> | number
    release_date?: DateTimeFilter<"ContentGroup"> | Date | string
    visible?: BoolFilter<"ContentGroup"> | boolean
    season_path?: StringFilter<"ContentGroup"> | string
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }

  export type ContentGroupOrderByWithRelationInput = {
    seasonid?: SortOrder
    season_number?: SortOrder
    release_date?: SortOrder
    visible?: SortOrder
    season_path?: SortOrder
    ContentGroupLinks?: ContentGroupMediaOrderByRelationAggregateInput
  }

  export type ContentGroupWhereUniqueInput = Prisma.AtLeast<{
    seasonid?: string
    AND?: ContentGroupWhereInput | ContentGroupWhereInput[]
    OR?: ContentGroupWhereInput[]
    NOT?: ContentGroupWhereInput | ContentGroupWhereInput[]
    season_number?: IntFilter<"ContentGroup"> | number
    release_date?: DateTimeFilter<"ContentGroup"> | Date | string
    visible?: BoolFilter<"ContentGroup"> | boolean
    season_path?: StringFilter<"ContentGroup"> | string
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }, "seasonid">

  export type ContentGroupOrderByWithAggregationInput = {
    seasonid?: SortOrder
    season_number?: SortOrder
    release_date?: SortOrder
    visible?: SortOrder
    season_path?: SortOrder
    _count?: ContentGroupCountOrderByAggregateInput
    _avg?: ContentGroupAvgOrderByAggregateInput
    _max?: ContentGroupMaxOrderByAggregateInput
    _min?: ContentGroupMinOrderByAggregateInput
    _sum?: ContentGroupSumOrderByAggregateInput
  }

  export type ContentGroupScalarWhereWithAggregatesInput = {
    AND?: ContentGroupScalarWhereWithAggregatesInput | ContentGroupScalarWhereWithAggregatesInput[]
    OR?: ContentGroupScalarWhereWithAggregatesInput[]
    NOT?: ContentGroupScalarWhereWithAggregatesInput | ContentGroupScalarWhereWithAggregatesInput[]
    seasonid?: StringWithAggregatesFilter<"ContentGroup"> | string
    season_number?: IntWithAggregatesFilter<"ContentGroup"> | number
    release_date?: DateTimeWithAggregatesFilter<"ContentGroup"> | Date | string
    visible?: BoolWithAggregatesFilter<"ContentGroup"> | boolean
    season_path?: StringWithAggregatesFilter<"ContentGroup"> | string
  }

  export type ContentGroupMediaWhereInput = {
    AND?: ContentGroupMediaWhereInput | ContentGroupMediaWhereInput[]
    OR?: ContentGroupMediaWhereInput[]
    NOT?: ContentGroupMediaWhereInput | ContentGroupMediaWhereInput[]
    id?: StringFilter<"ContentGroupMedia"> | string
    seasonid?: StringFilter<"ContentGroupMedia"> | string
    mediaid?: StringFilter<"ContentGroupMedia"> | string
    mediatype?: EnumMediaTypeFilter<"ContentGroupMedia"> | $Enums.MediaType
    Anime?: XOR<AnimeNullableScalarRelationFilter, AnimeWhereInput> | null
    Manga?: XOR<MangaNullableScalarRelationFilter, MangaWhereInput> | null
    Movies?: XOR<MoviesNullableScalarRelationFilter, MoviesWhereInput> | null
    ContentGroup?: XOR<ContentGroupScalarRelationFilter, ContentGroupWhereInput>
    ContentUnits?: ContentUnitListRelationFilter
  }

  export type ContentGroupMediaOrderByWithRelationInput = {
    id?: SortOrder
    seasonid?: SortOrder
    mediaid?: SortOrder
    mediatype?: SortOrder
    Anime?: AnimeOrderByWithRelationInput
    Manga?: MangaOrderByWithRelationInput
    Movies?: MoviesOrderByWithRelationInput
    ContentGroup?: ContentGroupOrderByWithRelationInput
    ContentUnits?: ContentUnitOrderByRelationAggregateInput
  }

  export type ContentGroupMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seasonid_mediaid_mediatype?: ContentGroupMediaSeasonidMediaidMediatypeCompoundUniqueInput
    AND?: ContentGroupMediaWhereInput | ContentGroupMediaWhereInput[]
    OR?: ContentGroupMediaWhereInput[]
    NOT?: ContentGroupMediaWhereInput | ContentGroupMediaWhereInput[]
    seasonid?: StringFilter<"ContentGroupMedia"> | string
    mediaid?: StringFilter<"ContentGroupMedia"> | string
    mediatype?: EnumMediaTypeFilter<"ContentGroupMedia"> | $Enums.MediaType
    Anime?: XOR<AnimeNullableScalarRelationFilter, AnimeWhereInput> | null
    Manga?: XOR<MangaNullableScalarRelationFilter, MangaWhereInput> | null
    Movies?: XOR<MoviesNullableScalarRelationFilter, MoviesWhereInput> | null
    ContentGroup?: XOR<ContentGroupScalarRelationFilter, ContentGroupWhereInput>
    ContentUnits?: ContentUnitListRelationFilter
  }, "id" | "seasonid_mediaid_mediatype">

  export type ContentGroupMediaOrderByWithAggregationInput = {
    id?: SortOrder
    seasonid?: SortOrder
    mediaid?: SortOrder
    mediatype?: SortOrder
    _count?: ContentGroupMediaCountOrderByAggregateInput
    _max?: ContentGroupMediaMaxOrderByAggregateInput
    _min?: ContentGroupMediaMinOrderByAggregateInput
  }

  export type ContentGroupMediaScalarWhereWithAggregatesInput = {
    AND?: ContentGroupMediaScalarWhereWithAggregatesInput | ContentGroupMediaScalarWhereWithAggregatesInput[]
    OR?: ContentGroupMediaScalarWhereWithAggregatesInput[]
    NOT?: ContentGroupMediaScalarWhereWithAggregatesInput | ContentGroupMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentGroupMedia"> | string
    seasonid?: StringWithAggregatesFilter<"ContentGroupMedia"> | string
    mediaid?: StringWithAggregatesFilter<"ContentGroupMedia"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"ContentGroupMedia"> | $Enums.MediaType
  }

  export type ContentUnitWhereInput = {
    AND?: ContentUnitWhereInput | ContentUnitWhereInput[]
    OR?: ContentUnitWhereInput[]
    NOT?: ContentUnitWhereInput | ContentUnitWhereInput[]
    episodeid?: StringFilter<"ContentUnit"> | string
    contentgroupid?: StringFilter<"ContentUnit"> | string
    title?: StringFilter<"ContentUnit"> | string
    description?: StringFilter<"ContentUnit"> | string
    release_date?: DateTimeNullableFilter<"ContentUnit"> | Date | string | null
    likes?: BigIntFilter<"ContentUnit"> | bigint | number
    dislikes?: BigIntFilter<"ContentUnit"> | bigint | number
    visible?: BoolFilter<"ContentUnit"> | boolean
    episode_number?: FloatFilter<"ContentUnit"> | number
    views?: IntFilter<"ContentUnit"> | number
    duration?: IntFilter<"ContentUnit"> | number
    episode_path?: StringFilter<"ContentUnit"> | string
    thumbnail?: StringFilter<"ContentUnit"> | string
    Comments?: CommentsListRelationFilter
    ContentGroupMedia?: XOR<ContentGroupMediaScalarRelationFilter, ContentGroupMediaWhereInput>
  }

  export type ContentUnitOrderByWithRelationInput = {
    episodeid?: SortOrder
    contentgroupid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    visible?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
    episode_path?: SortOrder
    thumbnail?: SortOrder
    Comments?: CommentsOrderByRelationAggregateInput
    ContentGroupMedia?: ContentGroupMediaOrderByWithRelationInput
  }

  export type ContentUnitWhereUniqueInput = Prisma.AtLeast<{
    episodeid?: string
    AND?: ContentUnitWhereInput | ContentUnitWhereInput[]
    OR?: ContentUnitWhereInput[]
    NOT?: ContentUnitWhereInput | ContentUnitWhereInput[]
    contentgroupid?: StringFilter<"ContentUnit"> | string
    title?: StringFilter<"ContentUnit"> | string
    description?: StringFilter<"ContentUnit"> | string
    release_date?: DateTimeNullableFilter<"ContentUnit"> | Date | string | null
    likes?: BigIntFilter<"ContentUnit"> | bigint | number
    dislikes?: BigIntFilter<"ContentUnit"> | bigint | number
    visible?: BoolFilter<"ContentUnit"> | boolean
    episode_number?: FloatFilter<"ContentUnit"> | number
    views?: IntFilter<"ContentUnit"> | number
    duration?: IntFilter<"ContentUnit"> | number
    episode_path?: StringFilter<"ContentUnit"> | string
    thumbnail?: StringFilter<"ContentUnit"> | string
    Comments?: CommentsListRelationFilter
    ContentGroupMedia?: XOR<ContentGroupMediaScalarRelationFilter, ContentGroupMediaWhereInput>
  }, "episodeid">

  export type ContentUnitOrderByWithAggregationInput = {
    episodeid?: SortOrder
    contentgroupid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    visible?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
    episode_path?: SortOrder
    thumbnail?: SortOrder
    _count?: ContentUnitCountOrderByAggregateInput
    _avg?: ContentUnitAvgOrderByAggregateInput
    _max?: ContentUnitMaxOrderByAggregateInput
    _min?: ContentUnitMinOrderByAggregateInput
    _sum?: ContentUnitSumOrderByAggregateInput
  }

  export type ContentUnitScalarWhereWithAggregatesInput = {
    AND?: ContentUnitScalarWhereWithAggregatesInput | ContentUnitScalarWhereWithAggregatesInput[]
    OR?: ContentUnitScalarWhereWithAggregatesInput[]
    NOT?: ContentUnitScalarWhereWithAggregatesInput | ContentUnitScalarWhereWithAggregatesInput[]
    episodeid?: StringWithAggregatesFilter<"ContentUnit"> | string
    contentgroupid?: StringWithAggregatesFilter<"ContentUnit"> | string
    title?: StringWithAggregatesFilter<"ContentUnit"> | string
    description?: StringWithAggregatesFilter<"ContentUnit"> | string
    release_date?: DateTimeNullableWithAggregatesFilter<"ContentUnit"> | Date | string | null
    likes?: BigIntWithAggregatesFilter<"ContentUnit"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"ContentUnit"> | bigint | number
    visible?: BoolWithAggregatesFilter<"ContentUnit"> | boolean
    episode_number?: FloatWithAggregatesFilter<"ContentUnit"> | number
    views?: IntWithAggregatesFilter<"ContentUnit"> | number
    duration?: IntWithAggregatesFilter<"ContentUnit"> | number
    episode_path?: StringWithAggregatesFilter<"ContentUnit"> | string
    thumbnail?: StringWithAggregatesFilter<"ContentUnit"> | string
  }

  export type Disliked_ContentWhereInput = {
    AND?: Disliked_ContentWhereInput | Disliked_ContentWhereInput[]
    OR?: Disliked_ContentWhereInput[]
    NOT?: Disliked_ContentWhereInput | Disliked_ContentWhereInput[]
    userid?: StringFilter<"Disliked_Content"> | string
    contentid?: IntFilter<"Disliked_Content"> | number
    mediatype?: EnumMediaTypeFilter<"Disliked_Content"> | $Enums.MediaType
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type Disliked_ContentOrderByWithRelationInput = {
    userid?: SortOrder
    contentid?: SortOrder
    mediatype?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type Disliked_ContentWhereUniqueInput = Prisma.AtLeast<{
    userid_contentid_mediatype?: Disliked_ContentUseridContentidMediatypeCompoundUniqueInput
    AND?: Disliked_ContentWhereInput | Disliked_ContentWhereInput[]
    OR?: Disliked_ContentWhereInput[]
    NOT?: Disliked_ContentWhereInput | Disliked_ContentWhereInput[]
    userid?: StringFilter<"Disliked_Content"> | string
    contentid?: IntFilter<"Disliked_Content"> | number
    mediatype?: EnumMediaTypeFilter<"Disliked_Content"> | $Enums.MediaType
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_contentid_mediatype">

  export type Disliked_ContentOrderByWithAggregationInput = {
    userid?: SortOrder
    contentid?: SortOrder
    mediatype?: SortOrder
    _count?: Disliked_ContentCountOrderByAggregateInput
    _avg?: Disliked_ContentAvgOrderByAggregateInput
    _max?: Disliked_ContentMaxOrderByAggregateInput
    _min?: Disliked_ContentMinOrderByAggregateInput
    _sum?: Disliked_ContentSumOrderByAggregateInput
  }

  export type Disliked_ContentScalarWhereWithAggregatesInput = {
    AND?: Disliked_ContentScalarWhereWithAggregatesInput | Disliked_ContentScalarWhereWithAggregatesInput[]
    OR?: Disliked_ContentScalarWhereWithAggregatesInput[]
    NOT?: Disliked_ContentScalarWhereWithAggregatesInput | Disliked_ContentScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"Disliked_Content"> | string
    contentid?: IntWithAggregatesFilter<"Disliked_Content"> | number
    mediatype?: EnumMediaTypeWithAggregatesFilter<"Disliked_Content"> | $Enums.MediaType
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    path?: StringFilter<"File"> | string
    extension?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    size?: BigIntFilter<"File"> | bigint | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"File"> | Date | string | null
    isShared?: BoolFilter<"File"> | boolean
    ownerId?: StringFilter<"File"> | string
    tags?: StringNullableListFilter<"File">
    checksum?: StringNullableFilter<"File"> | string | null
    downloadCount?: IntFilter<"File"> | number
    previewEnabled?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    filetype?: EnumFileTypeFilter<"File"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    Folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    FileShares?: FileSharesListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    path?: SortOrder
    extension?: SortOrder
    folderId?: SortOrderInput | SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrderInput | SortOrder
    isShared?: SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    checksum?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    previewEnabled?: SortOrder
    isPublic?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
    Folder?: FolderOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    FileShares?: FileSharesOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId_folderId_name?: FileOwnerIdFolderIdNameCompoundUniqueInput
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    path?: StringFilter<"File"> | string
    extension?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    size?: BigIntFilter<"File"> | bigint | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"File"> | Date | string | null
    isShared?: BoolFilter<"File"> | boolean
    ownerId?: StringFilter<"File"> | string
    tags?: StringNullableListFilter<"File">
    checksum?: StringNullableFilter<"File"> | string | null
    downloadCount?: IntFilter<"File"> | number
    previewEnabled?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    filetype?: EnumFileTypeFilter<"File"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    Folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    FileShares?: FileSharesListRelationFilter
  }, "id" | "ownerId_folderId_name">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    path?: SortOrder
    extension?: SortOrder
    folderId?: SortOrderInput | SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrderInput | SortOrder
    isShared?: SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    checksum?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    previewEnabled?: SortOrder
    isPublic?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    description?: StringNullableWithAggregatesFilter<"File"> | string | null
    path?: StringWithAggregatesFilter<"File"> | string
    extension?: StringWithAggregatesFilter<"File"> | string
    folderId?: StringNullableWithAggregatesFilter<"File"> | string | null
    size?: BigIntWithAggregatesFilter<"File"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
    lastAccessed?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
    isShared?: BoolWithAggregatesFilter<"File"> | boolean
    ownerId?: StringWithAggregatesFilter<"File"> | string
    tags?: StringNullableListFilter<"File">
    checksum?: StringNullableWithAggregatesFilter<"File"> | string | null
    downloadCount?: IntWithAggregatesFilter<"File"> | number
    previewEnabled?: BoolWithAggregatesFilter<"File"> | boolean
    isPublic?: BoolWithAggregatesFilter<"File"> | boolean
    filetype?: EnumFileTypeWithAggregatesFilter<"File"> | $Enums.FileType
    location?: EnumMediaTypeWithAggregatesFilter<"File"> | $Enums.MediaType
  }

  export type FileSharesWhereInput = {
    AND?: FileSharesWhereInput | FileSharesWhereInput[]
    OR?: FileSharesWhereInput[]
    NOT?: FileSharesWhereInput | FileSharesWhereInput[]
    userId?: StringFilter<"FileShares"> | string
    fileId?: StringFilter<"FileShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FileShares"> | $Enums.AccessLevel
    File?: XOR<FileScalarRelationFilter, FileWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type FileSharesOrderByWithRelationInput = {
    userId?: SortOrder
    fileId?: SortOrder
    accessLevel?: SortOrder
    File?: FileOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type FileSharesWhereUniqueInput = Prisma.AtLeast<{
    userId_fileId?: FileSharesUserIdFileIdCompoundUniqueInput
    AND?: FileSharesWhereInput | FileSharesWhereInput[]
    OR?: FileSharesWhereInput[]
    NOT?: FileSharesWhereInput | FileSharesWhereInput[]
    userId?: StringFilter<"FileShares"> | string
    fileId?: StringFilter<"FileShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FileShares"> | $Enums.AccessLevel
    File?: XOR<FileScalarRelationFilter, FileWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_fileId">

  export type FileSharesOrderByWithAggregationInput = {
    userId?: SortOrder
    fileId?: SortOrder
    accessLevel?: SortOrder
    _count?: FileSharesCountOrderByAggregateInput
    _max?: FileSharesMaxOrderByAggregateInput
    _min?: FileSharesMinOrderByAggregateInput
  }

  export type FileSharesScalarWhereWithAggregatesInput = {
    AND?: FileSharesScalarWhereWithAggregatesInput | FileSharesScalarWhereWithAggregatesInput[]
    OR?: FileSharesScalarWhereWithAggregatesInput[]
    NOT?: FileSharesScalarWhereWithAggregatesInput | FileSharesScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"FileShares"> | string
    fileId?: StringWithAggregatesFilter<"FileShares"> | string
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"FileShares"> | $Enums.AccessLevel
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"Folder"> | Date | string | null
    ownerId?: StringFilter<"Folder"> | string
    tags?: StringNullableListFilter<"Folder">
    accessCount?: IntFilter<"Folder"> | number
    totalSize?: IntFilter<"Folder"> | number
    parentFolderId?: StringNullableFilter<"Folder"> | string | null
    filetype?: EnumFileTypeFilter<"Folder"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"Folder"> | $Enums.MediaType
    File?: FileListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    other_Folder?: FolderListRelationFilter
    FolderShares?: FolderSharesListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    accessCount?: SortOrder
    totalSize?: SortOrder
    parentFolderId?: SortOrderInput | SortOrder
    filetype?: SortOrder
    location?: SortOrder
    File?: FileOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
    Folder?: FolderOrderByWithRelationInput
    other_Folder?: FolderOrderByRelationAggregateInput
    FolderShares?: FolderSharesOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId_id?: FolderOwnerIdIdCompoundUniqueInput
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"Folder"> | Date | string | null
    ownerId?: StringFilter<"Folder"> | string
    tags?: StringNullableListFilter<"Folder">
    accessCount?: IntFilter<"Folder"> | number
    totalSize?: IntFilter<"Folder"> | number
    parentFolderId?: StringNullableFilter<"Folder"> | string | null
    filetype?: EnumFileTypeFilter<"Folder"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"Folder"> | $Enums.MediaType
    File?: FileListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    other_Folder?: FolderListRelationFilter
    FolderShares?: FolderSharesListRelationFilter
  }, "id" | "ownerId_id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    accessCount?: SortOrder
    totalSize?: SortOrder
    parentFolderId?: SortOrderInput | SortOrder
    filetype?: SortOrder
    location?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _avg?: FolderAvgOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
    _sum?: FolderSumOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    description?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Folder"> | Date | string | null
    lastAccessed?: DateTimeNullableWithAggregatesFilter<"Folder"> | Date | string | null
    ownerId?: StringWithAggregatesFilter<"Folder"> | string
    tags?: StringNullableListFilter<"Folder">
    accessCount?: IntWithAggregatesFilter<"Folder"> | number
    totalSize?: IntWithAggregatesFilter<"Folder"> | number
    parentFolderId?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    filetype?: EnumFileTypeWithAggregatesFilter<"Folder"> | $Enums.FileType
    location?: EnumMediaTypeWithAggregatesFilter<"Folder"> | $Enums.MediaType
  }

  export type FolderSharesWhereInput = {
    AND?: FolderSharesWhereInput | FolderSharesWhereInput[]
    OR?: FolderSharesWhereInput[]
    NOT?: FolderSharesWhereInput | FolderSharesWhereInput[]
    userId?: StringFilter<"FolderShares"> | string
    folderId?: StringFilter<"FolderShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FolderShares"> | $Enums.AccessLevel
    Folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type FolderSharesOrderByWithRelationInput = {
    userId?: SortOrder
    folderId?: SortOrder
    accessLevel?: SortOrder
    Folder?: FolderOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type FolderSharesWhereUniqueInput = Prisma.AtLeast<{
    userId_folderId?: FolderSharesUserIdFolderIdCompoundUniqueInput
    AND?: FolderSharesWhereInput | FolderSharesWhereInput[]
    OR?: FolderSharesWhereInput[]
    NOT?: FolderSharesWhereInput | FolderSharesWhereInput[]
    userId?: StringFilter<"FolderShares"> | string
    folderId?: StringFilter<"FolderShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FolderShares"> | $Enums.AccessLevel
    Folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userId_folderId">

  export type FolderSharesOrderByWithAggregationInput = {
    userId?: SortOrder
    folderId?: SortOrder
    accessLevel?: SortOrder
    _count?: FolderSharesCountOrderByAggregateInput
    _max?: FolderSharesMaxOrderByAggregateInput
    _min?: FolderSharesMinOrderByAggregateInput
  }

  export type FolderSharesScalarWhereWithAggregatesInput = {
    AND?: FolderSharesScalarWhereWithAggregatesInput | FolderSharesScalarWhereWithAggregatesInput[]
    OR?: FolderSharesScalarWhereWithAggregatesInput[]
    NOT?: FolderSharesScalarWhereWithAggregatesInput | FolderSharesScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"FolderShares"> | string
    folderId?: StringWithAggregatesFilter<"FolderShares"> | string
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"FolderShares"> | $Enums.AccessLevel
  }

  export type Liked_ContentWhereInput = {
    AND?: Liked_ContentWhereInput | Liked_ContentWhereInput[]
    OR?: Liked_ContentWhereInput[]
    NOT?: Liked_ContentWhereInput | Liked_ContentWhereInput[]
    userid?: StringFilter<"Liked_Content"> | string
    mediatype?: EnumMediaTypeFilter<"Liked_Content"> | $Enums.MediaType
    contentid?: IntFilter<"Liked_Content"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type Liked_ContentOrderByWithRelationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    contentid?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type Liked_ContentWhereUniqueInput = Prisma.AtLeast<{
    userid_contentid_mediatype?: Liked_ContentUseridContentidMediatypeCompoundUniqueInput
    AND?: Liked_ContentWhereInput | Liked_ContentWhereInput[]
    OR?: Liked_ContentWhereInput[]
    NOT?: Liked_ContentWhereInput | Liked_ContentWhereInput[]
    userid?: StringFilter<"Liked_Content"> | string
    mediatype?: EnumMediaTypeFilter<"Liked_Content"> | $Enums.MediaType
    contentid?: IntFilter<"Liked_Content"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_contentid_mediatype">

  export type Liked_ContentOrderByWithAggregationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    contentid?: SortOrder
    _count?: Liked_ContentCountOrderByAggregateInput
    _avg?: Liked_ContentAvgOrderByAggregateInput
    _max?: Liked_ContentMaxOrderByAggregateInput
    _min?: Liked_ContentMinOrderByAggregateInput
    _sum?: Liked_ContentSumOrderByAggregateInput
  }

  export type Liked_ContentScalarWhereWithAggregatesInput = {
    AND?: Liked_ContentScalarWhereWithAggregatesInput | Liked_ContentScalarWhereWithAggregatesInput[]
    OR?: Liked_ContentScalarWhereWithAggregatesInput[]
    NOT?: Liked_ContentScalarWhereWithAggregatesInput | Liked_ContentScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"Liked_Content"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"Liked_Content"> | $Enums.MediaType
    contentid?: IntWithAggregatesFilter<"Liked_Content"> | number
  }

  export type MangaWhereInput = {
    AND?: MangaWhereInput | MangaWhereInput[]
    OR?: MangaWhereInput[]
    NOT?: MangaWhereInput | MangaWhereInput[]
    mangaid?: StringFilter<"Manga"> | string
    authorid?: StringFilter<"Manga"> | string
    title?: StringFilter<"Manga"> | string
    description?: StringNullableFilter<"Manga"> | string | null
    release_date?: DateTimeNullableFilter<"Manga"> | Date | string | null
    cover_iamge?: StringNullableFilter<"Manga"> | string | null
    likes?: BigIntFilter<"Manga"> | bigint | number
    dislikes?: BigIntFilter<"Manga"> | bigint | number
    age_rating?: EnumAgeRatingFilter<"Manga"> | $Enums.AgeRating
    MediaGenre?: EnumMediaGenreNullableListFilter<"Manga">
    Anime?: AnimeListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }

  export type MangaOrderByWithRelationInput = {
    mangaid?: SortOrder
    authorid?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    cover_iamge?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    age_rating?: SortOrder
    MediaGenre?: SortOrder
    Anime?: AnimeOrderByRelationAggregateInput
    Bookmarks?: BookmarksOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
    ContentGroupLinks?: ContentGroupMediaOrderByRelationAggregateInput
  }

  export type MangaWhereUniqueInput = Prisma.AtLeast<{
    mangaid?: string
    AND?: MangaWhereInput | MangaWhereInput[]
    OR?: MangaWhereInput[]
    NOT?: MangaWhereInput | MangaWhereInput[]
    authorid?: StringFilter<"Manga"> | string
    title?: StringFilter<"Manga"> | string
    description?: StringNullableFilter<"Manga"> | string | null
    release_date?: DateTimeNullableFilter<"Manga"> | Date | string | null
    cover_iamge?: StringNullableFilter<"Manga"> | string | null
    likes?: BigIntFilter<"Manga"> | bigint | number
    dislikes?: BigIntFilter<"Manga"> | bigint | number
    age_rating?: EnumAgeRatingFilter<"Manga"> | $Enums.AgeRating
    MediaGenre?: EnumMediaGenreNullableListFilter<"Manga">
    Anime?: AnimeListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }, "mangaid">

  export type MangaOrderByWithAggregationInput = {
    mangaid?: SortOrder
    authorid?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    cover_iamge?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    age_rating?: SortOrder
    MediaGenre?: SortOrder
    _count?: MangaCountOrderByAggregateInput
    _avg?: MangaAvgOrderByAggregateInput
    _max?: MangaMaxOrderByAggregateInput
    _min?: MangaMinOrderByAggregateInput
    _sum?: MangaSumOrderByAggregateInput
  }

  export type MangaScalarWhereWithAggregatesInput = {
    AND?: MangaScalarWhereWithAggregatesInput | MangaScalarWhereWithAggregatesInput[]
    OR?: MangaScalarWhereWithAggregatesInput[]
    NOT?: MangaScalarWhereWithAggregatesInput | MangaScalarWhereWithAggregatesInput[]
    mangaid?: StringWithAggregatesFilter<"Manga"> | string
    authorid?: StringWithAggregatesFilter<"Manga"> | string
    title?: StringWithAggregatesFilter<"Manga"> | string
    description?: StringNullableWithAggregatesFilter<"Manga"> | string | null
    release_date?: DateTimeNullableWithAggregatesFilter<"Manga"> | Date | string | null
    cover_iamge?: StringNullableWithAggregatesFilter<"Manga"> | string | null
    likes?: BigIntWithAggregatesFilter<"Manga"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Manga"> | bigint | number
    age_rating?: EnumAgeRatingWithAggregatesFilter<"Manga"> | $Enums.AgeRating
    MediaGenre?: EnumMediaGenreNullableListFilter<"Manga">
  }

  export type MoviesWhereInput = {
    AND?: MoviesWhereInput | MoviesWhereInput[]
    OR?: MoviesWhereInput[]
    NOT?: MoviesWhereInput | MoviesWhereInput[]
    movieid?: StringFilter<"Movies"> | string
    title?: StringFilter<"Movies"> | string
    description?: StringNullableFilter<"Movies"> | string | null
    release_date?: DateTimeNullableFilter<"Movies"> | Date | string | null
    media_id_reference?: IntNullableFilter<"Movies"> | number | null
    likes?: BigIntFilter<"Movies"> | bigint | number
    dislikes?: BigIntFilter<"Movies"> | bigint | number
    showbanner?: StringNullableFilter<"Movies"> | string | null
    age_rating?: EnumAgeRatingFilter<"Movies"> | $Enums.AgeRating
    authorid?: StringFilter<"Movies"> | string
    media_reference_type?: EnumMediaTypeFilter<"Movies"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Movies">
    Bookmarks?: BookmarksListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }

  export type MoviesOrderByWithRelationInput = {
    movieid?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    media_id_reference?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    showbanner?: SortOrderInput | SortOrder
    age_rating?: SortOrder
    authorid?: SortOrder
    media_reference_type?: SortOrder
    MediaGenre?: SortOrder
    Bookmarks?: BookmarksOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
    ContentGroupLinks?: ContentGroupMediaOrderByRelationAggregateInput
  }

  export type MoviesWhereUniqueInput = Prisma.AtLeast<{
    movieid?: string
    AND?: MoviesWhereInput | MoviesWhereInput[]
    OR?: MoviesWhereInput[]
    NOT?: MoviesWhereInput | MoviesWhereInput[]
    title?: StringFilter<"Movies"> | string
    description?: StringNullableFilter<"Movies"> | string | null
    release_date?: DateTimeNullableFilter<"Movies"> | Date | string | null
    media_id_reference?: IntNullableFilter<"Movies"> | number | null
    likes?: BigIntFilter<"Movies"> | bigint | number
    dislikes?: BigIntFilter<"Movies"> | bigint | number
    showbanner?: StringNullableFilter<"Movies"> | string | null
    age_rating?: EnumAgeRatingFilter<"Movies"> | $Enums.AgeRating
    authorid?: StringFilter<"Movies"> | string
    media_reference_type?: EnumMediaTypeFilter<"Movies"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Movies">
    Bookmarks?: BookmarksListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    ContentGroupLinks?: ContentGroupMediaListRelationFilter
  }, "movieid">

  export type MoviesOrderByWithAggregationInput = {
    movieid?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    release_date?: SortOrderInput | SortOrder
    media_id_reference?: SortOrderInput | SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    showbanner?: SortOrderInput | SortOrder
    age_rating?: SortOrder
    authorid?: SortOrder
    media_reference_type?: SortOrder
    MediaGenre?: SortOrder
    _count?: MoviesCountOrderByAggregateInput
    _avg?: MoviesAvgOrderByAggregateInput
    _max?: MoviesMaxOrderByAggregateInput
    _min?: MoviesMinOrderByAggregateInput
    _sum?: MoviesSumOrderByAggregateInput
  }

  export type MoviesScalarWhereWithAggregatesInput = {
    AND?: MoviesScalarWhereWithAggregatesInput | MoviesScalarWhereWithAggregatesInput[]
    OR?: MoviesScalarWhereWithAggregatesInput[]
    NOT?: MoviesScalarWhereWithAggregatesInput | MoviesScalarWhereWithAggregatesInput[]
    movieid?: StringWithAggregatesFilter<"Movies"> | string
    title?: StringWithAggregatesFilter<"Movies"> | string
    description?: StringNullableWithAggregatesFilter<"Movies"> | string | null
    release_date?: DateTimeNullableWithAggregatesFilter<"Movies"> | Date | string | null
    media_id_reference?: IntNullableWithAggregatesFilter<"Movies"> | number | null
    likes?: BigIntWithAggregatesFilter<"Movies"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Movies"> | bigint | number
    showbanner?: StringNullableWithAggregatesFilter<"Movies"> | string | null
    age_rating?: EnumAgeRatingWithAggregatesFilter<"Movies"> | $Enums.AgeRating
    authorid?: StringWithAggregatesFilter<"Movies"> | string
    media_reference_type?: EnumMediaTypeWithAggregatesFilter<"Movies"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Movies">
  }

  export type PollsWhereInput = {
    AND?: PollsWhereInput | PollsWhereInput[]
    OR?: PollsWhereInput[]
    NOT?: PollsWhereInput | PollsWhereInput[]
    pollid?: IntFilter<"Polls"> | number
    author?: StringFilter<"Polls"> | string
    title?: StringFilter<"Polls"> | string
    description?: StringFilter<"Polls"> | string
    likes?: BigIntFilter<"Polls"> | bigint | number
    dislikes?: BigIntFilter<"Polls"> | bigint | number
    date?: DateTimeNullableFilter<"Polls"> | Date | string | null
    category?: StringFilter<"Polls"> | string
    status?: StringFilter<"Polls"> | string
    progress?: StringNullableFilter<"Polls"> | string | null
    views?: IntFilter<"Polls"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type PollsOrderByWithRelationInput = {
    pollid?: SortOrder
    author?: SortOrder
    title?: SortOrder
    description?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    date?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    views?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type PollsWhereUniqueInput = Prisma.AtLeast<{
    pollid?: number
    AND?: PollsWhereInput | PollsWhereInput[]
    OR?: PollsWhereInput[]
    NOT?: PollsWhereInput | PollsWhereInput[]
    author?: StringFilter<"Polls"> | string
    title?: StringFilter<"Polls"> | string
    description?: StringFilter<"Polls"> | string
    likes?: BigIntFilter<"Polls"> | bigint | number
    dislikes?: BigIntFilter<"Polls"> | bigint | number
    date?: DateTimeNullableFilter<"Polls"> | Date | string | null
    category?: StringFilter<"Polls"> | string
    status?: StringFilter<"Polls"> | string
    progress?: StringNullableFilter<"Polls"> | string | null
    views?: IntFilter<"Polls"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "pollid">

  export type PollsOrderByWithAggregationInput = {
    pollid?: SortOrder
    author?: SortOrder
    title?: SortOrder
    description?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    date?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    progress?: SortOrderInput | SortOrder
    views?: SortOrder
    _count?: PollsCountOrderByAggregateInput
    _avg?: PollsAvgOrderByAggregateInput
    _max?: PollsMaxOrderByAggregateInput
    _min?: PollsMinOrderByAggregateInput
    _sum?: PollsSumOrderByAggregateInput
  }

  export type PollsScalarWhereWithAggregatesInput = {
    AND?: PollsScalarWhereWithAggregatesInput | PollsScalarWhereWithAggregatesInput[]
    OR?: PollsScalarWhereWithAggregatesInput[]
    NOT?: PollsScalarWhereWithAggregatesInput | PollsScalarWhereWithAggregatesInput[]
    pollid?: IntWithAggregatesFilter<"Polls"> | number
    author?: StringWithAggregatesFilter<"Polls"> | string
    title?: StringWithAggregatesFilter<"Polls"> | string
    description?: StringWithAggregatesFilter<"Polls"> | string
    likes?: BigIntWithAggregatesFilter<"Polls"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Polls"> | bigint | number
    date?: DateTimeNullableWithAggregatesFilter<"Polls"> | Date | string | null
    category?: StringWithAggregatesFilter<"Polls"> | string
    status?: StringWithAggregatesFilter<"Polls"> | string
    progress?: StringNullableWithAggregatesFilter<"Polls"> | string | null
    views?: IntWithAggregatesFilter<"Polls"> | number
  }

  export type ReviewsWhereInput = {
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    reviewid?: IntFilter<"Reviews"> | number
    parentid?: StringFilter<"Reviews"> | string
    mediatype?: EnumMediaTypeFilter<"Reviews"> | $Enums.MediaType
    userid?: StringFilter<"Reviews"> | string
    review_text?: StringFilter<"Reviews"> | string
    review_date?: DateTimeFilter<"Reviews"> | Date | string
    likes?: BigIntFilter<"Reviews"> | bigint | number
    dislikes?: BigIntFilter<"Reviews"> | bigint | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ReviewsOrderByWithRelationInput = {
    reviewid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    userid?: SortOrder
    review_text?: SortOrder
    review_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type ReviewsWhereUniqueInput = Prisma.AtLeast<{
    reviewid?: number
    AND?: ReviewsWhereInput | ReviewsWhereInput[]
    OR?: ReviewsWhereInput[]
    NOT?: ReviewsWhereInput | ReviewsWhereInput[]
    parentid?: StringFilter<"Reviews"> | string
    mediatype?: EnumMediaTypeFilter<"Reviews"> | $Enums.MediaType
    userid?: StringFilter<"Reviews"> | string
    review_text?: StringFilter<"Reviews"> | string
    review_date?: DateTimeFilter<"Reviews"> | Date | string
    likes?: BigIntFilter<"Reviews"> | bigint | number
    dislikes?: BigIntFilter<"Reviews"> | bigint | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "reviewid">

  export type ReviewsOrderByWithAggregationInput = {
    reviewid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    userid?: SortOrder
    review_text?: SortOrder
    review_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    _count?: ReviewsCountOrderByAggregateInput
    _avg?: ReviewsAvgOrderByAggregateInput
    _max?: ReviewsMaxOrderByAggregateInput
    _min?: ReviewsMinOrderByAggregateInput
    _sum?: ReviewsSumOrderByAggregateInput
  }

  export type ReviewsScalarWhereWithAggregatesInput = {
    AND?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    OR?: ReviewsScalarWhereWithAggregatesInput[]
    NOT?: ReviewsScalarWhereWithAggregatesInput | ReviewsScalarWhereWithAggregatesInput[]
    reviewid?: IntWithAggregatesFilter<"Reviews"> | number
    parentid?: StringWithAggregatesFilter<"Reviews"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"Reviews"> | $Enums.MediaType
    userid?: StringWithAggregatesFilter<"Reviews"> | string
    review_text?: StringWithAggregatesFilter<"Reviews"> | string
    review_date?: DateTimeWithAggregatesFilter<"Reviews"> | Date | string
    likes?: BigIntWithAggregatesFilter<"Reviews"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Reviews"> | bigint | number
  }

  export type Shopping_CartWhereInput = {
    AND?: Shopping_CartWhereInput | Shopping_CartWhereInput[]
    OR?: Shopping_CartWhereInput[]
    NOT?: Shopping_CartWhereInput | Shopping_CartWhereInput[]
    userid?: StringFilter<"Shopping_Cart"> | string
    storeid?: StringFilter<"Shopping_Cart"> | string
    quantity?: IntNullableFilter<"Shopping_Cart"> | number | null
    Store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type Shopping_CartOrderByWithRelationInput = {
    userid?: SortOrder
    storeid?: SortOrder
    quantity?: SortOrderInput | SortOrder
    Store?: StoreOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type Shopping_CartWhereUniqueInput = Prisma.AtLeast<{
    userid_storeid?: Shopping_CartUseridStoreidCompoundUniqueInput
    AND?: Shopping_CartWhereInput | Shopping_CartWhereInput[]
    OR?: Shopping_CartWhereInput[]
    NOT?: Shopping_CartWhereInput | Shopping_CartWhereInput[]
    userid?: StringFilter<"Shopping_Cart"> | string
    storeid?: StringFilter<"Shopping_Cart"> | string
    quantity?: IntNullableFilter<"Shopping_Cart"> | number | null
    Store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_storeid">

  export type Shopping_CartOrderByWithAggregationInput = {
    userid?: SortOrder
    storeid?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: Shopping_CartCountOrderByAggregateInput
    _avg?: Shopping_CartAvgOrderByAggregateInput
    _max?: Shopping_CartMaxOrderByAggregateInput
    _min?: Shopping_CartMinOrderByAggregateInput
    _sum?: Shopping_CartSumOrderByAggregateInput
  }

  export type Shopping_CartScalarWhereWithAggregatesInput = {
    AND?: Shopping_CartScalarWhereWithAggregatesInput | Shopping_CartScalarWhereWithAggregatesInput[]
    OR?: Shopping_CartScalarWhereWithAggregatesInput[]
    NOT?: Shopping_CartScalarWhereWithAggregatesInput | Shopping_CartScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"Shopping_Cart"> | string
    storeid?: StringWithAggregatesFilter<"Shopping_Cart"> | string
    quantity?: IntNullableWithAggregatesFilter<"Shopping_Cart"> | number | null
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    storeid?: StringFilter<"Store"> | string
    sellerid?: StringFilter<"Store"> | string
    title?: StringFilter<"Store"> | string
    num_in_stock?: IntFilter<"Store"> | number
    release_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    original_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFilter<"Store"> | number
    shipping_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Store"> | string
    num_of_carts?: IntFilter<"Store"> | number
    images?: StringNullableFilter<"Store"> | string | null
    media_id_reference?: IntNullableFilter<"Store"> | number | null
    sales?: IntFilter<"Store"> | number
    reference_media_type?: StringNullableFilter<"Store"> | string | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Store">
    Shopping_Cart?: Shopping_CartListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type StoreOrderByWithRelationInput = {
    storeid?: SortOrder
    sellerid?: SortOrder
    title?: SortOrder
    num_in_stock?: SortOrder
    release_date?: SortOrderInput | SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    description?: SortOrder
    num_of_carts?: SortOrder
    images?: SortOrderInput | SortOrder
    media_id_reference?: SortOrderInput | SortOrder
    sales?: SortOrder
    reference_media_type?: SortOrderInput | SortOrder
    MediaGenre?: SortOrder
    Shopping_Cart?: Shopping_CartOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    storeid?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    sellerid?: StringFilter<"Store"> | string
    title?: StringFilter<"Store"> | string
    num_in_stock?: IntFilter<"Store"> | number
    release_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    original_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFilter<"Store"> | number
    shipping_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Store"> | string
    num_of_carts?: IntFilter<"Store"> | number
    images?: StringNullableFilter<"Store"> | string | null
    media_id_reference?: IntNullableFilter<"Store"> | number | null
    sales?: IntFilter<"Store"> | number
    reference_media_type?: StringNullableFilter<"Store"> | string | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Store">
    Shopping_Cart?: Shopping_CartListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "storeid">

  export type StoreOrderByWithAggregationInput = {
    storeid?: SortOrder
    sellerid?: SortOrder
    title?: SortOrder
    num_in_stock?: SortOrder
    release_date?: SortOrderInput | SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    description?: SortOrder
    num_of_carts?: SortOrder
    images?: SortOrderInput | SortOrder
    media_id_reference?: SortOrderInput | SortOrder
    sales?: SortOrder
    reference_media_type?: SortOrderInput | SortOrder
    MediaGenre?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    storeid?: StringWithAggregatesFilter<"Store"> | string
    sellerid?: StringWithAggregatesFilter<"Store"> | string
    title?: StringWithAggregatesFilter<"Store"> | string
    num_in_stock?: IntWithAggregatesFilter<"Store"> | number
    release_date?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    original_price?: DecimalWithAggregatesFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalWithAggregatesFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatWithAggregatesFilter<"Store"> | number
    shipping_price?: DecimalWithAggregatesFilter<"Store"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"Store"> | string
    num_of_carts?: IntWithAggregatesFilter<"Store"> | number
    images?: StringNullableWithAggregatesFilter<"Store"> | string | null
    media_id_reference?: IntNullableWithAggregatesFilter<"Store"> | number | null
    sales?: IntWithAggregatesFilter<"Store"> | number
    reference_media_type?: StringNullableWithAggregatesFilter<"Store"> | string | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Store">
  }

  export type Subscription_TiersWhereInput = {
    AND?: Subscription_TiersWhereInput | Subscription_TiersWhereInput[]
    OR?: Subscription_TiersWhereInput[]
    NOT?: Subscription_TiersWhereInput | Subscription_TiersWhereInput[]
    tierid?: IntFilter<"Subscription_Tiers"> | number
    name?: StringFilter<"Subscription_Tiers"> | string
    price?: IntFilter<"Subscription_Tiers"> | number
    votepower?: IntFilter<"Subscription_Tiers"> | number
    cloudlimit?: IntFilter<"Subscription_Tiers"> | number
    icon?: StringNullableFilter<"Subscription_Tiers"> | string | null
    store_discount?: IntFilter<"Subscription_Tiers"> | number
    game_discount?: IntFilter<"Subscription_Tiers"> | number
    permissions?: EnumnavItemsNullableListFilter<"Subscription_Tiers">
    features?: StringNullableListFilter<"Subscription_Tiers">
    userid?: StringNullableFilter<"Subscription_Tiers"> | string | null
    Users?: UsersListRelationFilter
  }

  export type Subscription_TiersOrderByWithRelationInput = {
    tierid?: SortOrder
    name?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    icon?: SortOrderInput | SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
    permissions?: SortOrder
    features?: SortOrder
    userid?: SortOrderInput | SortOrder
    Users?: UsersOrderByRelationAggregateInput
  }

  export type Subscription_TiersWhereUniqueInput = Prisma.AtLeast<{
    tierid?: number
    name?: string
    AND?: Subscription_TiersWhereInput | Subscription_TiersWhereInput[]
    OR?: Subscription_TiersWhereInput[]
    NOT?: Subscription_TiersWhereInput | Subscription_TiersWhereInput[]
    price?: IntFilter<"Subscription_Tiers"> | number
    votepower?: IntFilter<"Subscription_Tiers"> | number
    cloudlimit?: IntFilter<"Subscription_Tiers"> | number
    icon?: StringNullableFilter<"Subscription_Tiers"> | string | null
    store_discount?: IntFilter<"Subscription_Tiers"> | number
    game_discount?: IntFilter<"Subscription_Tiers"> | number
    permissions?: EnumnavItemsNullableListFilter<"Subscription_Tiers">
    features?: StringNullableListFilter<"Subscription_Tiers">
    userid?: StringNullableFilter<"Subscription_Tiers"> | string | null
    Users?: UsersListRelationFilter
  }, "tierid" | "name">

  export type Subscription_TiersOrderByWithAggregationInput = {
    tierid?: SortOrder
    name?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    icon?: SortOrderInput | SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
    permissions?: SortOrder
    features?: SortOrder
    userid?: SortOrderInput | SortOrder
    _count?: Subscription_TiersCountOrderByAggregateInput
    _avg?: Subscription_TiersAvgOrderByAggregateInput
    _max?: Subscription_TiersMaxOrderByAggregateInput
    _min?: Subscription_TiersMinOrderByAggregateInput
    _sum?: Subscription_TiersSumOrderByAggregateInput
  }

  export type Subscription_TiersScalarWhereWithAggregatesInput = {
    AND?: Subscription_TiersScalarWhereWithAggregatesInput | Subscription_TiersScalarWhereWithAggregatesInput[]
    OR?: Subscription_TiersScalarWhereWithAggregatesInput[]
    NOT?: Subscription_TiersScalarWhereWithAggregatesInput | Subscription_TiersScalarWhereWithAggregatesInput[]
    tierid?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    name?: StringWithAggregatesFilter<"Subscription_Tiers"> | string
    price?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    votepower?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    cloudlimit?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    icon?: StringNullableWithAggregatesFilter<"Subscription_Tiers"> | string | null
    store_discount?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    game_discount?: IntWithAggregatesFilter<"Subscription_Tiers"> | number
    permissions?: EnumnavItemsNullableListFilter<"Subscription_Tiers">
    features?: StringNullableListFilter<"Subscription_Tiers">
    userid?: StringNullableWithAggregatesFilter<"Subscription_Tiers"> | string | null
  }

  export type TitleTranslationWhereInput = {
    AND?: TitleTranslationWhereInput | TitleTranslationWhereInput[]
    OR?: TitleTranslationWhereInput[]
    NOT?: TitleTranslationWhereInput | TitleTranslationWhereInput[]
    translationid?: IntFilter<"TitleTranslation"> | number
    parentid?: IntFilter<"TitleTranslation"> | number
    mediatype?: EnumMediaTypeFilter<"TitleTranslation"> | $Enums.MediaType
    title?: StringFilter<"TitleTranslation"> | string
    language?: StringFilter<"TitleTranslation"> | string
  }

  export type TitleTranslationOrderByWithRelationInput = {
    translationid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    title?: SortOrder
    language?: SortOrder
  }

  export type TitleTranslationWhereUniqueInput = Prisma.AtLeast<{
    translationid?: number
    AND?: TitleTranslationWhereInput | TitleTranslationWhereInput[]
    OR?: TitleTranslationWhereInput[]
    NOT?: TitleTranslationWhereInput | TitleTranslationWhereInput[]
    parentid?: IntFilter<"TitleTranslation"> | number
    mediatype?: EnumMediaTypeFilter<"TitleTranslation"> | $Enums.MediaType
    title?: StringFilter<"TitleTranslation"> | string
    language?: StringFilter<"TitleTranslation"> | string
  }, "translationid">

  export type TitleTranslationOrderByWithAggregationInput = {
    translationid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    title?: SortOrder
    language?: SortOrder
    _count?: TitleTranslationCountOrderByAggregateInput
    _avg?: TitleTranslationAvgOrderByAggregateInput
    _max?: TitleTranslationMaxOrderByAggregateInput
    _min?: TitleTranslationMinOrderByAggregateInput
    _sum?: TitleTranslationSumOrderByAggregateInput
  }

  export type TitleTranslationScalarWhereWithAggregatesInput = {
    AND?: TitleTranslationScalarWhereWithAggregatesInput | TitleTranslationScalarWhereWithAggregatesInput[]
    OR?: TitleTranslationScalarWhereWithAggregatesInput[]
    NOT?: TitleTranslationScalarWhereWithAggregatesInput | TitleTranslationScalarWhereWithAggregatesInput[]
    translationid?: IntWithAggregatesFilter<"TitleTranslation"> | number
    parentid?: IntWithAggregatesFilter<"TitleTranslation"> | number
    mediatype?: EnumMediaTypeWithAggregatesFilter<"TitleTranslation"> | $Enums.MediaType
    title?: StringWithAggregatesFilter<"TitleTranslation"> | string
    language?: StringWithAggregatesFilter<"TitleTranslation"> | string
  }

  export type User_ActivityWhereInput = {
    AND?: User_ActivityWhereInput | User_ActivityWhereInput[]
    OR?: User_ActivityWhereInput[]
    NOT?: User_ActivityWhereInput | User_ActivityWhereInput[]
    userid?: StringFilter<"User_Activity"> | string
    child_content?: StringFilter<"User_Activity"> | string
    parent_content?: StringFilter<"User_Activity"> | string
    mediatype?: EnumMediaTypeFilter<"User_Activity"> | $Enums.MediaType
    stopping_point?: IntFilter<"User_Activity"> | number
    date_watched?: DateTimeFilter<"User_Activity"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type User_ActivityOrderByWithRelationInput = {
    userid?: SortOrder
    child_content?: SortOrder
    parent_content?: SortOrder
    mediatype?: SortOrder
    stopping_point?: SortOrder
    date_watched?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type User_ActivityWhereUniqueInput = Prisma.AtLeast<{
    userid_child_content_parent_content_mediatype?: User_ActivityUseridChild_contentParent_contentMediatypeCompoundUniqueInput
    AND?: User_ActivityWhereInput | User_ActivityWhereInput[]
    OR?: User_ActivityWhereInput[]
    NOT?: User_ActivityWhereInput | User_ActivityWhereInput[]
    userid?: StringFilter<"User_Activity"> | string
    child_content?: StringFilter<"User_Activity"> | string
    parent_content?: StringFilter<"User_Activity"> | string
    mediatype?: EnumMediaTypeFilter<"User_Activity"> | $Enums.MediaType
    stopping_point?: IntFilter<"User_Activity"> | number
    date_watched?: DateTimeFilter<"User_Activity"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_child_content_parent_content_mediatype">

  export type User_ActivityOrderByWithAggregationInput = {
    userid?: SortOrder
    child_content?: SortOrder
    parent_content?: SortOrder
    mediatype?: SortOrder
    stopping_point?: SortOrder
    date_watched?: SortOrder
    _count?: User_ActivityCountOrderByAggregateInput
    _avg?: User_ActivityAvgOrderByAggregateInput
    _max?: User_ActivityMaxOrderByAggregateInput
    _min?: User_ActivityMinOrderByAggregateInput
    _sum?: User_ActivitySumOrderByAggregateInput
  }

  export type User_ActivityScalarWhereWithAggregatesInput = {
    AND?: User_ActivityScalarWhereWithAggregatesInput | User_ActivityScalarWhereWithAggregatesInput[]
    OR?: User_ActivityScalarWhereWithAggregatesInput[]
    NOT?: User_ActivityScalarWhereWithAggregatesInput | User_ActivityScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"User_Activity"> | string
    child_content?: StringWithAggregatesFilter<"User_Activity"> | string
    parent_content?: StringWithAggregatesFilter<"User_Activity"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"User_Activity"> | $Enums.MediaType
    stopping_point?: IntWithAggregatesFilter<"User_Activity"> | number
    date_watched?: DateTimeWithAggregatesFilter<"User_Activity"> | Date | string
  }

  export type User_BookmarksWhereInput = {
    AND?: User_BookmarksWhereInput | User_BookmarksWhereInput[]
    OR?: User_BookmarksWhereInput[]
    NOT?: User_BookmarksWhereInput | User_BookmarksWhereInput[]
    userid?: StringFilter<"User_Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"User_Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"User_Bookmarks"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type User_BookmarksOrderByWithRelationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type User_BookmarksWhereUniqueInput = Prisma.AtLeast<{
    userid_parentid_mediatype?: User_BookmarksUseridParentidMediatypeCompoundUniqueInput
    AND?: User_BookmarksWhereInput | User_BookmarksWhereInput[]
    OR?: User_BookmarksWhereInput[]
    NOT?: User_BookmarksWhereInput | User_BookmarksWhereInput[]
    userid?: StringFilter<"User_Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"User_Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"User_Bookmarks"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_parentid_mediatype">

  export type User_BookmarksOrderByWithAggregationInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
    _count?: User_BookmarksCountOrderByAggregateInput
    _max?: User_BookmarksMaxOrderByAggregateInput
    _min?: User_BookmarksMinOrderByAggregateInput
  }

  export type User_BookmarksScalarWhereWithAggregatesInput = {
    AND?: User_BookmarksScalarWhereWithAggregatesInput | User_BookmarksScalarWhereWithAggregatesInput[]
    OR?: User_BookmarksScalarWhereWithAggregatesInput[]
    NOT?: User_BookmarksScalarWhereWithAggregatesInput | User_BookmarksScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"User_Bookmarks"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"User_Bookmarks"> | $Enums.MediaType
    parentid?: StringWithAggregatesFilter<"User_Bookmarks"> | string
  }

  export type User_RatingsWhereInput = {
    AND?: User_RatingsWhereInput | User_RatingsWhereInput[]
    OR?: User_RatingsWhereInput[]
    NOT?: User_RatingsWhereInput | User_RatingsWhereInput[]
    userid?: StringFilter<"User_Ratings"> | string
    parentid?: StringFilter<"User_Ratings"> | string
    mediatype?: EnumMediaTypeFilter<"User_Ratings"> | $Enums.MediaType
    rating?: IntFilter<"User_Ratings"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type User_RatingsOrderByWithRelationInput = {
    userid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    rating?: SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type User_RatingsWhereUniqueInput = Prisma.AtLeast<{
    userid_parentid?: User_RatingsUseridParentidCompoundUniqueInput
    AND?: User_RatingsWhereInput | User_RatingsWhereInput[]
    OR?: User_RatingsWhereInput[]
    NOT?: User_RatingsWhereInput | User_RatingsWhereInput[]
    userid?: StringFilter<"User_Ratings"> | string
    parentid?: StringFilter<"User_Ratings"> | string
    mediatype?: EnumMediaTypeFilter<"User_Ratings"> | $Enums.MediaType
    rating?: IntFilter<"User_Ratings"> | number
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "userid_parentid">

  export type User_RatingsOrderByWithAggregationInput = {
    userid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    rating?: SortOrder
    _count?: User_RatingsCountOrderByAggregateInput
    _avg?: User_RatingsAvgOrderByAggregateInput
    _max?: User_RatingsMaxOrderByAggregateInput
    _min?: User_RatingsMinOrderByAggregateInput
    _sum?: User_RatingsSumOrderByAggregateInput
  }

  export type User_RatingsScalarWhereWithAggregatesInput = {
    AND?: User_RatingsScalarWhereWithAggregatesInput | User_RatingsScalarWhereWithAggregatesInput[]
    OR?: User_RatingsScalarWhereWithAggregatesInput[]
    NOT?: User_RatingsScalarWhereWithAggregatesInput | User_RatingsScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"User_Ratings"> | string
    parentid?: StringWithAggregatesFilter<"User_Ratings"> | string
    mediatype?: EnumMediaTypeWithAggregatesFilter<"User_Ratings"> | $Enums.MediaType
    rating?: IntWithAggregatesFilter<"User_Ratings"> | number
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    userid?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password_hash?: StringFilter<"Users"> | string
    date_joined?: DateTimeFilter<"Users"> | Date | string
    num_of_friends?: IntNullableFilter<"Users"> | number | null
    num_of_followers?: IntNullableFilter<"Users"> | number | null
    profile_picture?: StringNullableFilter<"Users"> | string | null
    user_bio?: StringNullableFilter<"Users"> | string | null
    two_factor?: BoolFilter<"Users"> | boolean
    email_notifications?: BoolFilter<"Users"> | boolean
    push_notifications?: BoolFilter<"Users"> | boolean
    subscriptionTierId?: IntNullableFilter<"Users"> | number | null
    usedstorage?: BigIntFilter<"Users"> | bigint | number
    accountType?: EnumAccountTypeFilter<"Users"> | $Enums.AccountType
    subscription_tier?: XOR<Subscription_TiersNullableScalarRelationFilter, Subscription_TiersWhereInput> | null
    Anime?: AnimeListRelationFilter
    Anime_Authors?: Anime_AuthorsListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Comments?: CommentsListRelationFilter
    Disliked_Content?: Disliked_ContentListRelationFilter
    File?: FileListRelationFilter
    FileShares?: FileSharesListRelationFilter
    Folder?: FolderListRelationFilter
    FolderShares?: FolderSharesListRelationFilter
    Liked_Content?: Liked_ContentListRelationFilter
    Manga?: MangaListRelationFilter
    Movies?: MoviesListRelationFilter
    Polls?: PollsListRelationFilter
    Reviews?: ReviewsListRelationFilter
    Shopping_Cart?: Shopping_CartListRelationFilter
    Store?: StoreListRelationFilter
    User_Activity?: User_ActivityListRelationFilter
    User_Bookmarks?: User_BookmarksListRelationFilter
    User_Ratings?: User_RatingsListRelationFilter
    Videos?: VideosListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    userid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    date_joined?: SortOrder
    num_of_friends?: SortOrderInput | SortOrder
    num_of_followers?: SortOrderInput | SortOrder
    profile_picture?: SortOrderInput | SortOrder
    user_bio?: SortOrderInput | SortOrder
    two_factor?: SortOrder
    email_notifications?: SortOrder
    push_notifications?: SortOrder
    subscriptionTierId?: SortOrderInput | SortOrder
    usedstorage?: SortOrder
    accountType?: SortOrder
    subscription_tier?: Subscription_TiersOrderByWithRelationInput
    Anime?: AnimeOrderByRelationAggregateInput
    Anime_Authors?: Anime_AuthorsOrderByRelationAggregateInput
    Bookmarks?: BookmarksOrderByRelationAggregateInput
    Comments?: CommentsOrderByRelationAggregateInput
    Disliked_Content?: Disliked_ContentOrderByRelationAggregateInput
    File?: FileOrderByRelationAggregateInput
    FileShares?: FileSharesOrderByRelationAggregateInput
    Folder?: FolderOrderByRelationAggregateInput
    FolderShares?: FolderSharesOrderByRelationAggregateInput
    Liked_Content?: Liked_ContentOrderByRelationAggregateInput
    Manga?: MangaOrderByRelationAggregateInput
    Movies?: MoviesOrderByRelationAggregateInput
    Polls?: PollsOrderByRelationAggregateInput
    Reviews?: ReviewsOrderByRelationAggregateInput
    Shopping_Cart?: Shopping_CartOrderByRelationAggregateInput
    Store?: StoreOrderByRelationAggregateInput
    User_Activity?: User_ActivityOrderByRelationAggregateInput
    User_Bookmarks?: User_BookmarksOrderByRelationAggregateInput
    User_Ratings?: User_RatingsOrderByRelationAggregateInput
    Videos?: VideosOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    userid?: string
    username?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password_hash?: StringFilter<"Users"> | string
    date_joined?: DateTimeFilter<"Users"> | Date | string
    num_of_friends?: IntNullableFilter<"Users"> | number | null
    num_of_followers?: IntNullableFilter<"Users"> | number | null
    profile_picture?: StringNullableFilter<"Users"> | string | null
    user_bio?: StringNullableFilter<"Users"> | string | null
    two_factor?: BoolFilter<"Users"> | boolean
    email_notifications?: BoolFilter<"Users"> | boolean
    push_notifications?: BoolFilter<"Users"> | boolean
    subscriptionTierId?: IntNullableFilter<"Users"> | number | null
    usedstorage?: BigIntFilter<"Users"> | bigint | number
    accountType?: EnumAccountTypeFilter<"Users"> | $Enums.AccountType
    subscription_tier?: XOR<Subscription_TiersNullableScalarRelationFilter, Subscription_TiersWhereInput> | null
    Anime?: AnimeListRelationFilter
    Anime_Authors?: Anime_AuthorsListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Comments?: CommentsListRelationFilter
    Disliked_Content?: Disliked_ContentListRelationFilter
    File?: FileListRelationFilter
    FileShares?: FileSharesListRelationFilter
    Folder?: FolderListRelationFilter
    FolderShares?: FolderSharesListRelationFilter
    Liked_Content?: Liked_ContentListRelationFilter
    Manga?: MangaListRelationFilter
    Movies?: MoviesListRelationFilter
    Polls?: PollsListRelationFilter
    Reviews?: ReviewsListRelationFilter
    Shopping_Cart?: Shopping_CartListRelationFilter
    Store?: StoreListRelationFilter
    User_Activity?: User_ActivityListRelationFilter
    User_Bookmarks?: User_BookmarksListRelationFilter
    User_Ratings?: User_RatingsListRelationFilter
    Videos?: VideosListRelationFilter
  }, "userid" | "username" | "email">

  export type UsersOrderByWithAggregationInput = {
    userid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    date_joined?: SortOrder
    num_of_friends?: SortOrderInput | SortOrder
    num_of_followers?: SortOrderInput | SortOrder
    profile_picture?: SortOrderInput | SortOrder
    user_bio?: SortOrderInput | SortOrder
    two_factor?: SortOrder
    email_notifications?: SortOrder
    push_notifications?: SortOrder
    subscriptionTierId?: SortOrderInput | SortOrder
    usedstorage?: SortOrder
    accountType?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    userid?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password_hash?: StringWithAggregatesFilter<"Users"> | string
    date_joined?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    num_of_friends?: IntNullableWithAggregatesFilter<"Users"> | number | null
    num_of_followers?: IntNullableWithAggregatesFilter<"Users"> | number | null
    profile_picture?: StringNullableWithAggregatesFilter<"Users"> | string | null
    user_bio?: StringNullableWithAggregatesFilter<"Users"> | string | null
    two_factor?: BoolWithAggregatesFilter<"Users"> | boolean
    email_notifications?: BoolWithAggregatesFilter<"Users"> | boolean
    push_notifications?: BoolWithAggregatesFilter<"Users"> | boolean
    subscriptionTierId?: IntNullableWithAggregatesFilter<"Users"> | number | null
    usedstorage?: BigIntWithAggregatesFilter<"Users"> | bigint | number
    accountType?: EnumAccountTypeWithAggregatesFilter<"Users"> | $Enums.AccountType
  }

  export type VideosWhereInput = {
    AND?: VideosWhereInput | VideosWhereInput[]
    OR?: VideosWhereInput[]
    NOT?: VideosWhereInput | VideosWhereInput[]
    videoid?: StringFilter<"Videos"> | string
    title?: StringFilter<"Videos"> | string
    authorid?: StringFilter<"Videos"> | string
    description?: StringFilter<"Videos"> | string
    release_date?: DateTimeNullableFilter<"Videos"> | Date | string | null
    media_type?: EnumMediaTypeFilter<"Videos"> | $Enums.MediaType
    video_banner?: StringFilter<"Videos"> | string
    likes?: BigIntFilter<"Videos"> | bigint | number
    dislikes?: BigIntFilter<"Videos"> | bigint | number
    duration?: BigIntNullableFilter<"Videos"> | bigint | number | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Videos">
    thumbnail?: StringFilter<"Videos"> | string
    views?: IntFilter<"Videos"> | number
    Anime?: AnimeListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Comments?: CommentsListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type VideosOrderByWithRelationInput = {
    videoid?: SortOrder
    title?: SortOrder
    authorid?: SortOrder
    description?: SortOrder
    release_date?: SortOrderInput | SortOrder
    media_type?: SortOrder
    video_banner?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrderInput | SortOrder
    MediaGenre?: SortOrder
    thumbnail?: SortOrder
    views?: SortOrder
    Anime?: AnimeOrderByRelationAggregateInput
    Bookmarks?: BookmarksOrderByRelationAggregateInput
    Comments?: CommentsOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
  }

  export type VideosWhereUniqueInput = Prisma.AtLeast<{
    videoid?: string
    AND?: VideosWhereInput | VideosWhereInput[]
    OR?: VideosWhereInput[]
    NOT?: VideosWhereInput | VideosWhereInput[]
    title?: StringFilter<"Videos"> | string
    authorid?: StringFilter<"Videos"> | string
    description?: StringFilter<"Videos"> | string
    release_date?: DateTimeNullableFilter<"Videos"> | Date | string | null
    media_type?: EnumMediaTypeFilter<"Videos"> | $Enums.MediaType
    video_banner?: StringFilter<"Videos"> | string
    likes?: BigIntFilter<"Videos"> | bigint | number
    dislikes?: BigIntFilter<"Videos"> | bigint | number
    duration?: BigIntNullableFilter<"Videos"> | bigint | number | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Videos">
    thumbnail?: StringFilter<"Videos"> | string
    views?: IntFilter<"Videos"> | number
    Anime?: AnimeListRelationFilter
    Bookmarks?: BookmarksListRelationFilter
    Comments?: CommentsListRelationFilter
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "videoid">

  export type VideosOrderByWithAggregationInput = {
    videoid?: SortOrder
    title?: SortOrder
    authorid?: SortOrder
    description?: SortOrder
    release_date?: SortOrderInput | SortOrder
    media_type?: SortOrder
    video_banner?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrderInput | SortOrder
    MediaGenre?: SortOrder
    thumbnail?: SortOrder
    views?: SortOrder
    _count?: VideosCountOrderByAggregateInput
    _avg?: VideosAvgOrderByAggregateInput
    _max?: VideosMaxOrderByAggregateInput
    _min?: VideosMinOrderByAggregateInput
    _sum?: VideosSumOrderByAggregateInput
  }

  export type VideosScalarWhereWithAggregatesInput = {
    AND?: VideosScalarWhereWithAggregatesInput | VideosScalarWhereWithAggregatesInput[]
    OR?: VideosScalarWhereWithAggregatesInput[]
    NOT?: VideosScalarWhereWithAggregatesInput | VideosScalarWhereWithAggregatesInput[]
    videoid?: StringWithAggregatesFilter<"Videos"> | string
    title?: StringWithAggregatesFilter<"Videos"> | string
    authorid?: StringWithAggregatesFilter<"Videos"> | string
    description?: StringWithAggregatesFilter<"Videos"> | string
    release_date?: DateTimeNullableWithAggregatesFilter<"Videos"> | Date | string | null
    media_type?: EnumMediaTypeWithAggregatesFilter<"Videos"> | $Enums.MediaType
    video_banner?: StringWithAggregatesFilter<"Videos"> | string
    likes?: BigIntWithAggregatesFilter<"Videos"> | bigint | number
    dislikes?: BigIntWithAggregatesFilter<"Videos"> | bigint | number
    duration?: BigIntNullableWithAggregatesFilter<"Videos"> | bigint | number | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Videos">
    thumbnail?: StringWithAggregatesFilter<"Videos"> | string
    views?: IntWithAggregatesFilter<"Videos"> | number
  }

  export type Website_VariablesWhereInput = {
    AND?: Website_VariablesWhereInput | Website_VariablesWhereInput[]
    OR?: Website_VariablesWhereInput[]
    NOT?: Website_VariablesWhereInput | Website_VariablesWhereInput[]
    website_version?: StringFilter<"Website_Variables"> | string
    footer_items?: StringNullableListFilter<"Website_Variables">
    footer_separator?: StringNullableFilter<"Website_Variables"> | string | null
    important_info?: StringNullableFilter<"Website_Variables"> | string | null
    rootContentPath?: StringNullableFilter<"Website_Variables"> | string | null
    loggedin_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
    loggedout_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
  }

  export type Website_VariablesOrderByWithRelationInput = {
    website_version?: SortOrder
    footer_items?: SortOrder
    footer_separator?: SortOrderInput | SortOrder
    important_info?: SortOrderInput | SortOrder
    rootContentPath?: SortOrderInput | SortOrder
    loggedin_nav_items?: SortOrder
    loggedout_nav_items?: SortOrder
  }

  export type Website_VariablesWhereUniqueInput = Prisma.AtLeast<{
    website_version?: string
    AND?: Website_VariablesWhereInput | Website_VariablesWhereInput[]
    OR?: Website_VariablesWhereInput[]
    NOT?: Website_VariablesWhereInput | Website_VariablesWhereInput[]
    footer_items?: StringNullableListFilter<"Website_Variables">
    footer_separator?: StringNullableFilter<"Website_Variables"> | string | null
    important_info?: StringNullableFilter<"Website_Variables"> | string | null
    rootContentPath?: StringNullableFilter<"Website_Variables"> | string | null
    loggedin_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
    loggedout_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
  }, "website_version">

  export type Website_VariablesOrderByWithAggregationInput = {
    website_version?: SortOrder
    footer_items?: SortOrder
    footer_separator?: SortOrderInput | SortOrder
    important_info?: SortOrderInput | SortOrder
    rootContentPath?: SortOrderInput | SortOrder
    loggedin_nav_items?: SortOrder
    loggedout_nav_items?: SortOrder
    _count?: Website_VariablesCountOrderByAggregateInput
    _max?: Website_VariablesMaxOrderByAggregateInput
    _min?: Website_VariablesMinOrderByAggregateInput
  }

  export type Website_VariablesScalarWhereWithAggregatesInput = {
    AND?: Website_VariablesScalarWhereWithAggregatesInput | Website_VariablesScalarWhereWithAggregatesInput[]
    OR?: Website_VariablesScalarWhereWithAggregatesInput[]
    NOT?: Website_VariablesScalarWhereWithAggregatesInput | Website_VariablesScalarWhereWithAggregatesInput[]
    website_version?: StringWithAggregatesFilter<"Website_Variables"> | string
    footer_items?: StringNullableListFilter<"Website_Variables">
    footer_separator?: StringNullableWithAggregatesFilter<"Website_Variables"> | string | null
    important_info?: StringNullableWithAggregatesFilter<"Website_Variables"> | string | null
    rootContentPath?: StringNullableWithAggregatesFilter<"Website_Variables"> | string | null
    loggedin_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
    loggedout_nav_items?: EnumMediaTypeNullableListFilter<"Website_Variables">
  }

  export type AnimeCreateInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUpdateInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeCreateManyInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
  }

  export type AnimeUpdateManyMutationInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnimeUncheckedUpdateManyInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Anime_AuthorsCreateInput = {
    Anime: AnimeCreateNestedOneWithoutAnime_AuthorsInput
    Users: UsersCreateNestedOneWithoutAnime_AuthorsInput
  }

  export type Anime_AuthorsUncheckedCreateInput = {
    animeid: string
    authorid: string
  }

  export type Anime_AuthorsUpdateInput = {
    Anime?: AnimeUpdateOneRequiredWithoutAnime_AuthorsNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnime_AuthorsNestedInput
  }

  export type Anime_AuthorsUncheckedUpdateInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
  }

  export type Anime_AuthorsCreateManyInput = {
    animeid: string
    authorid: string
  }

  export type Anime_AuthorsUpdateManyMutationInput = {

  }

  export type Anime_AuthorsUncheckedUpdateManyInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarksCreateInput = {
    mediatype: $Enums.MediaType
    Anime: AnimeCreateNestedOneWithoutBookmarksInput
    Manga: MangaCreateNestedOneWithoutBookmarksInput
    Movies: MoviesCreateNestedOneWithoutBookmarksInput
    Videos: VideosCreateNestedOneWithoutBookmarksInput
    Users: UsersCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateInput = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type BookmarksUpdateInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneRequiredWithoutBookmarksNestedInput
    Manga?: MangaUpdateOneRequiredWithoutBookmarksNestedInput
    Movies?: MoviesUpdateOneRequiredWithoutBookmarksNestedInput
    Videos?: VideosUpdateOneRequiredWithoutBookmarksNestedInput
    Users?: UsersUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarksCreateManyInput = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type BookmarksUpdateManyMutationInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsCreateInput = {
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    ContentUnit: ContentUnitCreateNestedOneWithoutCommentsInput
    Videos: VideosCreateNestedOneWithoutCommentsInput
    Users: UsersCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateInput = {
    commentid?: number
    parentid: string
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsUpdateInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    ContentUnit?: ContentUnitUpdateOneRequiredWithoutCommentsNestedInput
    Videos?: VideosUpdateOneRequiredWithoutCommentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommentsCreateManyInput = {
    commentid?: number
    parentid: string
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsUpdateManyMutationInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommentsUncheckedUpdateManyInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ContentGroupCreateInput = {
    seasonid?: string
    season_number: number
    release_date?: Date | string
    visible?: boolean
    season_path?: string
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutContentGroupInput
  }

  export type ContentGroupUncheckedCreateInput = {
    seasonid?: string
    season_number: number
    release_date?: Date | string
    visible?: boolean
    season_path?: string
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutContentGroupInput
  }

  export type ContentGroupUpdateInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutContentGroupNestedInput
  }

  export type ContentGroupUncheckedUpdateInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutContentGroupNestedInput
  }

  export type ContentGroupCreateManyInput = {
    seasonid?: string
    season_number: number
    release_date?: Date | string
    visible?: boolean
    season_path?: string
  }

  export type ContentGroupUpdateManyMutationInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
  }

  export type ContentGroupUncheckedUpdateManyInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
  }

  export type ContentGroupMediaCreateInput = {
    id?: string
    mediatype: $Enums.MediaType
    Anime?: AnimeCreateNestedOneWithoutContentGroupLinksInput
    Manga?: MangaCreateNestedOneWithoutContentGroupLinksInput
    Movies?: MoviesCreateNestedOneWithoutContentGroupLinksInput
    ContentGroup: ContentGroupCreateNestedOneWithoutContentGroupLinksInput
    ContentUnits?: ContentUnitCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUncheckedCreateInput = {
    id?: string
    seasonid: string
    mediaid: string
    mediatype: $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneWithoutContentGroupLinksNestedInput
    Manga?: MangaUpdateOneWithoutContentGroupLinksNestedInput
    Movies?: MoviesUpdateOneWithoutContentGroupLinksNestedInput
    ContentGroup?: ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput
    ContentUnits?: ContentUnitUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediaid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaCreateManyInput = {
    id?: string
    seasonid: string
    mediaid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentGroupMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediaid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentUnitCreateInput = {
    episodeid?: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
    Comments?: CommentsCreateNestedManyWithoutContentUnitInput
    ContentGroupMedia: ContentGroupMediaCreateNestedOneWithoutContentUnitsInput
  }

  export type ContentUnitUncheckedCreateInput = {
    episodeid?: string
    contentgroupid: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
    Comments?: CommentsUncheckedCreateNestedManyWithoutContentUnitInput
  }

  export type ContentUnitUpdateInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUpdateManyWithoutContentUnitNestedInput
    ContentGroupMedia?: ContentGroupMediaUpdateOneRequiredWithoutContentUnitsNestedInput
  }

  export type ContentUnitUncheckedUpdateInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    contentgroupid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUncheckedUpdateManyWithoutContentUnitNestedInput
  }

  export type ContentUnitCreateManyInput = {
    episodeid?: string
    contentgroupid: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
  }

  export type ContentUnitUpdateManyMutationInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
  }

  export type ContentUnitUncheckedUpdateManyInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    contentgroupid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
  }

  export type Disliked_ContentCreateInput = {
    contentid: number
    mediatype: $Enums.MediaType
    Users: UsersCreateNestedOneWithoutDisliked_ContentInput
  }

  export type Disliked_ContentUncheckedCreateInput = {
    userid: string
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Disliked_ContentUpdateInput = {
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Users?: UsersUpdateOneRequiredWithoutDisliked_ContentNestedInput
  }

  export type Disliked_ContentUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type Disliked_ContentCreateManyInput = {
    userid: string
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Disliked_ContentUpdateManyMutationInput = {
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type Disliked_ContentUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FileCreateInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    Folder?: FolderCreateNestedOneWithoutFileInput
    Users: UsersCreateNestedOneWithoutFileInput
    FileShares?: FileSharesCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    folderId?: string | null
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    ownerId: string
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Folder?: FolderUpdateOneWithoutFileNestedInput
    Users?: UsersUpdateOneRequiredWithoutFileNestedInput
    FileShares?: FileSharesUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    FileShares?: FileSharesUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    folderId?: string | null
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    ownerId: string
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FileSharesCreateInput = {
    accessLevel?: $Enums.AccessLevel
    File: FileCreateNestedOneWithoutFileSharesInput
    Users: UsersCreateNestedOneWithoutFileSharesInput
  }

  export type FileSharesUncheckedCreateInput = {
    userId: string
    fileId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileSharesUpdateInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    File?: FileUpdateOneRequiredWithoutFileSharesNestedInput
    Users?: UsersUpdateOneRequiredWithoutFileSharesNestedInput
  }

  export type FileSharesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FileSharesCreateManyInput = {
    userId: string
    fileId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileSharesUpdateManyMutationInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FileSharesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileCreateNestedManyWithoutFolderInput
    Users: UsersCreateNestedOneWithoutFolderInput
    Folder?: FolderCreateNestedOneWithoutOther_FolderInput
    other_Folder?: FolderCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    ownerId: string
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileUncheckedCreateNestedManyWithoutFolderInput
    other_Folder?: FolderUncheckedCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUpdateManyWithoutFolderNestedInput
    Users?: UsersUpdateOneRequiredWithoutFolderNestedInput
    Folder?: FolderUpdateOneWithoutOther_FolderNestedInput
    other_Folder?: FolderUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUncheckedUpdateManyWithoutFolderNestedInput
    other_Folder?: FolderUncheckedUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    ownerId: string
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FolderSharesCreateInput = {
    accessLevel?: $Enums.AccessLevel
    Folder: FolderCreateNestedOneWithoutFolderSharesInput
    Users: UsersCreateNestedOneWithoutFolderSharesInput
  }

  export type FolderSharesUncheckedCreateInput = {
    userId: string
    folderId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FolderSharesUpdateInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    Folder?: FolderUpdateOneRequiredWithoutFolderSharesNestedInput
    Users?: UsersUpdateOneRequiredWithoutFolderSharesNestedInput
  }

  export type FolderSharesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderSharesCreateManyInput = {
    userId: string
    folderId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FolderSharesUpdateManyMutationInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderSharesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type Liked_ContentCreateInput = {
    mediatype: $Enums.MediaType
    contentid: number
    Users: UsersCreateNestedOneWithoutLiked_ContentInput
  }

  export type Liked_ContentUncheckedCreateInput = {
    userid: string
    mediatype: $Enums.MediaType
    contentid: number
  }

  export type Liked_ContentUpdateInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
    Users?: UsersUpdateOneRequiredWithoutLiked_ContentNestedInput
  }

  export type Liked_ContentUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type Liked_ContentCreateManyInput = {
    userid: string
    mediatype: $Enums.MediaType
    contentid: number
  }

  export type Liked_ContentUpdateManyMutationInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type Liked_ContentUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type MangaCreateInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksCreateNestedManyWithoutMangaInput
    Users: UsersCreateNestedOneWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMangaInput
  }

  export type MangaUncheckedCreateInput = {
    mangaid?: string
    authorid: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMangaInput
  }

  export type MangaUpdateInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutMangaNestedInput
    Users?: UsersUpdateOneRequiredWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMangaNestedInput
  }

  export type MangaCreateManyInput = {
    mangaid?: string
    authorid: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MangaUpdateManyMutationInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MangaUncheckedUpdateManyInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MoviesCreateInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksCreateNestedManyWithoutMoviesInput
    Users: UsersCreateNestedOneWithoutMoviesInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMoviesInput
  }

  export type MoviesUncheckedCreateInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    authorid: string
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMoviesInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMoviesInput
  }

  export type MoviesUpdateInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUpdateManyWithoutMoviesNestedInput
    Users?: UsersUpdateOneRequiredWithoutMoviesNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMoviesNestedInput
  }

  export type MoviesUncheckedUpdateInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    authorid?: StringFieldUpdateOperationsInput | string
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMoviesNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMoviesNestedInput
  }

  export type MoviesCreateManyInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    authorid: string
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MoviesUpdateManyMutationInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MoviesUncheckedUpdateManyInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    authorid?: StringFieldUpdateOperationsInput | string
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type PollsCreateInput = {
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
    Users: UsersCreateNestedOneWithoutPollsInput
  }

  export type PollsUncheckedCreateInput = {
    pollid?: number
    author: string
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
  }

  export type PollsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    Users?: UsersUpdateOneRequiredWithoutPollsNestedInput
  }

  export type PollsUncheckedUpdateInput = {
    pollid?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type PollsCreateManyInput = {
    pollid?: number
    author: string
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
  }

  export type PollsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type PollsUncheckedUpdateManyInput = {
    pollid?: IntFieldUpdateOperationsInput | number
    author?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewsCreateInput = {
    parentid: string
    mediatype: $Enums.MediaType
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    Users: UsersCreateNestedOneWithoutReviewsInput
  }

  export type ReviewsUncheckedCreateInput = {
    reviewid?: number
    parentid: string
    mediatype: $Enums.MediaType
    userid: string
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type ReviewsUpdateInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    Users?: UsersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewsUncheckedUpdateInput = {
    reviewid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    userid?: StringFieldUpdateOperationsInput | string
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReviewsCreateManyInput = {
    reviewid?: number
    parentid: string
    mediatype: $Enums.MediaType
    userid: string
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type ReviewsUpdateManyMutationInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReviewsUncheckedUpdateManyInput = {
    reviewid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    userid?: StringFieldUpdateOperationsInput | string
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Shopping_CartCreateInput = {
    quantity?: number | null
    Store: StoreCreateNestedOneWithoutShopping_CartInput
    Users: UsersCreateNestedOneWithoutShopping_CartInput
  }

  export type Shopping_CartUncheckedCreateInput = {
    userid: string
    storeid: string
    quantity?: number | null
  }

  export type Shopping_CartUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Store?: StoreUpdateOneRequiredWithoutShopping_CartNestedInput
    Users?: UsersUpdateOneRequiredWithoutShopping_CartNestedInput
  }

  export type Shopping_CartUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    storeid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Shopping_CartCreateManyInput = {
    userid: string
    storeid: string
    quantity?: number | null
  }

  export type Shopping_CartUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Shopping_CartUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    storeid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreCreateInput = {
    storeid?: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutStoreInput
    Users: UsersCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    storeid?: string
    sellerid: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUpdateManyWithoutStoreNestedInput
    Users?: UsersUpdateOneRequiredWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    sellerid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    storeid?: string
    sellerid: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type StoreUpdateManyMutationInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type StoreUncheckedUpdateManyInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    sellerid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type Subscription_TiersCreateInput = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon?: string | null
    store_discount?: number
    game_discount?: number
    permissions?: Subscription_TiersCreatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersCreatefeaturesInput | string[]
    userid?: string | null
    Users?: UsersCreateNestedManyWithoutSubscription_tierInput
  }

  export type Subscription_TiersUncheckedCreateInput = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon?: string | null
    store_discount?: number
    game_discount?: number
    permissions?: Subscription_TiersCreatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersCreatefeaturesInput | string[]
    userid?: string | null
    Users?: UsersUncheckedCreateNestedManyWithoutSubscription_tierInput
  }

  export type Subscription_TiersUpdateInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUpdateManyWithoutSubscription_tierNestedInput
  }

  export type Subscription_TiersUncheckedUpdateInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    Users?: UsersUncheckedUpdateManyWithoutSubscription_tierNestedInput
  }

  export type Subscription_TiersCreateManyInput = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon?: string | null
    store_discount?: number
    game_discount?: number
    permissions?: Subscription_TiersCreatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersCreatefeaturesInput | string[]
    userid?: string | null
  }

  export type Subscription_TiersUpdateManyMutationInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Subscription_TiersUncheckedUpdateManyInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TitleTranslationCreateInput = {
    parentid: number
    mediatype: $Enums.MediaType
    title: string
    language: string
  }

  export type TitleTranslationUncheckedCreateInput = {
    translationid?: number
    parentid: number
    mediatype: $Enums.MediaType
    title: string
    language: string
  }

  export type TitleTranslationUpdateInput = {
    parentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type TitleTranslationUncheckedUpdateInput = {
    translationid?: IntFieldUpdateOperationsInput | number
    parentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type TitleTranslationCreateManyInput = {
    translationid?: number
    parentid: number
    mediatype: $Enums.MediaType
    title: string
    language: string
  }

  export type TitleTranslationUpdateManyMutationInput = {
    parentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type TitleTranslationUncheckedUpdateManyInput = {
    translationid?: IntFieldUpdateOperationsInput | number
    parentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    title?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type User_ActivityCreateInput = {
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
    Users: UsersCreateNestedOneWithoutUser_ActivityInput
  }

  export type User_ActivityUncheckedCreateInput = {
    userid: string
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
  }

  export type User_ActivityUpdateInput = {
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutUser_ActivityNestedInput
  }

  export type User_ActivityUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_ActivityCreateManyInput = {
    userid: string
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
  }

  export type User_ActivityUpdateManyMutationInput = {
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_ActivityUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_BookmarksCreateInput = {
    mediatype: $Enums.MediaType
    parentid: string
    Users: UsersCreateNestedOneWithoutUser_BookmarksInput
  }

  export type User_BookmarksUncheckedCreateInput = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type User_BookmarksUpdateInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutUser_BookmarksNestedInput
  }

  export type User_BookmarksUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_BookmarksCreateManyInput = {
    userid: string
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type User_BookmarksUpdateManyMutationInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_BookmarksUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_RatingsCreateInput = {
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
    Users: UsersCreateNestedOneWithoutUser_RatingsInput
  }

  export type User_RatingsUncheckedCreateInput = {
    userid: string
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
  }

  export type User_RatingsUpdateInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
    Users?: UsersUpdateOneRequiredWithoutUser_RatingsNestedInput
  }

  export type User_RatingsUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type User_RatingsCreateManyInput = {
    userid: string
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
  }

  export type User_RatingsUpdateManyMutationInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type User_RatingsUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type UsersCreateInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
  }

  export type UsersUpdateManyMutationInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
  }

  export type UsersUncheckedUpdateManyInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
  }

  export type VideosCreateInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksCreateNestedManyWithoutVideosInput
    Comments?: CommentsCreateNestedManyWithoutVideosInput
    Users: UsersCreateNestedOneWithoutVideosInput
  }

  export type VideosUncheckedCreateInput = {
    videoid?: string
    title: string
    authorid: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeUncheckedCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutVideosInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideosUpdateInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUpdateManyWithoutVideosNestedInput
    Users?: UsersUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUncheckedUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideosCreateManyInput = {
    videoid?: string
    title: string
    authorid: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
  }

  export type VideosUpdateManyMutationInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
  }

  export type VideosUncheckedUpdateManyInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
  }

  export type Website_VariablesCreateInput = {
    website_version: string
    footer_items?: Website_VariablesCreatefooter_itemsInput | string[]
    footer_separator?: string | null
    important_info?: string | null
    rootContentPath?: string | null
    loggedin_nav_items?: Website_VariablesCreateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesCreateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesUncheckedCreateInput = {
    website_version: string
    footer_items?: Website_VariablesCreatefooter_itemsInput | string[]
    footer_separator?: string | null
    important_info?: string | null
    rootContentPath?: string | null
    loggedin_nav_items?: Website_VariablesCreateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesCreateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesUpdateInput = {
    website_version?: StringFieldUpdateOperationsInput | string
    footer_items?: Website_VariablesUpdatefooter_itemsInput | string[]
    footer_separator?: NullableStringFieldUpdateOperationsInput | string | null
    important_info?: NullableStringFieldUpdateOperationsInput | string | null
    rootContentPath?: NullableStringFieldUpdateOperationsInput | string | null
    loggedin_nav_items?: Website_VariablesUpdateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesUpdateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesUncheckedUpdateInput = {
    website_version?: StringFieldUpdateOperationsInput | string
    footer_items?: Website_VariablesUpdatefooter_itemsInput | string[]
    footer_separator?: NullableStringFieldUpdateOperationsInput | string | null
    important_info?: NullableStringFieldUpdateOperationsInput | string | null
    rootContentPath?: NullableStringFieldUpdateOperationsInput | string | null
    loggedin_nav_items?: Website_VariablesUpdateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesUpdateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesCreateManyInput = {
    website_version: string
    footer_items?: Website_VariablesCreatefooter_itemsInput | string[]
    footer_separator?: string | null
    important_info?: string | null
    rootContentPath?: string | null
    loggedin_nav_items?: Website_VariablesCreateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesCreateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesUpdateManyMutationInput = {
    website_version?: StringFieldUpdateOperationsInput | string
    footer_items?: Website_VariablesUpdatefooter_itemsInput | string[]
    footer_separator?: NullableStringFieldUpdateOperationsInput | string | null
    important_info?: NullableStringFieldUpdateOperationsInput | string | null
    rootContentPath?: NullableStringFieldUpdateOperationsInput | string | null
    loggedin_nav_items?: Website_VariablesUpdateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesUpdateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type Website_VariablesUncheckedUpdateManyInput = {
    website_version?: StringFieldUpdateOperationsInput | string
    footer_items?: Website_VariablesUpdatefooter_itemsInput | string[]
    footer_separator?: NullableStringFieldUpdateOperationsInput | string | null
    important_info?: NullableStringFieldUpdateOperationsInput | string | null
    rootContentPath?: NullableStringFieldUpdateOperationsInput | string | null
    loggedin_nav_items?: Website_VariablesUpdateloggedin_nav_itemsInput | $Enums.MediaType[]
    loggedout_nav_items?: Website_VariablesUpdateloggedout_nav_itemsInput | $Enums.MediaType[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type EnumMediaGenreNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaGenre[] | ListEnumMediaGenreFieldRefInput<$PrismaModel> | null
    has?: $Enums.MediaGenre | EnumMediaGenreFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.MediaGenre[] | ListEnumMediaGenreFieldRefInput<$PrismaModel>
    hasSome?: $Enums.MediaGenre[] | ListEnumMediaGenreFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MangaNullableScalarRelationFilter = {
    is?: MangaWhereInput | null
    isNot?: MangaWhereInput | null
  }

  export type VideosNullableScalarRelationFilter = {
    is?: VideosWhereInput | null
    isNot?: VideosWhereInput | null
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type Anime_AuthorsListRelationFilter = {
    every?: Anime_AuthorsWhereInput
    some?: Anime_AuthorsWhereInput
    none?: Anime_AuthorsWhereInput
  }

  export type BookmarksListRelationFilter = {
    every?: BookmarksWhereInput
    some?: BookmarksWhereInput
    none?: BookmarksWhereInput
  }

  export type ContentGroupMediaListRelationFilter = {
    every?: ContentGroupMediaWhereInput
    some?: ContentGroupMediaWhereInput
    none?: ContentGroupMediaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Anime_AuthorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentGroupMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnimeCountOrderByAggregateInput = {
    animeid?: SortOrder
    description?: SortOrder
    trailerid?: SortOrder
    upload_date?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    authorid?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
    age_rating?: SortOrder
    mangaid?: SortOrder
    title?: SortOrder
    type?: SortOrder
    MediaGenre?: SortOrder
    anime_key_visual?: SortOrder
    visible?: SortOrder
  }

  export type AnimeAvgOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
  }

  export type AnimeMaxOrderByAggregateInput = {
    animeid?: SortOrder
    description?: SortOrder
    trailerid?: SortOrder
    upload_date?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    authorid?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
    age_rating?: SortOrder
    mangaid?: SortOrder
    title?: SortOrder
    type?: SortOrder
    anime_key_visual?: SortOrder
    visible?: SortOrder
  }

  export type AnimeMinOrderByAggregateInput = {
    animeid?: SortOrder
    description?: SortOrder
    trailerid?: SortOrder
    upload_date?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    authorid?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
    age_rating?: SortOrder
    mangaid?: SortOrder
    title?: SortOrder
    type?: SortOrder
    anime_key_visual?: SortOrder
    visible?: SortOrder
  }

  export type AnimeSumOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    activity?: SortOrder
    average_rating?: SortOrder
    anime_ratings?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AnimeScalarRelationFilter = {
    is?: AnimeWhereInput
    isNot?: AnimeWhereInput
  }

  export type Anime_AuthorsAnimeidAuthoridCompoundUniqueInput = {
    animeid: string
    authorid: string
  }

  export type Anime_AuthorsCountOrderByAggregateInput = {
    animeid?: SortOrder
    authorid?: SortOrder
  }

  export type Anime_AuthorsMaxOrderByAggregateInput = {
    animeid?: SortOrder
    authorid?: SortOrder
  }

  export type Anime_AuthorsMinOrderByAggregateInput = {
    animeid?: SortOrder
    authorid?: SortOrder
  }

  export type MangaScalarRelationFilter = {
    is?: MangaWhereInput
    isNot?: MangaWhereInput
  }

  export type MoviesScalarRelationFilter = {
    is?: MoviesWhereInput
    isNot?: MoviesWhereInput
  }

  export type VideosScalarRelationFilter = {
    is?: VideosWhereInput
    isNot?: VideosWhereInput
  }

  export type BookmarksUseridParentidMediatypeCompoundUniqueInput = {
    userid: string
    parentid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksCountOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type BookmarksMaxOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type BookmarksMinOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContentUnitScalarRelationFilter = {
    is?: ContentUnitWhereInput
    isNot?: ContentUnitWhereInput
  }

  export type CommentsCountOrderByAggregateInput = {
    commentid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    mediatime?: SortOrder
    userid?: SortOrder
    comment_text?: SortOrder
    comment_date?: SortOrder
    parent_comment_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type CommentsAvgOrderByAggregateInput = {
    commentid?: SortOrder
    mediatime?: SortOrder
    parent_comment_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type CommentsMaxOrderByAggregateInput = {
    commentid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    mediatime?: SortOrder
    userid?: SortOrder
    comment_text?: SortOrder
    comment_date?: SortOrder
    parent_comment_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type CommentsMinOrderByAggregateInput = {
    commentid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    mediatime?: SortOrder
    userid?: SortOrder
    comment_text?: SortOrder
    comment_date?: SortOrder
    parent_comment_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type CommentsSumOrderByAggregateInput = {
    commentid?: SortOrder
    mediatime?: SortOrder
    parent_comment_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContentGroupCountOrderByAggregateInput = {
    seasonid?: SortOrder
    season_number?: SortOrder
    release_date?: SortOrder
    visible?: SortOrder
    season_path?: SortOrder
  }

  export type ContentGroupAvgOrderByAggregateInput = {
    season_number?: SortOrder
  }

  export type ContentGroupMaxOrderByAggregateInput = {
    seasonid?: SortOrder
    season_number?: SortOrder
    release_date?: SortOrder
    visible?: SortOrder
    season_path?: SortOrder
  }

  export type ContentGroupMinOrderByAggregateInput = {
    seasonid?: SortOrder
    season_number?: SortOrder
    release_date?: SortOrder
    visible?: SortOrder
    season_path?: SortOrder
  }

  export type ContentGroupSumOrderByAggregateInput = {
    season_number?: SortOrder
  }

  export type AnimeNullableScalarRelationFilter = {
    is?: AnimeWhereInput | null
    isNot?: AnimeWhereInput | null
  }

  export type MoviesNullableScalarRelationFilter = {
    is?: MoviesWhereInput | null
    isNot?: MoviesWhereInput | null
  }

  export type ContentGroupScalarRelationFilter = {
    is?: ContentGroupWhereInput
    isNot?: ContentGroupWhereInput
  }

  export type ContentUnitListRelationFilter = {
    every?: ContentUnitWhereInput
    some?: ContentUnitWhereInput
    none?: ContentUnitWhereInput
  }

  export type ContentUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentGroupMediaSeasonidMediaidMediatypeCompoundUniqueInput = {
    seasonid: string
    mediaid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaCountOrderByAggregateInput = {
    id?: SortOrder
    seasonid?: SortOrder
    mediaid?: SortOrder
    mediatype?: SortOrder
  }

  export type ContentGroupMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonid?: SortOrder
    mediaid?: SortOrder
    mediatype?: SortOrder
  }

  export type ContentGroupMediaMinOrderByAggregateInput = {
    id?: SortOrder
    seasonid?: SortOrder
    mediaid?: SortOrder
    mediatype?: SortOrder
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type ContentGroupMediaScalarRelationFilter = {
    is?: ContentGroupMediaWhereInput
    isNot?: ContentGroupMediaWhereInput
  }

  export type CommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentUnitCountOrderByAggregateInput = {
    episodeid?: SortOrder
    contentgroupid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    visible?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
    episode_path?: SortOrder
    thumbnail?: SortOrder
  }

  export type ContentUnitAvgOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
  }

  export type ContentUnitMaxOrderByAggregateInput = {
    episodeid?: SortOrder
    contentgroupid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    visible?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
    episode_path?: SortOrder
    thumbnail?: SortOrder
  }

  export type ContentUnitMinOrderByAggregateInput = {
    episodeid?: SortOrder
    contentgroupid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    visible?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
    episode_path?: SortOrder
    thumbnail?: SortOrder
  }

  export type ContentUnitSumOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    episode_number?: SortOrder
    views?: SortOrder
    duration?: SortOrder
  }

  export type Disliked_ContentUseridContentidMediatypeCompoundUniqueInput = {
    userid: string
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Disliked_ContentCountOrderByAggregateInput = {
    userid?: SortOrder
    contentid?: SortOrder
    mediatype?: SortOrder
  }

  export type Disliked_ContentAvgOrderByAggregateInput = {
    contentid?: SortOrder
  }

  export type Disliked_ContentMaxOrderByAggregateInput = {
    userid?: SortOrder
    contentid?: SortOrder
    mediatype?: SortOrder
  }

  export type Disliked_ContentMinOrderByAggregateInput = {
    userid?: SortOrder
    contentid?: SortOrder
    mediatype?: SortOrder
  }

  export type Disliked_ContentSumOrderByAggregateInput = {
    contentid?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type FileSharesListRelationFilter = {
    every?: FileSharesWhereInput
    some?: FileSharesWhereInput
    none?: FileSharesWhereInput
  }

  export type FileSharesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOwnerIdFolderIdNameCompoundUniqueInput = {
    ownerId: string
    folderId: string
    name: string
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    path?: SortOrder
    extension?: SortOrder
    folderId?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    isShared?: SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    checksum?: SortOrder
    downloadCount?: SortOrder
    previewEnabled?: SortOrder
    isPublic?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
    downloadCount?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    path?: SortOrder
    extension?: SortOrder
    folderId?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    isShared?: SortOrder
    ownerId?: SortOrder
    checksum?: SortOrder
    downloadCount?: SortOrder
    previewEnabled?: SortOrder
    isPublic?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    path?: SortOrder
    extension?: SortOrder
    folderId?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    isShared?: SortOrder
    ownerId?: SortOrder
    checksum?: SortOrder
    downloadCount?: SortOrder
    previewEnabled?: SortOrder
    isPublic?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
    downloadCount?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type FileScalarRelationFilter = {
    is?: FileWhereInput
    isNot?: FileWhereInput
  }

  export type FileSharesUserIdFileIdCompoundUniqueInput = {
    userId: string
    fileId: string
  }

  export type FileSharesCountOrderByAggregateInput = {
    userId?: SortOrder
    fileId?: SortOrder
    accessLevel?: SortOrder
  }

  export type FileSharesMaxOrderByAggregateInput = {
    userId?: SortOrder
    fileId?: SortOrder
    accessLevel?: SortOrder
  }

  export type FileSharesMinOrderByAggregateInput = {
    userId?: SortOrder
    fileId?: SortOrder
    accessLevel?: SortOrder
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type FolderSharesListRelationFilter = {
    every?: FolderSharesWhereInput
    some?: FolderSharesWhereInput
    none?: FolderSharesWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderSharesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOwnerIdIdCompoundUniqueInput = {
    ownerId: string
    id: string
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    ownerId?: SortOrder
    tags?: SortOrder
    accessCount?: SortOrder
    totalSize?: SortOrder
    parentFolderId?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FolderAvgOrderByAggregateInput = {
    accessCount?: SortOrder
    totalSize?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    ownerId?: SortOrder
    accessCount?: SortOrder
    totalSize?: SortOrder
    parentFolderId?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastAccessed?: SortOrder
    ownerId?: SortOrder
    accessCount?: SortOrder
    totalSize?: SortOrder
    parentFolderId?: SortOrder
    filetype?: SortOrder
    location?: SortOrder
  }

  export type FolderSumOrderByAggregateInput = {
    accessCount?: SortOrder
    totalSize?: SortOrder
  }

  export type FolderScalarRelationFilter = {
    is?: FolderWhereInput
    isNot?: FolderWhereInput
  }

  export type FolderSharesUserIdFolderIdCompoundUniqueInput = {
    userId: string
    folderId: string
  }

  export type FolderSharesCountOrderByAggregateInput = {
    userId?: SortOrder
    folderId?: SortOrder
    accessLevel?: SortOrder
  }

  export type FolderSharesMaxOrderByAggregateInput = {
    userId?: SortOrder
    folderId?: SortOrder
    accessLevel?: SortOrder
  }

  export type FolderSharesMinOrderByAggregateInput = {
    userId?: SortOrder
    folderId?: SortOrder
    accessLevel?: SortOrder
  }

  export type Liked_ContentUseridContentidMediatypeCompoundUniqueInput = {
    userid: string
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Liked_ContentCountOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    contentid?: SortOrder
  }

  export type Liked_ContentAvgOrderByAggregateInput = {
    contentid?: SortOrder
  }

  export type Liked_ContentMaxOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    contentid?: SortOrder
  }

  export type Liked_ContentMinOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    contentid?: SortOrder
  }

  export type Liked_ContentSumOrderByAggregateInput = {
    contentid?: SortOrder
  }

  export type AnimeListRelationFilter = {
    every?: AnimeWhereInput
    some?: AnimeWhereInput
    none?: AnimeWhereInput
  }

  export type AnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MangaCountOrderByAggregateInput = {
    mangaid?: SortOrder
    authorid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    cover_iamge?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    age_rating?: SortOrder
    MediaGenre?: SortOrder
  }

  export type MangaAvgOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type MangaMaxOrderByAggregateInput = {
    mangaid?: SortOrder
    authorid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    cover_iamge?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    age_rating?: SortOrder
  }

  export type MangaMinOrderByAggregateInput = {
    mangaid?: SortOrder
    authorid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    cover_iamge?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    age_rating?: SortOrder
  }

  export type MangaSumOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type MoviesCountOrderByAggregateInput = {
    movieid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_id_reference?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    showbanner?: SortOrder
    age_rating?: SortOrder
    authorid?: SortOrder
    media_reference_type?: SortOrder
    MediaGenre?: SortOrder
  }

  export type MoviesAvgOrderByAggregateInput = {
    media_id_reference?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type MoviesMaxOrderByAggregateInput = {
    movieid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_id_reference?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    showbanner?: SortOrder
    age_rating?: SortOrder
    authorid?: SortOrder
    media_reference_type?: SortOrder
  }

  export type MoviesMinOrderByAggregateInput = {
    movieid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_id_reference?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    showbanner?: SortOrder
    age_rating?: SortOrder
    authorid?: SortOrder
    media_reference_type?: SortOrder
  }

  export type MoviesSumOrderByAggregateInput = {
    media_id_reference?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type PollsCountOrderByAggregateInput = {
    pollid?: SortOrder
    author?: SortOrder
    title?: SortOrder
    description?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    date?: SortOrder
    category?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    views?: SortOrder
  }

  export type PollsAvgOrderByAggregateInput = {
    pollid?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
  }

  export type PollsMaxOrderByAggregateInput = {
    pollid?: SortOrder
    author?: SortOrder
    title?: SortOrder
    description?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    date?: SortOrder
    category?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    views?: SortOrder
  }

  export type PollsMinOrderByAggregateInput = {
    pollid?: SortOrder
    author?: SortOrder
    title?: SortOrder
    description?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    date?: SortOrder
    category?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    views?: SortOrder
  }

  export type PollsSumOrderByAggregateInput = {
    pollid?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
  }

  export type ReviewsCountOrderByAggregateInput = {
    reviewid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    userid?: SortOrder
    review_text?: SortOrder
    review_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type ReviewsAvgOrderByAggregateInput = {
    reviewid?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type ReviewsMaxOrderByAggregateInput = {
    reviewid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    userid?: SortOrder
    review_text?: SortOrder
    review_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type ReviewsMinOrderByAggregateInput = {
    reviewid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    userid?: SortOrder
    review_text?: SortOrder
    review_date?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type ReviewsSumOrderByAggregateInput = {
    reviewid?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type Shopping_CartUseridStoreidCompoundUniqueInput = {
    userid: string
    storeid: string
  }

  export type Shopping_CartCountOrderByAggregateInput = {
    userid?: SortOrder
    storeid?: SortOrder
    quantity?: SortOrder
  }

  export type Shopping_CartAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type Shopping_CartMaxOrderByAggregateInput = {
    userid?: SortOrder
    storeid?: SortOrder
    quantity?: SortOrder
  }

  export type Shopping_CartMinOrderByAggregateInput = {
    userid?: SortOrder
    storeid?: SortOrder
    quantity?: SortOrder
  }

  export type Shopping_CartSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Shopping_CartListRelationFilter = {
    every?: Shopping_CartWhereInput
    some?: Shopping_CartWhereInput
    none?: Shopping_CartWhereInput
  }

  export type Shopping_CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    storeid?: SortOrder
    sellerid?: SortOrder
    title?: SortOrder
    num_in_stock?: SortOrder
    release_date?: SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    description?: SortOrder
    num_of_carts?: SortOrder
    images?: SortOrder
    media_id_reference?: SortOrder
    sales?: SortOrder
    reference_media_type?: SortOrder
    MediaGenre?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    num_in_stock?: SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    num_of_carts?: SortOrder
    media_id_reference?: SortOrder
    sales?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    storeid?: SortOrder
    sellerid?: SortOrder
    title?: SortOrder
    num_in_stock?: SortOrder
    release_date?: SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    description?: SortOrder
    num_of_carts?: SortOrder
    images?: SortOrder
    media_id_reference?: SortOrder
    sales?: SortOrder
    reference_media_type?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    storeid?: SortOrder
    sellerid?: SortOrder
    title?: SortOrder
    num_in_stock?: SortOrder
    release_date?: SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    description?: SortOrder
    num_of_carts?: SortOrder
    images?: SortOrder
    media_id_reference?: SortOrder
    sales?: SortOrder
    reference_media_type?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    num_in_stock?: SortOrder
    original_price?: SortOrder
    discount_price?: SortOrder
    discount_percent?: SortOrder
    shipping_price?: SortOrder
    num_of_carts?: SortOrder
    media_id_reference?: SortOrder
    sales?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumnavItemsNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.navItems[] | ListEnumnavItemsFieldRefInput<$PrismaModel> | null
    has?: $Enums.navItems | EnumnavItemsFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.navItems[] | ListEnumnavItemsFieldRefInput<$PrismaModel>
    hasSome?: $Enums.navItems[] | ListEnumnavItemsFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Subscription_TiersCountOrderByAggregateInput = {
    tierid?: SortOrder
    name?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    icon?: SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
    permissions?: SortOrder
    features?: SortOrder
    userid?: SortOrder
  }

  export type Subscription_TiersAvgOrderByAggregateInput = {
    tierid?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
  }

  export type Subscription_TiersMaxOrderByAggregateInput = {
    tierid?: SortOrder
    name?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    icon?: SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
    userid?: SortOrder
  }

  export type Subscription_TiersMinOrderByAggregateInput = {
    tierid?: SortOrder
    name?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    icon?: SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
    userid?: SortOrder
  }

  export type Subscription_TiersSumOrderByAggregateInput = {
    tierid?: SortOrder
    price?: SortOrder
    votepower?: SortOrder
    cloudlimit?: SortOrder
    store_discount?: SortOrder
    game_discount?: SortOrder
  }

  export type TitleTranslationCountOrderByAggregateInput = {
    translationid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    title?: SortOrder
    language?: SortOrder
  }

  export type TitleTranslationAvgOrderByAggregateInput = {
    translationid?: SortOrder
    parentid?: SortOrder
  }

  export type TitleTranslationMaxOrderByAggregateInput = {
    translationid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    title?: SortOrder
    language?: SortOrder
  }

  export type TitleTranslationMinOrderByAggregateInput = {
    translationid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    title?: SortOrder
    language?: SortOrder
  }

  export type TitleTranslationSumOrderByAggregateInput = {
    translationid?: SortOrder
    parentid?: SortOrder
  }

  export type User_ActivityUseridChild_contentParent_contentMediatypeCompoundUniqueInput = {
    userid: string
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
  }

  export type User_ActivityCountOrderByAggregateInput = {
    userid?: SortOrder
    child_content?: SortOrder
    parent_content?: SortOrder
    mediatype?: SortOrder
    stopping_point?: SortOrder
    date_watched?: SortOrder
  }

  export type User_ActivityAvgOrderByAggregateInput = {
    stopping_point?: SortOrder
  }

  export type User_ActivityMaxOrderByAggregateInput = {
    userid?: SortOrder
    child_content?: SortOrder
    parent_content?: SortOrder
    mediatype?: SortOrder
    stopping_point?: SortOrder
    date_watched?: SortOrder
  }

  export type User_ActivityMinOrderByAggregateInput = {
    userid?: SortOrder
    child_content?: SortOrder
    parent_content?: SortOrder
    mediatype?: SortOrder
    stopping_point?: SortOrder
    date_watched?: SortOrder
  }

  export type User_ActivitySumOrderByAggregateInput = {
    stopping_point?: SortOrder
  }

  export type User_BookmarksUseridParentidMediatypeCompoundUniqueInput = {
    userid: string
    parentid: string
    mediatype: $Enums.MediaType
  }

  export type User_BookmarksCountOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type User_BookmarksMaxOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type User_BookmarksMinOrderByAggregateInput = {
    userid?: SortOrder
    mediatype?: SortOrder
    parentid?: SortOrder
  }

  export type User_RatingsUseridParentidCompoundUniqueInput = {
    userid: string
    parentid: string
  }

  export type User_RatingsCountOrderByAggregateInput = {
    userid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    rating?: SortOrder
  }

  export type User_RatingsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type User_RatingsMaxOrderByAggregateInput = {
    userid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    rating?: SortOrder
  }

  export type User_RatingsMinOrderByAggregateInput = {
    userid?: SortOrder
    parentid?: SortOrder
    mediatype?: SortOrder
    rating?: SortOrder
  }

  export type User_RatingsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type Subscription_TiersNullableScalarRelationFilter = {
    is?: Subscription_TiersWhereInput | null
    isNot?: Subscription_TiersWhereInput | null
  }

  export type Disliked_ContentListRelationFilter = {
    every?: Disliked_ContentWhereInput
    some?: Disliked_ContentWhereInput
    none?: Disliked_ContentWhereInput
  }

  export type Liked_ContentListRelationFilter = {
    every?: Liked_ContentWhereInput
    some?: Liked_ContentWhereInput
    none?: Liked_ContentWhereInput
  }

  export type MangaListRelationFilter = {
    every?: MangaWhereInput
    some?: MangaWhereInput
    none?: MangaWhereInput
  }

  export type MoviesListRelationFilter = {
    every?: MoviesWhereInput
    some?: MoviesWhereInput
    none?: MoviesWhereInput
  }

  export type PollsListRelationFilter = {
    every?: PollsWhereInput
    some?: PollsWhereInput
    none?: PollsWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: ReviewsWhereInput
    some?: ReviewsWhereInput
    none?: ReviewsWhereInput
  }

  export type StoreListRelationFilter = {
    every?: StoreWhereInput
    some?: StoreWhereInput
    none?: StoreWhereInput
  }

  export type User_ActivityListRelationFilter = {
    every?: User_ActivityWhereInput
    some?: User_ActivityWhereInput
    none?: User_ActivityWhereInput
  }

  export type User_BookmarksListRelationFilter = {
    every?: User_BookmarksWhereInput
    some?: User_BookmarksWhereInput
    none?: User_BookmarksWhereInput
  }

  export type User_RatingsListRelationFilter = {
    every?: User_RatingsWhereInput
    some?: User_RatingsWhereInput
    none?: User_RatingsWhereInput
  }

  export type VideosListRelationFilter = {
    every?: VideosWhereInput
    some?: VideosWhereInput
    none?: VideosWhereInput
  }

  export type Disliked_ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Liked_ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MangaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoviesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type User_ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type User_BookmarksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type User_RatingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    userid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    date_joined?: SortOrder
    num_of_friends?: SortOrder
    num_of_followers?: SortOrder
    profile_picture?: SortOrder
    user_bio?: SortOrder
    two_factor?: SortOrder
    email_notifications?: SortOrder
    push_notifications?: SortOrder
    subscriptionTierId?: SortOrder
    usedstorage?: SortOrder
    accountType?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    num_of_friends?: SortOrder
    num_of_followers?: SortOrder
    subscriptionTierId?: SortOrder
    usedstorage?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    userid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    date_joined?: SortOrder
    num_of_friends?: SortOrder
    num_of_followers?: SortOrder
    profile_picture?: SortOrder
    user_bio?: SortOrder
    two_factor?: SortOrder
    email_notifications?: SortOrder
    push_notifications?: SortOrder
    subscriptionTierId?: SortOrder
    usedstorage?: SortOrder
    accountType?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    userid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    date_joined?: SortOrder
    num_of_friends?: SortOrder
    num_of_followers?: SortOrder
    profile_picture?: SortOrder
    user_bio?: SortOrder
    two_factor?: SortOrder
    email_notifications?: SortOrder
    push_notifications?: SortOrder
    subscriptionTierId?: SortOrder
    usedstorage?: SortOrder
    accountType?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    num_of_friends?: SortOrder
    num_of_followers?: SortOrder
    subscriptionTierId?: SortOrder
    usedstorage?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type VideosCountOrderByAggregateInput = {
    videoid?: SortOrder
    title?: SortOrder
    authorid?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_type?: SortOrder
    video_banner?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrder
    MediaGenre?: SortOrder
    thumbnail?: SortOrder
    views?: SortOrder
  }

  export type VideosAvgOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrder
    views?: SortOrder
  }

  export type VideosMaxOrderByAggregateInput = {
    videoid?: SortOrder
    title?: SortOrder
    authorid?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_type?: SortOrder
    video_banner?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrder
    thumbnail?: SortOrder
    views?: SortOrder
  }

  export type VideosMinOrderByAggregateInput = {
    videoid?: SortOrder
    title?: SortOrder
    authorid?: SortOrder
    description?: SortOrder
    release_date?: SortOrder
    media_type?: SortOrder
    video_banner?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrder
    thumbnail?: SortOrder
    views?: SortOrder
  }

  export type VideosSumOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    duration?: SortOrder
    views?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumMediaTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Website_VariablesCountOrderByAggregateInput = {
    website_version?: SortOrder
    footer_items?: SortOrder
    footer_separator?: SortOrder
    important_info?: SortOrder
    rootContentPath?: SortOrder
    loggedin_nav_items?: SortOrder
    loggedout_nav_items?: SortOrder
  }

  export type Website_VariablesMaxOrderByAggregateInput = {
    website_version?: SortOrder
    footer_separator?: SortOrder
    important_info?: SortOrder
    rootContentPath?: SortOrder
  }

  export type Website_VariablesMinOrderByAggregateInput = {
    website_version?: SortOrder
    footer_separator?: SortOrder
    important_info?: SortOrder
    rootContentPath?: SortOrder
  }

  export type AnimeCreateMediaGenreInput = {
    set: $Enums.MediaGenre[]
  }

  export type MangaCreateNestedOneWithoutAnimeInput = {
    create?: XOR<MangaCreateWithoutAnimeInput, MangaUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: MangaCreateOrConnectWithoutAnimeInput
    connect?: MangaWhereUniqueInput
  }

  export type VideosCreateNestedOneWithoutAnimeInput = {
    create?: XOR<VideosCreateWithoutAnimeInput, VideosUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: VideosCreateOrConnectWithoutAnimeInput
    connect?: VideosWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutAnimeInput = {
    create?: XOR<UsersCreateWithoutAnimeInput, UsersUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAnimeInput
    connect?: UsersWhereUniqueInput
  }

  export type Anime_AuthorsCreateNestedManyWithoutAnimeInput = {
    create?: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput> | Anime_AuthorsCreateWithoutAnimeInput[] | Anime_AuthorsUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutAnimeInput | Anime_AuthorsCreateOrConnectWithoutAnimeInput[]
    createMany?: Anime_AuthorsCreateManyAnimeInputEnvelope
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
  }

  export type BookmarksCreateNestedManyWithoutAnimeInput = {
    create?: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput> | BookmarksCreateWithoutAnimeInput[] | BookmarksUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutAnimeInput | BookmarksCreateOrConnectWithoutAnimeInput[]
    createMany?: BookmarksCreateManyAnimeInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type ContentGroupMediaCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput> | ContentGroupMediaCreateWithoutAnimeInput[] | ContentGroupMediaUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutAnimeInput | ContentGroupMediaCreateOrConnectWithoutAnimeInput[]
    createMany?: ContentGroupMediaCreateManyAnimeInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput> | Anime_AuthorsCreateWithoutAnimeInput[] | Anime_AuthorsUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutAnimeInput | Anime_AuthorsCreateOrConnectWithoutAnimeInput[]
    createMany?: Anime_AuthorsCreateManyAnimeInputEnvelope
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
  }

  export type BookmarksUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput> | BookmarksCreateWithoutAnimeInput[] | BookmarksUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutAnimeInput | BookmarksCreateOrConnectWithoutAnimeInput[]
    createMany?: BookmarksCreateManyAnimeInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput> | ContentGroupMediaCreateWithoutAnimeInput[] | ContentGroupMediaUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutAnimeInput | ContentGroupMediaCreateOrConnectWithoutAnimeInput[]
    createMany?: ContentGroupMediaCreateManyAnimeInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAgeRatingFieldUpdateOperationsInput = {
    set?: $Enums.AgeRating
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type AnimeUpdateMediaGenreInput = {
    set?: $Enums.MediaGenre[]
    push?: $Enums.MediaGenre | $Enums.MediaGenre[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MangaUpdateOneWithoutAnimeNestedInput = {
    create?: XOR<MangaCreateWithoutAnimeInput, MangaUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: MangaCreateOrConnectWithoutAnimeInput
    upsert?: MangaUpsertWithoutAnimeInput
    disconnect?: MangaWhereInput | boolean
    delete?: MangaWhereInput | boolean
    connect?: MangaWhereUniqueInput
    update?: XOR<XOR<MangaUpdateToOneWithWhereWithoutAnimeInput, MangaUpdateWithoutAnimeInput>, MangaUncheckedUpdateWithoutAnimeInput>
  }

  export type VideosUpdateOneWithoutAnimeNestedInput = {
    create?: XOR<VideosCreateWithoutAnimeInput, VideosUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: VideosCreateOrConnectWithoutAnimeInput
    upsert?: VideosUpsertWithoutAnimeInput
    disconnect?: VideosWhereInput | boolean
    delete?: VideosWhereInput | boolean
    connect?: VideosWhereUniqueInput
    update?: XOR<XOR<VideosUpdateToOneWithWhereWithoutAnimeInput, VideosUpdateWithoutAnimeInput>, VideosUncheckedUpdateWithoutAnimeInput>
  }

  export type UsersUpdateOneRequiredWithoutAnimeNestedInput = {
    create?: XOR<UsersCreateWithoutAnimeInput, UsersUncheckedCreateWithoutAnimeInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAnimeInput
    upsert?: UsersUpsertWithoutAnimeInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAnimeInput, UsersUpdateWithoutAnimeInput>, UsersUncheckedUpdateWithoutAnimeInput>
  }

  export type Anime_AuthorsUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput> | Anime_AuthorsCreateWithoutAnimeInput[] | Anime_AuthorsUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutAnimeInput | Anime_AuthorsCreateOrConnectWithoutAnimeInput[]
    upsert?: Anime_AuthorsUpsertWithWhereUniqueWithoutAnimeInput | Anime_AuthorsUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: Anime_AuthorsCreateManyAnimeInputEnvelope
    set?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    disconnect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    delete?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    update?: Anime_AuthorsUpdateWithWhereUniqueWithoutAnimeInput | Anime_AuthorsUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: Anime_AuthorsUpdateManyWithWhereWithoutAnimeInput | Anime_AuthorsUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
  }

  export type BookmarksUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput> | BookmarksCreateWithoutAnimeInput[] | BookmarksUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutAnimeInput | BookmarksCreateOrConnectWithoutAnimeInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutAnimeInput | BookmarksUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: BookmarksCreateManyAnimeInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutAnimeInput | BookmarksUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutAnimeInput | BookmarksUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type ContentGroupMediaUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput> | ContentGroupMediaCreateWithoutAnimeInput[] | ContentGroupMediaUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutAnimeInput | ContentGroupMediaCreateOrConnectWithoutAnimeInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutAnimeInput | ContentGroupMediaUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ContentGroupMediaCreateManyAnimeInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutAnimeInput | ContentGroupMediaUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutAnimeInput | ContentGroupMediaUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput> | Anime_AuthorsCreateWithoutAnimeInput[] | Anime_AuthorsUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutAnimeInput | Anime_AuthorsCreateOrConnectWithoutAnimeInput[]
    upsert?: Anime_AuthorsUpsertWithWhereUniqueWithoutAnimeInput | Anime_AuthorsUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: Anime_AuthorsCreateManyAnimeInputEnvelope
    set?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    disconnect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    delete?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    update?: Anime_AuthorsUpdateWithWhereUniqueWithoutAnimeInput | Anime_AuthorsUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: Anime_AuthorsUpdateManyWithWhereWithoutAnimeInput | Anime_AuthorsUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
  }

  export type BookmarksUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput> | BookmarksCreateWithoutAnimeInput[] | BookmarksUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutAnimeInput | BookmarksCreateOrConnectWithoutAnimeInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutAnimeInput | BookmarksUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: BookmarksCreateManyAnimeInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutAnimeInput | BookmarksUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutAnimeInput | BookmarksUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput> | ContentGroupMediaCreateWithoutAnimeInput[] | ContentGroupMediaUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutAnimeInput | ContentGroupMediaCreateOrConnectWithoutAnimeInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutAnimeInput | ContentGroupMediaUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ContentGroupMediaCreateManyAnimeInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutAnimeInput | ContentGroupMediaUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutAnimeInput | ContentGroupMediaUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutAnime_AuthorsInput = {
    create?: XOR<AnimeCreateWithoutAnime_AuthorsInput, AnimeUncheckedCreateWithoutAnime_AuthorsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutAnime_AuthorsInput
    connect?: AnimeWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutAnime_AuthorsInput = {
    create?: XOR<UsersCreateWithoutAnime_AuthorsInput, UsersUncheckedCreateWithoutAnime_AuthorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAnime_AuthorsInput
    connect?: UsersWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutAnime_AuthorsNestedInput = {
    create?: XOR<AnimeCreateWithoutAnime_AuthorsInput, AnimeUncheckedCreateWithoutAnime_AuthorsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutAnime_AuthorsInput
    upsert?: AnimeUpsertWithoutAnime_AuthorsInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutAnime_AuthorsInput, AnimeUpdateWithoutAnime_AuthorsInput>, AnimeUncheckedUpdateWithoutAnime_AuthorsInput>
  }

  export type UsersUpdateOneRequiredWithoutAnime_AuthorsNestedInput = {
    create?: XOR<UsersCreateWithoutAnime_AuthorsInput, UsersUncheckedCreateWithoutAnime_AuthorsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAnime_AuthorsInput
    upsert?: UsersUpsertWithoutAnime_AuthorsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAnime_AuthorsInput, UsersUpdateWithoutAnime_AuthorsInput>, UsersUncheckedUpdateWithoutAnime_AuthorsInput>
  }

  export type AnimeCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<AnimeCreateWithoutBookmarksInput, AnimeUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutBookmarksInput
    connect?: AnimeWhereUniqueInput
  }

  export type MangaCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<MangaCreateWithoutBookmarksInput, MangaUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: MangaCreateOrConnectWithoutBookmarksInput
    connect?: MangaWhereUniqueInput
  }

  export type MoviesCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<MoviesCreateWithoutBookmarksInput, MoviesUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: MoviesCreateOrConnectWithoutBookmarksInput
    connect?: MoviesWhereUniqueInput
  }

  export type VideosCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<VideosCreateWithoutBookmarksInput, VideosUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: VideosCreateOrConnectWithoutBookmarksInput
    connect?: VideosWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<UsersCreateWithoutBookmarksInput, UsersUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBookmarksInput
    connect?: UsersWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<AnimeCreateWithoutBookmarksInput, AnimeUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutBookmarksInput
    upsert?: AnimeUpsertWithoutBookmarksInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutBookmarksInput, AnimeUpdateWithoutBookmarksInput>, AnimeUncheckedUpdateWithoutBookmarksInput>
  }

  export type MangaUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<MangaCreateWithoutBookmarksInput, MangaUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: MangaCreateOrConnectWithoutBookmarksInput
    upsert?: MangaUpsertWithoutBookmarksInput
    connect?: MangaWhereUniqueInput
    update?: XOR<XOR<MangaUpdateToOneWithWhereWithoutBookmarksInput, MangaUpdateWithoutBookmarksInput>, MangaUncheckedUpdateWithoutBookmarksInput>
  }

  export type MoviesUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<MoviesCreateWithoutBookmarksInput, MoviesUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: MoviesCreateOrConnectWithoutBookmarksInput
    upsert?: MoviesUpsertWithoutBookmarksInput
    connect?: MoviesWhereUniqueInput
    update?: XOR<XOR<MoviesUpdateToOneWithWhereWithoutBookmarksInput, MoviesUpdateWithoutBookmarksInput>, MoviesUncheckedUpdateWithoutBookmarksInput>
  }

  export type VideosUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<VideosCreateWithoutBookmarksInput, VideosUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: VideosCreateOrConnectWithoutBookmarksInput
    upsert?: VideosUpsertWithoutBookmarksInput
    connect?: VideosWhereUniqueInput
    update?: XOR<XOR<VideosUpdateToOneWithWhereWithoutBookmarksInput, VideosUpdateWithoutBookmarksInput>, VideosUncheckedUpdateWithoutBookmarksInput>
  }

  export type UsersUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<UsersCreateWithoutBookmarksInput, UsersUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBookmarksInput
    upsert?: UsersUpsertWithoutBookmarksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBookmarksInput, UsersUpdateWithoutBookmarksInput>, UsersUncheckedUpdateWithoutBookmarksInput>
  }

  export type ContentUnitCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ContentUnitCreateWithoutCommentsInput, ContentUnitUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutCommentsInput
    connect?: ContentUnitWhereUniqueInput
  }

  export type VideosCreateNestedOneWithoutCommentsInput = {
    create?: XOR<VideosCreateWithoutCommentsInput, VideosUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideosCreateOrConnectWithoutCommentsInput
    connect?: VideosWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentsInput
    connect?: UsersWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContentUnitUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ContentUnitCreateWithoutCommentsInput, ContentUnitUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContentUnitCreateOrConnectWithoutCommentsInput
    upsert?: ContentUnitUpsertWithoutCommentsInput
    connect?: ContentUnitWhereUniqueInput
    update?: XOR<XOR<ContentUnitUpdateToOneWithWhereWithoutCommentsInput, ContentUnitUpdateWithoutCommentsInput>, ContentUnitUncheckedUpdateWithoutCommentsInput>
  }

  export type VideosUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<VideosCreateWithoutCommentsInput, VideosUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideosCreateOrConnectWithoutCommentsInput
    upsert?: VideosUpsertWithoutCommentsInput
    connect?: VideosWhereUniqueInput
    update?: XOR<XOR<VideosUpdateToOneWithWhereWithoutCommentsInput, VideosUpdateWithoutCommentsInput>, VideosUncheckedUpdateWithoutCommentsInput>
  }

  export type UsersUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentsInput
    upsert?: UsersUpsertWithoutCommentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCommentsInput, UsersUpdateWithoutCommentsInput>, UsersUncheckedUpdateWithoutCommentsInput>
  }

  export type ContentGroupMediaCreateNestedManyWithoutContentGroupInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput> | ContentGroupMediaCreateWithoutContentGroupInput[] | ContentGroupMediaUncheckedCreateWithoutContentGroupInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentGroupInput | ContentGroupMediaCreateOrConnectWithoutContentGroupInput[]
    createMany?: ContentGroupMediaCreateManyContentGroupInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type ContentGroupMediaUncheckedCreateNestedManyWithoutContentGroupInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput> | ContentGroupMediaCreateWithoutContentGroupInput[] | ContentGroupMediaUncheckedCreateWithoutContentGroupInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentGroupInput | ContentGroupMediaCreateOrConnectWithoutContentGroupInput[]
    createMany?: ContentGroupMediaCreateManyContentGroupInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type ContentGroupMediaUpdateManyWithoutContentGroupNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput> | ContentGroupMediaCreateWithoutContentGroupInput[] | ContentGroupMediaUncheckedCreateWithoutContentGroupInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentGroupInput | ContentGroupMediaCreateOrConnectWithoutContentGroupInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutContentGroupInput | ContentGroupMediaUpsertWithWhereUniqueWithoutContentGroupInput[]
    createMany?: ContentGroupMediaCreateManyContentGroupInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutContentGroupInput | ContentGroupMediaUpdateWithWhereUniqueWithoutContentGroupInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutContentGroupInput | ContentGroupMediaUpdateManyWithWhereWithoutContentGroupInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutContentGroupNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput> | ContentGroupMediaCreateWithoutContentGroupInput[] | ContentGroupMediaUncheckedCreateWithoutContentGroupInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentGroupInput | ContentGroupMediaCreateOrConnectWithoutContentGroupInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutContentGroupInput | ContentGroupMediaUpsertWithWhereUniqueWithoutContentGroupInput[]
    createMany?: ContentGroupMediaCreateManyContentGroupInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutContentGroupInput | ContentGroupMediaUpdateWithWhereUniqueWithoutContentGroupInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutContentGroupInput | ContentGroupMediaUpdateManyWithWhereWithoutContentGroupInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutContentGroupLinksInput = {
    create?: XOR<AnimeCreateWithoutContentGroupLinksInput, AnimeUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutContentGroupLinksInput
    connect?: AnimeWhereUniqueInput
  }

  export type MangaCreateNestedOneWithoutContentGroupLinksInput = {
    create?: XOR<MangaCreateWithoutContentGroupLinksInput, MangaUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: MangaCreateOrConnectWithoutContentGroupLinksInput
    connect?: MangaWhereUniqueInput
  }

  export type MoviesCreateNestedOneWithoutContentGroupLinksInput = {
    create?: XOR<MoviesCreateWithoutContentGroupLinksInput, MoviesUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: MoviesCreateOrConnectWithoutContentGroupLinksInput
    connect?: MoviesWhereUniqueInput
  }

  export type ContentGroupCreateNestedOneWithoutContentGroupLinksInput = {
    create?: XOR<ContentGroupCreateWithoutContentGroupLinksInput, ContentGroupUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: ContentGroupCreateOrConnectWithoutContentGroupLinksInput
    connect?: ContentGroupWhereUniqueInput
  }

  export type ContentUnitCreateNestedManyWithoutContentGroupMediaInput = {
    create?: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput> | ContentUnitCreateWithoutContentGroupMediaInput[] | ContentUnitUncheckedCreateWithoutContentGroupMediaInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutContentGroupMediaInput | ContentUnitCreateOrConnectWithoutContentGroupMediaInput[]
    createMany?: ContentUnitCreateManyContentGroupMediaInputEnvelope
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
  }

  export type ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput = {
    create?: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput> | ContentUnitCreateWithoutContentGroupMediaInput[] | ContentUnitUncheckedCreateWithoutContentGroupMediaInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutContentGroupMediaInput | ContentUnitCreateOrConnectWithoutContentGroupMediaInput[]
    createMany?: ContentUnitCreateManyContentGroupMediaInputEnvelope
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
  }

  export type AnimeUpdateOneWithoutContentGroupLinksNestedInput = {
    create?: XOR<AnimeCreateWithoutContentGroupLinksInput, AnimeUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutContentGroupLinksInput
    upsert?: AnimeUpsertWithoutContentGroupLinksInput
    disconnect?: AnimeWhereInput | boolean
    delete?: AnimeWhereInput | boolean
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutContentGroupLinksInput, AnimeUpdateWithoutContentGroupLinksInput>, AnimeUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type MangaUpdateOneWithoutContentGroupLinksNestedInput = {
    create?: XOR<MangaCreateWithoutContentGroupLinksInput, MangaUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: MangaCreateOrConnectWithoutContentGroupLinksInput
    upsert?: MangaUpsertWithoutContentGroupLinksInput
    disconnect?: MangaWhereInput | boolean
    delete?: MangaWhereInput | boolean
    connect?: MangaWhereUniqueInput
    update?: XOR<XOR<MangaUpdateToOneWithWhereWithoutContentGroupLinksInput, MangaUpdateWithoutContentGroupLinksInput>, MangaUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type MoviesUpdateOneWithoutContentGroupLinksNestedInput = {
    create?: XOR<MoviesCreateWithoutContentGroupLinksInput, MoviesUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: MoviesCreateOrConnectWithoutContentGroupLinksInput
    upsert?: MoviesUpsertWithoutContentGroupLinksInput
    disconnect?: MoviesWhereInput | boolean
    delete?: MoviesWhereInput | boolean
    connect?: MoviesWhereUniqueInput
    update?: XOR<XOR<MoviesUpdateToOneWithWhereWithoutContentGroupLinksInput, MoviesUpdateWithoutContentGroupLinksInput>, MoviesUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput = {
    create?: XOR<ContentGroupCreateWithoutContentGroupLinksInput, ContentGroupUncheckedCreateWithoutContentGroupLinksInput>
    connectOrCreate?: ContentGroupCreateOrConnectWithoutContentGroupLinksInput
    upsert?: ContentGroupUpsertWithoutContentGroupLinksInput
    connect?: ContentGroupWhereUniqueInput
    update?: XOR<XOR<ContentGroupUpdateToOneWithWhereWithoutContentGroupLinksInput, ContentGroupUpdateWithoutContentGroupLinksInput>, ContentGroupUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type ContentUnitUpdateManyWithoutContentGroupMediaNestedInput = {
    create?: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput> | ContentUnitCreateWithoutContentGroupMediaInput[] | ContentUnitUncheckedCreateWithoutContentGroupMediaInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutContentGroupMediaInput | ContentUnitCreateOrConnectWithoutContentGroupMediaInput[]
    upsert?: ContentUnitUpsertWithWhereUniqueWithoutContentGroupMediaInput | ContentUnitUpsertWithWhereUniqueWithoutContentGroupMediaInput[]
    createMany?: ContentUnitCreateManyContentGroupMediaInputEnvelope
    set?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    disconnect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    delete?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    update?: ContentUnitUpdateWithWhereUniqueWithoutContentGroupMediaInput | ContentUnitUpdateWithWhereUniqueWithoutContentGroupMediaInput[]
    updateMany?: ContentUnitUpdateManyWithWhereWithoutContentGroupMediaInput | ContentUnitUpdateManyWithWhereWithoutContentGroupMediaInput[]
    deleteMany?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
  }

  export type ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput = {
    create?: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput> | ContentUnitCreateWithoutContentGroupMediaInput[] | ContentUnitUncheckedCreateWithoutContentGroupMediaInput[]
    connectOrCreate?: ContentUnitCreateOrConnectWithoutContentGroupMediaInput | ContentUnitCreateOrConnectWithoutContentGroupMediaInput[]
    upsert?: ContentUnitUpsertWithWhereUniqueWithoutContentGroupMediaInput | ContentUnitUpsertWithWhereUniqueWithoutContentGroupMediaInput[]
    createMany?: ContentUnitCreateManyContentGroupMediaInputEnvelope
    set?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    disconnect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    delete?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    connect?: ContentUnitWhereUniqueInput | ContentUnitWhereUniqueInput[]
    update?: ContentUnitUpdateWithWhereUniqueWithoutContentGroupMediaInput | ContentUnitUpdateWithWhereUniqueWithoutContentGroupMediaInput[]
    updateMany?: ContentUnitUpdateManyWithWhereWithoutContentGroupMediaInput | ContentUnitUpdateManyWithWhereWithoutContentGroupMediaInput[]
    deleteMany?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
  }

  export type CommentsCreateNestedManyWithoutContentUnitInput = {
    create?: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput> | CommentsCreateWithoutContentUnitInput[] | CommentsUncheckedCreateWithoutContentUnitInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutContentUnitInput | CommentsCreateOrConnectWithoutContentUnitInput[]
    createMany?: CommentsCreateManyContentUnitInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type ContentGroupMediaCreateNestedOneWithoutContentUnitsInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentUnitsInput, ContentGroupMediaUncheckedCreateWithoutContentUnitsInput>
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentUnitsInput
    connect?: ContentGroupMediaWhereUniqueInput
  }

  export type CommentsUncheckedCreateNestedManyWithoutContentUnitInput = {
    create?: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput> | CommentsCreateWithoutContentUnitInput[] | CommentsUncheckedCreateWithoutContentUnitInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutContentUnitInput | CommentsCreateOrConnectWithoutContentUnitInput[]
    createMany?: CommentsCreateManyContentUnitInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type CommentsUpdateManyWithoutContentUnitNestedInput = {
    create?: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput> | CommentsCreateWithoutContentUnitInput[] | CommentsUncheckedCreateWithoutContentUnitInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutContentUnitInput | CommentsCreateOrConnectWithoutContentUnitInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutContentUnitInput | CommentsUpsertWithWhereUniqueWithoutContentUnitInput[]
    createMany?: CommentsCreateManyContentUnitInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutContentUnitInput | CommentsUpdateWithWhereUniqueWithoutContentUnitInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutContentUnitInput | CommentsUpdateManyWithWhereWithoutContentUnitInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type ContentGroupMediaUpdateOneRequiredWithoutContentUnitsNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutContentUnitsInput, ContentGroupMediaUncheckedCreateWithoutContentUnitsInput>
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutContentUnitsInput
    upsert?: ContentGroupMediaUpsertWithoutContentUnitsInput
    connect?: ContentGroupMediaWhereUniqueInput
    update?: XOR<XOR<ContentGroupMediaUpdateToOneWithWhereWithoutContentUnitsInput, ContentGroupMediaUpdateWithoutContentUnitsInput>, ContentGroupMediaUncheckedUpdateWithoutContentUnitsInput>
  }

  export type CommentsUncheckedUpdateManyWithoutContentUnitNestedInput = {
    create?: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput> | CommentsCreateWithoutContentUnitInput[] | CommentsUncheckedCreateWithoutContentUnitInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutContentUnitInput | CommentsCreateOrConnectWithoutContentUnitInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutContentUnitInput | CommentsUpsertWithWhereUniqueWithoutContentUnitInput[]
    createMany?: CommentsCreateManyContentUnitInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutContentUnitInput | CommentsUpdateWithWhereUniqueWithoutContentUnitInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutContentUnitInput | CommentsUpdateManyWithWhereWithoutContentUnitInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutDisliked_ContentInput = {
    create?: XOR<UsersCreateWithoutDisliked_ContentInput, UsersUncheckedCreateWithoutDisliked_ContentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDisliked_ContentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutDisliked_ContentNestedInput = {
    create?: XOR<UsersCreateWithoutDisliked_ContentInput, UsersUncheckedCreateWithoutDisliked_ContentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDisliked_ContentInput
    upsert?: UsersUpsertWithoutDisliked_ContentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutDisliked_ContentInput, UsersUpdateWithoutDisliked_ContentInput>, UsersUncheckedUpdateWithoutDisliked_ContentInput>
  }

  export type FileCreatetagsInput = {
    set: string[]
  }

  export type FolderCreateNestedOneWithoutFileInput = {
    create?: XOR<FolderCreateWithoutFileInput, FolderUncheckedCreateWithoutFileInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFileInput
    connect?: FolderWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFileInput = {
    create?: XOR<UsersCreateWithoutFileInput, UsersUncheckedCreateWithoutFileInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFileInput
    connect?: UsersWhereUniqueInput
  }

  export type FileSharesCreateNestedManyWithoutFileInput = {
    create?: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput> | FileSharesCreateWithoutFileInput[] | FileSharesUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutFileInput | FileSharesCreateOrConnectWithoutFileInput[]
    createMany?: FileSharesCreateManyFileInputEnvelope
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
  }

  export type FileSharesUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput> | FileSharesCreateWithoutFileInput[] | FileSharesUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutFileInput | FileSharesCreateOrConnectWithoutFileInput[]
    createMany?: FileSharesCreateManyFileInputEnvelope
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
  }

  export type FileUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type FolderUpdateOneWithoutFileNestedInput = {
    create?: XOR<FolderCreateWithoutFileInput, FolderUncheckedCreateWithoutFileInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFileInput
    upsert?: FolderUpsertWithoutFileInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFileInput, FolderUpdateWithoutFileInput>, FolderUncheckedUpdateWithoutFileInput>
  }

  export type UsersUpdateOneRequiredWithoutFileNestedInput = {
    create?: XOR<UsersCreateWithoutFileInput, UsersUncheckedCreateWithoutFileInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFileInput
    upsert?: UsersUpsertWithoutFileInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFileInput, UsersUpdateWithoutFileInput>, UsersUncheckedUpdateWithoutFileInput>
  }

  export type FileSharesUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput> | FileSharesCreateWithoutFileInput[] | FileSharesUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutFileInput | FileSharesCreateOrConnectWithoutFileInput[]
    upsert?: FileSharesUpsertWithWhereUniqueWithoutFileInput | FileSharesUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileSharesCreateManyFileInputEnvelope
    set?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    disconnect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    delete?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    update?: FileSharesUpdateWithWhereUniqueWithoutFileInput | FileSharesUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileSharesUpdateManyWithWhereWithoutFileInput | FileSharesUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
  }

  export type FileSharesUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput> | FileSharesCreateWithoutFileInput[] | FileSharesUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutFileInput | FileSharesCreateOrConnectWithoutFileInput[]
    upsert?: FileSharesUpsertWithWhereUniqueWithoutFileInput | FileSharesUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileSharesCreateManyFileInputEnvelope
    set?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    disconnect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    delete?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    update?: FileSharesUpdateWithWhereUniqueWithoutFileInput | FileSharesUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileSharesUpdateManyWithWhereWithoutFileInput | FileSharesUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutFileSharesInput = {
    create?: XOR<FileCreateWithoutFileSharesInput, FileUncheckedCreateWithoutFileSharesInput>
    connectOrCreate?: FileCreateOrConnectWithoutFileSharesInput
    connect?: FileWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFileSharesInput = {
    create?: XOR<UsersCreateWithoutFileSharesInput, UsersUncheckedCreateWithoutFileSharesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFileSharesInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type FileUpdateOneRequiredWithoutFileSharesNestedInput = {
    create?: XOR<FileCreateWithoutFileSharesInput, FileUncheckedCreateWithoutFileSharesInput>
    connectOrCreate?: FileCreateOrConnectWithoutFileSharesInput
    upsert?: FileUpsertWithoutFileSharesInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutFileSharesInput, FileUpdateWithoutFileSharesInput>, FileUncheckedUpdateWithoutFileSharesInput>
  }

  export type UsersUpdateOneRequiredWithoutFileSharesNestedInput = {
    create?: XOR<UsersCreateWithoutFileSharesInput, UsersUncheckedCreateWithoutFileSharesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFileSharesInput
    upsert?: UsersUpsertWithoutFileSharesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFileSharesInput, UsersUpdateWithoutFileSharesInput>, UsersUncheckedUpdateWithoutFileSharesInput>
  }

  export type FolderCreatetagsInput = {
    set: string[]
  }

  export type FileCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutFolderInput = {
    create?: XOR<UsersCreateWithoutFolderInput, UsersUncheckedCreateWithoutFolderInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFolderInput
    connect?: UsersWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutOther_FolderInput = {
    create?: XOR<FolderCreateWithoutOther_FolderInput, FolderUncheckedCreateWithoutOther_FolderInput>
    connectOrCreate?: FolderCreateOrConnectWithoutOther_FolderInput
    connect?: FolderWhereUniqueInput
  }

  export type FolderCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput> | FolderCreateWithoutFolderInput[] | FolderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutFolderInput | FolderCreateOrConnectWithoutFolderInput[]
    createMany?: FolderCreateManyFolderInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FolderSharesCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput> | FolderSharesCreateWithoutFolderInput[] | FolderSharesUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutFolderInput | FolderSharesCreateOrConnectWithoutFolderInput[]
    createMany?: FolderSharesCreateManyFolderInputEnvelope
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput> | FolderCreateWithoutFolderInput[] | FolderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutFolderInput | FolderCreateOrConnectWithoutFolderInput[]
    createMany?: FolderCreateManyFolderInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FolderSharesUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput> | FolderSharesCreateWithoutFolderInput[] | FolderSharesUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutFolderInput | FolderSharesCreateOrConnectWithoutFolderInput[]
    createMany?: FolderSharesCreateManyFolderInputEnvelope
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
  }

  export type FolderUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FileUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutFolderNestedInput = {
    create?: XOR<UsersCreateWithoutFolderInput, UsersUncheckedCreateWithoutFolderInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFolderInput
    upsert?: UsersUpsertWithoutFolderInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFolderInput, UsersUpdateWithoutFolderInput>, UsersUncheckedUpdateWithoutFolderInput>
  }

  export type FolderUpdateOneWithoutOther_FolderNestedInput = {
    create?: XOR<FolderCreateWithoutOther_FolderInput, FolderUncheckedCreateWithoutOther_FolderInput>
    connectOrCreate?: FolderCreateOrConnectWithoutOther_FolderInput
    upsert?: FolderUpsertWithoutOther_FolderInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutOther_FolderInput, FolderUpdateWithoutOther_FolderInput>, FolderUncheckedUpdateWithoutOther_FolderInput>
  }

  export type FolderUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput> | FolderCreateWithoutFolderInput[] | FolderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutFolderInput | FolderCreateOrConnectWithoutFolderInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutFolderInput | FolderUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderCreateManyFolderInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutFolderInput | FolderUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutFolderInput | FolderUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FolderSharesUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput> | FolderSharesCreateWithoutFolderInput[] | FolderSharesUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutFolderInput | FolderSharesCreateOrConnectWithoutFolderInput[]
    upsert?: FolderSharesUpsertWithWhereUniqueWithoutFolderInput | FolderSharesUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderSharesCreateManyFolderInputEnvelope
    set?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    disconnect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    delete?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    update?: FolderSharesUpdateWithWhereUniqueWithoutFolderInput | FolderSharesUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderSharesUpdateManyWithWhereWithoutFolderInput | FolderSharesUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput> | FileCreateWithoutFolderInput[] | FileUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutFolderInput | FileCreateOrConnectWithoutFolderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutFolderInput | FileUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FileCreateManyFolderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutFolderInput | FileUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutFolderInput | FileUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput> | FolderCreateWithoutFolderInput[] | FolderUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutFolderInput | FolderCreateOrConnectWithoutFolderInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutFolderInput | FolderUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderCreateManyFolderInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutFolderInput | FolderUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutFolderInput | FolderUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FolderSharesUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput> | FolderSharesCreateWithoutFolderInput[] | FolderSharesUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutFolderInput | FolderSharesCreateOrConnectWithoutFolderInput[]
    upsert?: FolderSharesUpsertWithWhereUniqueWithoutFolderInput | FolderSharesUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderSharesCreateManyFolderInputEnvelope
    set?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    disconnect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    delete?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    update?: FolderSharesUpdateWithWhereUniqueWithoutFolderInput | FolderSharesUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderSharesUpdateManyWithWhereWithoutFolderInput | FolderSharesUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
  }

  export type FolderCreateNestedOneWithoutFolderSharesInput = {
    create?: XOR<FolderCreateWithoutFolderSharesInput, FolderUncheckedCreateWithoutFolderSharesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFolderSharesInput
    connect?: FolderWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFolderSharesInput = {
    create?: XOR<UsersCreateWithoutFolderSharesInput, UsersUncheckedCreateWithoutFolderSharesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFolderSharesInput
    connect?: UsersWhereUniqueInput
  }

  export type FolderUpdateOneRequiredWithoutFolderSharesNestedInput = {
    create?: XOR<FolderCreateWithoutFolderSharesInput, FolderUncheckedCreateWithoutFolderSharesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFolderSharesInput
    upsert?: FolderUpsertWithoutFolderSharesInput
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFolderSharesInput, FolderUpdateWithoutFolderSharesInput>, FolderUncheckedUpdateWithoutFolderSharesInput>
  }

  export type UsersUpdateOneRequiredWithoutFolderSharesNestedInput = {
    create?: XOR<UsersCreateWithoutFolderSharesInput, UsersUncheckedCreateWithoutFolderSharesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFolderSharesInput
    upsert?: UsersUpsertWithoutFolderSharesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFolderSharesInput, UsersUpdateWithoutFolderSharesInput>, UsersUncheckedUpdateWithoutFolderSharesInput>
  }

  export type UsersCreateNestedOneWithoutLiked_ContentInput = {
    create?: XOR<UsersCreateWithoutLiked_ContentInput, UsersUncheckedCreateWithoutLiked_ContentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLiked_ContentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutLiked_ContentNestedInput = {
    create?: XOR<UsersCreateWithoutLiked_ContentInput, UsersUncheckedCreateWithoutLiked_ContentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLiked_ContentInput
    upsert?: UsersUpsertWithoutLiked_ContentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutLiked_ContentInput, UsersUpdateWithoutLiked_ContentInput>, UsersUncheckedUpdateWithoutLiked_ContentInput>
  }

  export type MangaCreateMediaGenreInput = {
    set: $Enums.MediaGenre[]
  }

  export type AnimeCreateNestedManyWithoutMangaInput = {
    create?: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput> | AnimeCreateWithoutMangaInput[] | AnimeUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutMangaInput | AnimeCreateOrConnectWithoutMangaInput[]
    createMany?: AnimeCreateManyMangaInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type BookmarksCreateNestedManyWithoutMangaInput = {
    create?: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput> | BookmarksCreateWithoutMangaInput[] | BookmarksUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMangaInput | BookmarksCreateOrConnectWithoutMangaInput[]
    createMany?: BookmarksCreateManyMangaInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutMangaInput = {
    create?: XOR<UsersCreateWithoutMangaInput, UsersUncheckedCreateWithoutMangaInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMangaInput
    connect?: UsersWhereUniqueInput
  }

  export type ContentGroupMediaCreateNestedManyWithoutMangaInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput> | ContentGroupMediaCreateWithoutMangaInput[] | ContentGroupMediaUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMangaInput | ContentGroupMediaCreateOrConnectWithoutMangaInput[]
    createMany?: ContentGroupMediaCreateManyMangaInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type AnimeUncheckedCreateNestedManyWithoutMangaInput = {
    create?: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput> | AnimeCreateWithoutMangaInput[] | AnimeUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutMangaInput | AnimeCreateOrConnectWithoutMangaInput[]
    createMany?: AnimeCreateManyMangaInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type BookmarksUncheckedCreateNestedManyWithoutMangaInput = {
    create?: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput> | BookmarksCreateWithoutMangaInput[] | BookmarksUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMangaInput | BookmarksCreateOrConnectWithoutMangaInput[]
    createMany?: BookmarksCreateManyMangaInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type ContentGroupMediaUncheckedCreateNestedManyWithoutMangaInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput> | ContentGroupMediaCreateWithoutMangaInput[] | ContentGroupMediaUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMangaInput | ContentGroupMediaCreateOrConnectWithoutMangaInput[]
    createMany?: ContentGroupMediaCreateManyMangaInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type MangaUpdateMediaGenreInput = {
    set?: $Enums.MediaGenre[]
    push?: $Enums.MediaGenre | $Enums.MediaGenre[]
  }

  export type AnimeUpdateManyWithoutMangaNestedInput = {
    create?: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput> | AnimeCreateWithoutMangaInput[] | AnimeUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutMangaInput | AnimeCreateOrConnectWithoutMangaInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutMangaInput | AnimeUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: AnimeCreateManyMangaInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutMangaInput | AnimeUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutMangaInput | AnimeUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type BookmarksUpdateManyWithoutMangaNestedInput = {
    create?: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput> | BookmarksCreateWithoutMangaInput[] | BookmarksUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMangaInput | BookmarksCreateOrConnectWithoutMangaInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutMangaInput | BookmarksUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: BookmarksCreateManyMangaInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutMangaInput | BookmarksUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutMangaInput | BookmarksUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutMangaNestedInput = {
    create?: XOR<UsersCreateWithoutMangaInput, UsersUncheckedCreateWithoutMangaInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMangaInput
    upsert?: UsersUpsertWithoutMangaInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMangaInput, UsersUpdateWithoutMangaInput>, UsersUncheckedUpdateWithoutMangaInput>
  }

  export type ContentGroupMediaUpdateManyWithoutMangaNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput> | ContentGroupMediaCreateWithoutMangaInput[] | ContentGroupMediaUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMangaInput | ContentGroupMediaCreateOrConnectWithoutMangaInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutMangaInput | ContentGroupMediaUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: ContentGroupMediaCreateManyMangaInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutMangaInput | ContentGroupMediaUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutMangaInput | ContentGroupMediaUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type AnimeUncheckedUpdateManyWithoutMangaNestedInput = {
    create?: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput> | AnimeCreateWithoutMangaInput[] | AnimeUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutMangaInput | AnimeCreateOrConnectWithoutMangaInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutMangaInput | AnimeUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: AnimeCreateManyMangaInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutMangaInput | AnimeUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutMangaInput | AnimeUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type BookmarksUncheckedUpdateManyWithoutMangaNestedInput = {
    create?: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput> | BookmarksCreateWithoutMangaInput[] | BookmarksUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMangaInput | BookmarksCreateOrConnectWithoutMangaInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutMangaInput | BookmarksUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: BookmarksCreateManyMangaInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutMangaInput | BookmarksUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutMangaInput | BookmarksUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutMangaNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput> | ContentGroupMediaCreateWithoutMangaInput[] | ContentGroupMediaUncheckedCreateWithoutMangaInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMangaInput | ContentGroupMediaCreateOrConnectWithoutMangaInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutMangaInput | ContentGroupMediaUpsertWithWhereUniqueWithoutMangaInput[]
    createMany?: ContentGroupMediaCreateManyMangaInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutMangaInput | ContentGroupMediaUpdateWithWhereUniqueWithoutMangaInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutMangaInput | ContentGroupMediaUpdateManyWithWhereWithoutMangaInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type MoviesCreateMediaGenreInput = {
    set: $Enums.MediaGenre[]
  }

  export type BookmarksCreateNestedManyWithoutMoviesInput = {
    create?: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput> | BookmarksCreateWithoutMoviesInput[] | BookmarksUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMoviesInput | BookmarksCreateOrConnectWithoutMoviesInput[]
    createMany?: BookmarksCreateManyMoviesInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutMoviesInput = {
    create?: XOR<UsersCreateWithoutMoviesInput, UsersUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMoviesInput
    connect?: UsersWhereUniqueInput
  }

  export type ContentGroupMediaCreateNestedManyWithoutMoviesInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput> | ContentGroupMediaCreateWithoutMoviesInput[] | ContentGroupMediaUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMoviesInput | ContentGroupMediaCreateOrConnectWithoutMoviesInput[]
    createMany?: ContentGroupMediaCreateManyMoviesInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type BookmarksUncheckedCreateNestedManyWithoutMoviesInput = {
    create?: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput> | BookmarksCreateWithoutMoviesInput[] | BookmarksUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMoviesInput | BookmarksCreateOrConnectWithoutMoviesInput[]
    createMany?: BookmarksCreateManyMoviesInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type ContentGroupMediaUncheckedCreateNestedManyWithoutMoviesInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput> | ContentGroupMediaCreateWithoutMoviesInput[] | ContentGroupMediaUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMoviesInput | ContentGroupMediaCreateOrConnectWithoutMoviesInput[]
    createMany?: ContentGroupMediaCreateManyMoviesInputEnvelope
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
  }

  export type MoviesUpdateMediaGenreInput = {
    set?: $Enums.MediaGenre[]
    push?: $Enums.MediaGenre | $Enums.MediaGenre[]
  }

  export type BookmarksUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput> | BookmarksCreateWithoutMoviesInput[] | BookmarksUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMoviesInput | BookmarksCreateOrConnectWithoutMoviesInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutMoviesInput | BookmarksUpsertWithWhereUniqueWithoutMoviesInput[]
    createMany?: BookmarksCreateManyMoviesInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutMoviesInput | BookmarksUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutMoviesInput | BookmarksUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutMoviesNestedInput = {
    create?: XOR<UsersCreateWithoutMoviesInput, UsersUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMoviesInput
    upsert?: UsersUpsertWithoutMoviesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMoviesInput, UsersUpdateWithoutMoviesInput>, UsersUncheckedUpdateWithoutMoviesInput>
  }

  export type ContentGroupMediaUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput> | ContentGroupMediaCreateWithoutMoviesInput[] | ContentGroupMediaUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMoviesInput | ContentGroupMediaCreateOrConnectWithoutMoviesInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutMoviesInput | ContentGroupMediaUpsertWithWhereUniqueWithoutMoviesInput[]
    createMany?: ContentGroupMediaCreateManyMoviesInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutMoviesInput | ContentGroupMediaUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutMoviesInput | ContentGroupMediaUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type BookmarksUncheckedUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput> | BookmarksCreateWithoutMoviesInput[] | BookmarksUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutMoviesInput | BookmarksCreateOrConnectWithoutMoviesInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutMoviesInput | BookmarksUpsertWithWhereUniqueWithoutMoviesInput[]
    createMany?: BookmarksCreateManyMoviesInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutMoviesInput | BookmarksUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutMoviesInput | BookmarksUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutMoviesNestedInput = {
    create?: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput> | ContentGroupMediaCreateWithoutMoviesInput[] | ContentGroupMediaUncheckedCreateWithoutMoviesInput[]
    connectOrCreate?: ContentGroupMediaCreateOrConnectWithoutMoviesInput | ContentGroupMediaCreateOrConnectWithoutMoviesInput[]
    upsert?: ContentGroupMediaUpsertWithWhereUniqueWithoutMoviesInput | ContentGroupMediaUpsertWithWhereUniqueWithoutMoviesInput[]
    createMany?: ContentGroupMediaCreateManyMoviesInputEnvelope
    set?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    disconnect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    delete?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    connect?: ContentGroupMediaWhereUniqueInput | ContentGroupMediaWhereUniqueInput[]
    update?: ContentGroupMediaUpdateWithWhereUniqueWithoutMoviesInput | ContentGroupMediaUpdateWithWhereUniqueWithoutMoviesInput[]
    updateMany?: ContentGroupMediaUpdateManyWithWhereWithoutMoviesInput | ContentGroupMediaUpdateManyWithWhereWithoutMoviesInput[]
    deleteMany?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutPollsInput = {
    create?: XOR<UsersCreateWithoutPollsInput, UsersUncheckedCreateWithoutPollsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPollsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutPollsNestedInput = {
    create?: XOR<UsersCreateWithoutPollsInput, UsersUncheckedCreateWithoutPollsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPollsInput
    upsert?: UsersUpsertWithoutPollsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPollsInput, UsersUpdateWithoutPollsInput>, UsersUncheckedUpdateWithoutPollsInput>
  }

  export type UsersCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviewsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReviewsInput
    upsert?: UsersUpsertWithoutReviewsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReviewsInput, UsersUpdateWithoutReviewsInput>, UsersUncheckedUpdateWithoutReviewsInput>
  }

  export type StoreCreateNestedOneWithoutShopping_CartInput = {
    create?: XOR<StoreCreateWithoutShopping_CartInput, StoreUncheckedCreateWithoutShopping_CartInput>
    connectOrCreate?: StoreCreateOrConnectWithoutShopping_CartInput
    connect?: StoreWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutShopping_CartInput = {
    create?: XOR<UsersCreateWithoutShopping_CartInput, UsersUncheckedCreateWithoutShopping_CartInput>
    connectOrCreate?: UsersCreateOrConnectWithoutShopping_CartInput
    connect?: UsersWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutShopping_CartNestedInput = {
    create?: XOR<StoreCreateWithoutShopping_CartInput, StoreUncheckedCreateWithoutShopping_CartInput>
    connectOrCreate?: StoreCreateOrConnectWithoutShopping_CartInput
    upsert?: StoreUpsertWithoutShopping_CartInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutShopping_CartInput, StoreUpdateWithoutShopping_CartInput>, StoreUncheckedUpdateWithoutShopping_CartInput>
  }

  export type UsersUpdateOneRequiredWithoutShopping_CartNestedInput = {
    create?: XOR<UsersCreateWithoutShopping_CartInput, UsersUncheckedCreateWithoutShopping_CartInput>
    connectOrCreate?: UsersCreateOrConnectWithoutShopping_CartInput
    upsert?: UsersUpsertWithoutShopping_CartInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutShopping_CartInput, UsersUpdateWithoutShopping_CartInput>, UsersUncheckedUpdateWithoutShopping_CartInput>
  }

  export type StoreCreateMediaGenreInput = {
    set: $Enums.MediaGenre[]
  }

  export type Shopping_CartCreateNestedManyWithoutStoreInput = {
    create?: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput> | Shopping_CartCreateWithoutStoreInput[] | Shopping_CartUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutStoreInput | Shopping_CartCreateOrConnectWithoutStoreInput[]
    createMany?: Shopping_CartCreateManyStoreInputEnvelope
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutStoreInput = {
    create?: XOR<UsersCreateWithoutStoreInput, UsersUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoreInput
    connect?: UsersWhereUniqueInput
  }

  export type Shopping_CartUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput> | Shopping_CartCreateWithoutStoreInput[] | Shopping_CartUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutStoreInput | Shopping_CartCreateOrConnectWithoutStoreInput[]
    createMany?: Shopping_CartCreateManyStoreInputEnvelope
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StoreUpdateMediaGenreInput = {
    set?: $Enums.MediaGenre[]
    push?: $Enums.MediaGenre | $Enums.MediaGenre[]
  }

  export type Shopping_CartUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput> | Shopping_CartCreateWithoutStoreInput[] | Shopping_CartUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutStoreInput | Shopping_CartCreateOrConnectWithoutStoreInput[]
    upsert?: Shopping_CartUpsertWithWhereUniqueWithoutStoreInput | Shopping_CartUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: Shopping_CartCreateManyStoreInputEnvelope
    set?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    disconnect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    delete?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    update?: Shopping_CartUpdateWithWhereUniqueWithoutStoreInput | Shopping_CartUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: Shopping_CartUpdateManyWithWhereWithoutStoreInput | Shopping_CartUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutStoreNestedInput = {
    create?: XOR<UsersCreateWithoutStoreInput, UsersUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoreInput
    upsert?: UsersUpsertWithoutStoreInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutStoreInput, UsersUpdateWithoutStoreInput>, UsersUncheckedUpdateWithoutStoreInput>
  }

  export type Shopping_CartUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput> | Shopping_CartCreateWithoutStoreInput[] | Shopping_CartUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutStoreInput | Shopping_CartCreateOrConnectWithoutStoreInput[]
    upsert?: Shopping_CartUpsertWithWhereUniqueWithoutStoreInput | Shopping_CartUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: Shopping_CartCreateManyStoreInputEnvelope
    set?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    disconnect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    delete?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    update?: Shopping_CartUpdateWithWhereUniqueWithoutStoreInput | Shopping_CartUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: Shopping_CartUpdateManyWithWhereWithoutStoreInput | Shopping_CartUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
  }

  export type Subscription_TiersCreatepermissionsInput = {
    set: $Enums.navItems[]
  }

  export type Subscription_TiersCreatefeaturesInput = {
    set: string[]
  }

  export type UsersCreateNestedManyWithoutSubscription_tierInput = {
    create?: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput> | UsersCreateWithoutSubscription_tierInput[] | UsersUncheckedCreateWithoutSubscription_tierInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutSubscription_tierInput | UsersCreateOrConnectWithoutSubscription_tierInput[]
    createMany?: UsersCreateManySubscription_tierInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutSubscription_tierInput = {
    create?: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput> | UsersCreateWithoutSubscription_tierInput[] | UsersUncheckedCreateWithoutSubscription_tierInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutSubscription_tierInput | UsersCreateOrConnectWithoutSubscription_tierInput[]
    createMany?: UsersCreateManySubscription_tierInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type Subscription_TiersUpdatepermissionsInput = {
    set?: $Enums.navItems[]
    push?: $Enums.navItems | $Enums.navItems[]
  }

  export type Subscription_TiersUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersUpdateManyWithoutSubscription_tierNestedInput = {
    create?: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput> | UsersCreateWithoutSubscription_tierInput[] | UsersUncheckedCreateWithoutSubscription_tierInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutSubscription_tierInput | UsersCreateOrConnectWithoutSubscription_tierInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutSubscription_tierInput | UsersUpsertWithWhereUniqueWithoutSubscription_tierInput[]
    createMany?: UsersCreateManySubscription_tierInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutSubscription_tierInput | UsersUpdateWithWhereUniqueWithoutSubscription_tierInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutSubscription_tierInput | UsersUpdateManyWithWhereWithoutSubscription_tierInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutSubscription_tierNestedInput = {
    create?: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput> | UsersCreateWithoutSubscription_tierInput[] | UsersUncheckedCreateWithoutSubscription_tierInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutSubscription_tierInput | UsersCreateOrConnectWithoutSubscription_tierInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutSubscription_tierInput | UsersUpsertWithWhereUniqueWithoutSubscription_tierInput[]
    createMany?: UsersCreateManySubscription_tierInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutSubscription_tierInput | UsersUpdateWithWhereUniqueWithoutSubscription_tierInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutSubscription_tierInput | UsersUpdateManyWithWhereWithoutSubscription_tierInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutUser_ActivityInput = {
    create?: XOR<UsersCreateWithoutUser_ActivityInput, UsersUncheckedCreateWithoutUser_ActivityInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_ActivityInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUser_ActivityNestedInput = {
    create?: XOR<UsersCreateWithoutUser_ActivityInput, UsersUncheckedCreateWithoutUser_ActivityInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_ActivityInput
    upsert?: UsersUpsertWithoutUser_ActivityInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUser_ActivityInput, UsersUpdateWithoutUser_ActivityInput>, UsersUncheckedUpdateWithoutUser_ActivityInput>
  }

  export type UsersCreateNestedOneWithoutUser_BookmarksInput = {
    create?: XOR<UsersCreateWithoutUser_BookmarksInput, UsersUncheckedCreateWithoutUser_BookmarksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_BookmarksInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUser_BookmarksNestedInput = {
    create?: XOR<UsersCreateWithoutUser_BookmarksInput, UsersUncheckedCreateWithoutUser_BookmarksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_BookmarksInput
    upsert?: UsersUpsertWithoutUser_BookmarksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUser_BookmarksInput, UsersUpdateWithoutUser_BookmarksInput>, UsersUncheckedUpdateWithoutUser_BookmarksInput>
  }

  export type UsersCreateNestedOneWithoutUser_RatingsInput = {
    create?: XOR<UsersCreateWithoutUser_RatingsInput, UsersUncheckedCreateWithoutUser_RatingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_RatingsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUser_RatingsNestedInput = {
    create?: XOR<UsersCreateWithoutUser_RatingsInput, UsersUncheckedCreateWithoutUser_RatingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUser_RatingsInput
    upsert?: UsersUpsertWithoutUser_RatingsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUser_RatingsInput, UsersUpdateWithoutUser_RatingsInput>, UsersUncheckedUpdateWithoutUser_RatingsInput>
  }

  export type Subscription_TiersCreateNestedOneWithoutUsersInput = {
    create?: XOR<Subscription_TiersCreateWithoutUsersInput, Subscription_TiersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: Subscription_TiersCreateOrConnectWithoutUsersInput
    connect?: Subscription_TiersWhereUniqueInput
  }

  export type AnimeCreateNestedManyWithoutUsersInput = {
    create?: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput> | AnimeCreateWithoutUsersInput[] | AnimeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutUsersInput | AnimeCreateOrConnectWithoutUsersInput[]
    createMany?: AnimeCreateManyUsersInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type Anime_AuthorsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput> | Anime_AuthorsCreateWithoutUsersInput[] | Anime_AuthorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutUsersInput | Anime_AuthorsCreateOrConnectWithoutUsersInput[]
    createMany?: Anime_AuthorsCreateManyUsersInputEnvelope
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
  }

  export type BookmarksCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput> | BookmarksCreateWithoutUsersInput[] | BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutUsersInput | BookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: BookmarksCreateManyUsersInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput> | CommentsCreateWithoutUsersInput[] | CommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUsersInput | CommentsCreateOrConnectWithoutUsersInput[]
    createMany?: CommentsCreateManyUsersInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Disliked_ContentCreateNestedManyWithoutUsersInput = {
    create?: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput> | Disliked_ContentCreateWithoutUsersInput[] | Disliked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Disliked_ContentCreateOrConnectWithoutUsersInput | Disliked_ContentCreateOrConnectWithoutUsersInput[]
    createMany?: Disliked_ContentCreateManyUsersInputEnvelope
    connect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUsersInput = {
    create?: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput> | FileCreateWithoutUsersInput[] | FileUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUsersInput | FileCreateOrConnectWithoutUsersInput[]
    createMany?: FileCreateManyUsersInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileSharesCreateNestedManyWithoutUsersInput = {
    create?: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput> | FileSharesCreateWithoutUsersInput[] | FileSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutUsersInput | FileSharesCreateOrConnectWithoutUsersInput[]
    createMany?: FileSharesCreateManyUsersInputEnvelope
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
  }

  export type FolderCreateNestedManyWithoutUsersInput = {
    create?: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput> | FolderCreateWithoutUsersInput[] | FolderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutUsersInput | FolderCreateOrConnectWithoutUsersInput[]
    createMany?: FolderCreateManyUsersInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FolderSharesCreateNestedManyWithoutUsersInput = {
    create?: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput> | FolderSharesCreateWithoutUsersInput[] | FolderSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutUsersInput | FolderSharesCreateOrConnectWithoutUsersInput[]
    createMany?: FolderSharesCreateManyUsersInputEnvelope
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
  }

  export type Liked_ContentCreateNestedManyWithoutUsersInput = {
    create?: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput> | Liked_ContentCreateWithoutUsersInput[] | Liked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Liked_ContentCreateOrConnectWithoutUsersInput | Liked_ContentCreateOrConnectWithoutUsersInput[]
    createMany?: Liked_ContentCreateManyUsersInputEnvelope
    connect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
  }

  export type MangaCreateNestedManyWithoutUsersInput = {
    create?: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput> | MangaCreateWithoutUsersInput[] | MangaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MangaCreateOrConnectWithoutUsersInput | MangaCreateOrConnectWithoutUsersInput[]
    createMany?: MangaCreateManyUsersInputEnvelope
    connect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
  }

  export type MoviesCreateNestedManyWithoutUsersInput = {
    create?: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput> | MoviesCreateWithoutUsersInput[] | MoviesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MoviesCreateOrConnectWithoutUsersInput | MoviesCreateOrConnectWithoutUsersInput[]
    createMany?: MoviesCreateManyUsersInputEnvelope
    connect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
  }

  export type PollsCreateNestedManyWithoutUsersInput = {
    create?: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput> | PollsCreateWithoutUsersInput[] | PollsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PollsCreateOrConnectWithoutUsersInput | PollsCreateOrConnectWithoutUsersInput[]
    createMany?: PollsCreateManyUsersInputEnvelope
    connect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
  }

  export type ReviewsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput> | ReviewsCreateWithoutUsersInput[] | ReviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsersInput | ReviewsCreateOrConnectWithoutUsersInput[]
    createMany?: ReviewsCreateManyUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Shopping_CartCreateNestedManyWithoutUsersInput = {
    create?: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput> | Shopping_CartCreateWithoutUsersInput[] | Shopping_CartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutUsersInput | Shopping_CartCreateOrConnectWithoutUsersInput[]
    createMany?: Shopping_CartCreateManyUsersInputEnvelope
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
  }

  export type StoreCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput> | StoreCreateWithoutUsersInput[] | StoreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput | StoreCreateOrConnectWithoutUsersInput[]
    createMany?: StoreCreateManyUsersInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type User_ActivityCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput> | User_ActivityCreateWithoutUsersInput[] | User_ActivityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_ActivityCreateOrConnectWithoutUsersInput | User_ActivityCreateOrConnectWithoutUsersInput[]
    createMany?: User_ActivityCreateManyUsersInputEnvelope
    connect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
  }

  export type User_BookmarksCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput> | User_BookmarksCreateWithoutUsersInput[] | User_BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_BookmarksCreateOrConnectWithoutUsersInput | User_BookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: User_BookmarksCreateManyUsersInputEnvelope
    connect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
  }

  export type User_RatingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput> | User_RatingsCreateWithoutUsersInput[] | User_RatingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_RatingsCreateOrConnectWithoutUsersInput | User_RatingsCreateOrConnectWithoutUsersInput[]
    createMany?: User_RatingsCreateManyUsersInputEnvelope
    connect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
  }

  export type VideosCreateNestedManyWithoutUsersInput = {
    create?: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput> | VideosCreateWithoutUsersInput[] | VideosUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VideosCreateOrConnectWithoutUsersInput | VideosCreateOrConnectWithoutUsersInput[]
    createMany?: VideosCreateManyUsersInputEnvelope
    connect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
  }

  export type AnimeUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput> | AnimeCreateWithoutUsersInput[] | AnimeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutUsersInput | AnimeCreateOrConnectWithoutUsersInput[]
    createMany?: AnimeCreateManyUsersInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput> | Anime_AuthorsCreateWithoutUsersInput[] | Anime_AuthorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutUsersInput | Anime_AuthorsCreateOrConnectWithoutUsersInput[]
    createMany?: Anime_AuthorsCreateManyUsersInputEnvelope
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
  }

  export type BookmarksUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput> | BookmarksCreateWithoutUsersInput[] | BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutUsersInput | BookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: BookmarksCreateManyUsersInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput> | CommentsCreateWithoutUsersInput[] | CommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUsersInput | CommentsCreateOrConnectWithoutUsersInput[]
    createMany?: CommentsCreateManyUsersInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput> | Disliked_ContentCreateWithoutUsersInput[] | Disliked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Disliked_ContentCreateOrConnectWithoutUsersInput | Disliked_ContentCreateOrConnectWithoutUsersInput[]
    createMany?: Disliked_ContentCreateManyUsersInputEnvelope
    connect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput> | FileCreateWithoutUsersInput[] | FileUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUsersInput | FileCreateOrConnectWithoutUsersInput[]
    createMany?: FileCreateManyUsersInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileSharesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput> | FileSharesCreateWithoutUsersInput[] | FileSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutUsersInput | FileSharesCreateOrConnectWithoutUsersInput[]
    createMany?: FileSharesCreateManyUsersInputEnvelope
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput> | FolderCreateWithoutUsersInput[] | FolderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutUsersInput | FolderCreateOrConnectWithoutUsersInput[]
    createMany?: FolderCreateManyUsersInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type FolderSharesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput> | FolderSharesCreateWithoutUsersInput[] | FolderSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutUsersInput | FolderSharesCreateOrConnectWithoutUsersInput[]
    createMany?: FolderSharesCreateManyUsersInputEnvelope
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
  }

  export type Liked_ContentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput> | Liked_ContentCreateWithoutUsersInput[] | Liked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Liked_ContentCreateOrConnectWithoutUsersInput | Liked_ContentCreateOrConnectWithoutUsersInput[]
    createMany?: Liked_ContentCreateManyUsersInputEnvelope
    connect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
  }

  export type MangaUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput> | MangaCreateWithoutUsersInput[] | MangaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MangaCreateOrConnectWithoutUsersInput | MangaCreateOrConnectWithoutUsersInput[]
    createMany?: MangaCreateManyUsersInputEnvelope
    connect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
  }

  export type MoviesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput> | MoviesCreateWithoutUsersInput[] | MoviesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MoviesCreateOrConnectWithoutUsersInput | MoviesCreateOrConnectWithoutUsersInput[]
    createMany?: MoviesCreateManyUsersInputEnvelope
    connect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
  }

  export type PollsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput> | PollsCreateWithoutUsersInput[] | PollsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PollsCreateOrConnectWithoutUsersInput | PollsCreateOrConnectWithoutUsersInput[]
    createMany?: PollsCreateManyUsersInputEnvelope
    connect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
  }

  export type ReviewsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput> | ReviewsCreateWithoutUsersInput[] | ReviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsersInput | ReviewsCreateOrConnectWithoutUsersInput[]
    createMany?: ReviewsCreateManyUsersInputEnvelope
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
  }

  export type Shopping_CartUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput> | Shopping_CartCreateWithoutUsersInput[] | Shopping_CartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutUsersInput | Shopping_CartCreateOrConnectWithoutUsersInput[]
    createMany?: Shopping_CartCreateManyUsersInputEnvelope
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
  }

  export type StoreUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput> | StoreCreateWithoutUsersInput[] | StoreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput | StoreCreateOrConnectWithoutUsersInput[]
    createMany?: StoreCreateManyUsersInputEnvelope
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
  }

  export type User_ActivityUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput> | User_ActivityCreateWithoutUsersInput[] | User_ActivityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_ActivityCreateOrConnectWithoutUsersInput | User_ActivityCreateOrConnectWithoutUsersInput[]
    createMany?: User_ActivityCreateManyUsersInputEnvelope
    connect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
  }

  export type User_BookmarksUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput> | User_BookmarksCreateWithoutUsersInput[] | User_BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_BookmarksCreateOrConnectWithoutUsersInput | User_BookmarksCreateOrConnectWithoutUsersInput[]
    createMany?: User_BookmarksCreateManyUsersInputEnvelope
    connect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
  }

  export type User_RatingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput> | User_RatingsCreateWithoutUsersInput[] | User_RatingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_RatingsCreateOrConnectWithoutUsersInput | User_RatingsCreateOrConnectWithoutUsersInput[]
    createMany?: User_RatingsCreateManyUsersInputEnvelope
    connect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
  }

  export type VideosUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput> | VideosCreateWithoutUsersInput[] | VideosUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VideosCreateOrConnectWithoutUsersInput | VideosCreateOrConnectWithoutUsersInput[]
    createMany?: VideosCreateManyUsersInputEnvelope
    connect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type Subscription_TiersUpdateOneWithoutUsersNestedInput = {
    create?: XOR<Subscription_TiersCreateWithoutUsersInput, Subscription_TiersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: Subscription_TiersCreateOrConnectWithoutUsersInput
    upsert?: Subscription_TiersUpsertWithoutUsersInput
    disconnect?: Subscription_TiersWhereInput | boolean
    delete?: Subscription_TiersWhereInput | boolean
    connect?: Subscription_TiersWhereUniqueInput
    update?: XOR<XOR<Subscription_TiersUpdateToOneWithWhereWithoutUsersInput, Subscription_TiersUpdateWithoutUsersInput>, Subscription_TiersUncheckedUpdateWithoutUsersInput>
  }

  export type AnimeUpdateManyWithoutUsersNestedInput = {
    create?: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput> | AnimeCreateWithoutUsersInput[] | AnimeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutUsersInput | AnimeCreateOrConnectWithoutUsersInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutUsersInput | AnimeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: AnimeCreateManyUsersInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutUsersInput | AnimeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutUsersInput | AnimeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type Anime_AuthorsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput> | Anime_AuthorsCreateWithoutUsersInput[] | Anime_AuthorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutUsersInput | Anime_AuthorsCreateOrConnectWithoutUsersInput[]
    upsert?: Anime_AuthorsUpsertWithWhereUniqueWithoutUsersInput | Anime_AuthorsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Anime_AuthorsCreateManyUsersInputEnvelope
    set?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    disconnect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    delete?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    update?: Anime_AuthorsUpdateWithWhereUniqueWithoutUsersInput | Anime_AuthorsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Anime_AuthorsUpdateManyWithWhereWithoutUsersInput | Anime_AuthorsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
  }

  export type BookmarksUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput> | BookmarksCreateWithoutUsersInput[] | BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutUsersInput | BookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutUsersInput | BookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: BookmarksCreateManyUsersInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutUsersInput | BookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutUsersInput | BookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput> | CommentsCreateWithoutUsersInput[] | CommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUsersInput | CommentsCreateOrConnectWithoutUsersInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUsersInput | CommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentsCreateManyUsersInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUsersInput | CommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUsersInput | CommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Disliked_ContentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput> | Disliked_ContentCreateWithoutUsersInput[] | Disliked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Disliked_ContentCreateOrConnectWithoutUsersInput | Disliked_ContentCreateOrConnectWithoutUsersInput[]
    upsert?: Disliked_ContentUpsertWithWhereUniqueWithoutUsersInput | Disliked_ContentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Disliked_ContentCreateManyUsersInputEnvelope
    set?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    disconnect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    delete?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    connect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    update?: Disliked_ContentUpdateWithWhereUniqueWithoutUsersInput | Disliked_ContentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Disliked_ContentUpdateManyWithWhereWithoutUsersInput | Disliked_ContentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Disliked_ContentScalarWhereInput | Disliked_ContentScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput> | FileCreateWithoutUsersInput[] | FileUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUsersInput | FileCreateOrConnectWithoutUsersInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUsersInput | FileUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FileCreateManyUsersInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUsersInput | FileUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUsersInput | FileUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileSharesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput> | FileSharesCreateWithoutUsersInput[] | FileSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutUsersInput | FileSharesCreateOrConnectWithoutUsersInput[]
    upsert?: FileSharesUpsertWithWhereUniqueWithoutUsersInput | FileSharesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FileSharesCreateManyUsersInputEnvelope
    set?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    disconnect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    delete?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    update?: FileSharesUpdateWithWhereUniqueWithoutUsersInput | FileSharesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FileSharesUpdateManyWithWhereWithoutUsersInput | FileSharesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
  }

  export type FolderUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput> | FolderCreateWithoutUsersInput[] | FolderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutUsersInput | FolderCreateOrConnectWithoutUsersInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutUsersInput | FolderUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FolderCreateManyUsersInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutUsersInput | FolderUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutUsersInput | FolderUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FolderSharesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput> | FolderSharesCreateWithoutUsersInput[] | FolderSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutUsersInput | FolderSharesCreateOrConnectWithoutUsersInput[]
    upsert?: FolderSharesUpsertWithWhereUniqueWithoutUsersInput | FolderSharesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FolderSharesCreateManyUsersInputEnvelope
    set?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    disconnect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    delete?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    update?: FolderSharesUpdateWithWhereUniqueWithoutUsersInput | FolderSharesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FolderSharesUpdateManyWithWhereWithoutUsersInput | FolderSharesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
  }

  export type Liked_ContentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput> | Liked_ContentCreateWithoutUsersInput[] | Liked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Liked_ContentCreateOrConnectWithoutUsersInput | Liked_ContentCreateOrConnectWithoutUsersInput[]
    upsert?: Liked_ContentUpsertWithWhereUniqueWithoutUsersInput | Liked_ContentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Liked_ContentCreateManyUsersInputEnvelope
    set?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    disconnect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    delete?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    connect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    update?: Liked_ContentUpdateWithWhereUniqueWithoutUsersInput | Liked_ContentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Liked_ContentUpdateManyWithWhereWithoutUsersInput | Liked_ContentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Liked_ContentScalarWhereInput | Liked_ContentScalarWhereInput[]
  }

  export type MangaUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput> | MangaCreateWithoutUsersInput[] | MangaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MangaCreateOrConnectWithoutUsersInput | MangaCreateOrConnectWithoutUsersInput[]
    upsert?: MangaUpsertWithWhereUniqueWithoutUsersInput | MangaUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MangaCreateManyUsersInputEnvelope
    set?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    disconnect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    delete?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    connect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    update?: MangaUpdateWithWhereUniqueWithoutUsersInput | MangaUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MangaUpdateManyWithWhereWithoutUsersInput | MangaUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MangaScalarWhereInput | MangaScalarWhereInput[]
  }

  export type MoviesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput> | MoviesCreateWithoutUsersInput[] | MoviesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MoviesCreateOrConnectWithoutUsersInput | MoviesCreateOrConnectWithoutUsersInput[]
    upsert?: MoviesUpsertWithWhereUniqueWithoutUsersInput | MoviesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MoviesCreateManyUsersInputEnvelope
    set?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    disconnect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    delete?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    connect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    update?: MoviesUpdateWithWhereUniqueWithoutUsersInput | MoviesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MoviesUpdateManyWithWhereWithoutUsersInput | MoviesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MoviesScalarWhereInput | MoviesScalarWhereInput[]
  }

  export type PollsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput> | PollsCreateWithoutUsersInput[] | PollsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PollsCreateOrConnectWithoutUsersInput | PollsCreateOrConnectWithoutUsersInput[]
    upsert?: PollsUpsertWithWhereUniqueWithoutUsersInput | PollsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PollsCreateManyUsersInputEnvelope
    set?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    disconnect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    delete?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    connect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    update?: PollsUpdateWithWhereUniqueWithoutUsersInput | PollsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PollsUpdateManyWithWhereWithoutUsersInput | PollsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PollsScalarWhereInput | PollsScalarWhereInput[]
  }

  export type ReviewsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput> | ReviewsCreateWithoutUsersInput[] | ReviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsersInput | ReviewsCreateOrConnectWithoutUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ReviewsCreateManyUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsersInput | ReviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Shopping_CartUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput> | Shopping_CartCreateWithoutUsersInput[] | Shopping_CartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutUsersInput | Shopping_CartCreateOrConnectWithoutUsersInput[]
    upsert?: Shopping_CartUpsertWithWhereUniqueWithoutUsersInput | Shopping_CartUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Shopping_CartCreateManyUsersInputEnvelope
    set?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    disconnect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    delete?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    update?: Shopping_CartUpdateWithWhereUniqueWithoutUsersInput | Shopping_CartUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Shopping_CartUpdateManyWithWhereWithoutUsersInput | Shopping_CartUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
  }

  export type StoreUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput> | StoreCreateWithoutUsersInput[] | StoreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput | StoreCreateOrConnectWithoutUsersInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutUsersInput | StoreUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoreCreateManyUsersInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutUsersInput | StoreUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutUsersInput | StoreUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type User_ActivityUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput> | User_ActivityCreateWithoutUsersInput[] | User_ActivityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_ActivityCreateOrConnectWithoutUsersInput | User_ActivityCreateOrConnectWithoutUsersInput[]
    upsert?: User_ActivityUpsertWithWhereUniqueWithoutUsersInput | User_ActivityUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_ActivityCreateManyUsersInputEnvelope
    set?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    disconnect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    delete?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    connect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    update?: User_ActivityUpdateWithWhereUniqueWithoutUsersInput | User_ActivityUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_ActivityUpdateManyWithWhereWithoutUsersInput | User_ActivityUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_ActivityScalarWhereInput | User_ActivityScalarWhereInput[]
  }

  export type User_BookmarksUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput> | User_BookmarksCreateWithoutUsersInput[] | User_BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_BookmarksCreateOrConnectWithoutUsersInput | User_BookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: User_BookmarksUpsertWithWhereUniqueWithoutUsersInput | User_BookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_BookmarksCreateManyUsersInputEnvelope
    set?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    disconnect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    delete?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    connect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    update?: User_BookmarksUpdateWithWhereUniqueWithoutUsersInput | User_BookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_BookmarksUpdateManyWithWhereWithoutUsersInput | User_BookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_BookmarksScalarWhereInput | User_BookmarksScalarWhereInput[]
  }

  export type User_RatingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput> | User_RatingsCreateWithoutUsersInput[] | User_RatingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_RatingsCreateOrConnectWithoutUsersInput | User_RatingsCreateOrConnectWithoutUsersInput[]
    upsert?: User_RatingsUpsertWithWhereUniqueWithoutUsersInput | User_RatingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_RatingsCreateManyUsersInputEnvelope
    set?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    disconnect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    delete?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    connect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    update?: User_RatingsUpdateWithWhereUniqueWithoutUsersInput | User_RatingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_RatingsUpdateManyWithWhereWithoutUsersInput | User_RatingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_RatingsScalarWhereInput | User_RatingsScalarWhereInput[]
  }

  export type VideosUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput> | VideosCreateWithoutUsersInput[] | VideosUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VideosCreateOrConnectWithoutUsersInput | VideosCreateOrConnectWithoutUsersInput[]
    upsert?: VideosUpsertWithWhereUniqueWithoutUsersInput | VideosUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VideosCreateManyUsersInputEnvelope
    set?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    disconnect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    delete?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    connect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    update?: VideosUpdateWithWhereUniqueWithoutUsersInput | VideosUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VideosUpdateManyWithWhereWithoutUsersInput | VideosUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VideosScalarWhereInput | VideosScalarWhereInput[]
  }

  export type AnimeUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput> | AnimeCreateWithoutUsersInput[] | AnimeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutUsersInput | AnimeCreateOrConnectWithoutUsersInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutUsersInput | AnimeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: AnimeCreateManyUsersInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutUsersInput | AnimeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutUsersInput | AnimeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput> | Anime_AuthorsCreateWithoutUsersInput[] | Anime_AuthorsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Anime_AuthorsCreateOrConnectWithoutUsersInput | Anime_AuthorsCreateOrConnectWithoutUsersInput[]
    upsert?: Anime_AuthorsUpsertWithWhereUniqueWithoutUsersInput | Anime_AuthorsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Anime_AuthorsCreateManyUsersInputEnvelope
    set?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    disconnect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    delete?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    connect?: Anime_AuthorsWhereUniqueInput | Anime_AuthorsWhereUniqueInput[]
    update?: Anime_AuthorsUpdateWithWhereUniqueWithoutUsersInput | Anime_AuthorsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Anime_AuthorsUpdateManyWithWhereWithoutUsersInput | Anime_AuthorsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
  }

  export type BookmarksUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput> | BookmarksCreateWithoutUsersInput[] | BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutUsersInput | BookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutUsersInput | BookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: BookmarksCreateManyUsersInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutUsersInput | BookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutUsersInput | BookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput> | CommentsCreateWithoutUsersInput[] | CommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUsersInput | CommentsCreateOrConnectWithoutUsersInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUsersInput | CommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentsCreateManyUsersInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUsersInput | CommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUsersInput | CommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput> | Disliked_ContentCreateWithoutUsersInput[] | Disliked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Disliked_ContentCreateOrConnectWithoutUsersInput | Disliked_ContentCreateOrConnectWithoutUsersInput[]
    upsert?: Disliked_ContentUpsertWithWhereUniqueWithoutUsersInput | Disliked_ContentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Disliked_ContentCreateManyUsersInputEnvelope
    set?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    disconnect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    delete?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    connect?: Disliked_ContentWhereUniqueInput | Disliked_ContentWhereUniqueInput[]
    update?: Disliked_ContentUpdateWithWhereUniqueWithoutUsersInput | Disliked_ContentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Disliked_ContentUpdateManyWithWhereWithoutUsersInput | Disliked_ContentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Disliked_ContentScalarWhereInput | Disliked_ContentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput> | FileCreateWithoutUsersInput[] | FileUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUsersInput | FileCreateOrConnectWithoutUsersInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUsersInput | FileUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FileCreateManyUsersInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUsersInput | FileUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUsersInput | FileUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileSharesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput> | FileSharesCreateWithoutUsersInput[] | FileSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FileSharesCreateOrConnectWithoutUsersInput | FileSharesCreateOrConnectWithoutUsersInput[]
    upsert?: FileSharesUpsertWithWhereUniqueWithoutUsersInput | FileSharesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FileSharesCreateManyUsersInputEnvelope
    set?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    disconnect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    delete?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    connect?: FileSharesWhereUniqueInput | FileSharesWhereUniqueInput[]
    update?: FileSharesUpdateWithWhereUniqueWithoutUsersInput | FileSharesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FileSharesUpdateManyWithWhereWithoutUsersInput | FileSharesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput> | FolderCreateWithoutUsersInput[] | FolderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutUsersInput | FolderCreateOrConnectWithoutUsersInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutUsersInput | FolderUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FolderCreateManyUsersInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutUsersInput | FolderUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutUsersInput | FolderUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type FolderSharesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput> | FolderSharesCreateWithoutUsersInput[] | FolderSharesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FolderSharesCreateOrConnectWithoutUsersInput | FolderSharesCreateOrConnectWithoutUsersInput[]
    upsert?: FolderSharesUpsertWithWhereUniqueWithoutUsersInput | FolderSharesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FolderSharesCreateManyUsersInputEnvelope
    set?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    disconnect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    delete?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    connect?: FolderSharesWhereUniqueInput | FolderSharesWhereUniqueInput[]
    update?: FolderSharesUpdateWithWhereUniqueWithoutUsersInput | FolderSharesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FolderSharesUpdateManyWithWhereWithoutUsersInput | FolderSharesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
  }

  export type Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput> | Liked_ContentCreateWithoutUsersInput[] | Liked_ContentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Liked_ContentCreateOrConnectWithoutUsersInput | Liked_ContentCreateOrConnectWithoutUsersInput[]
    upsert?: Liked_ContentUpsertWithWhereUniqueWithoutUsersInput | Liked_ContentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Liked_ContentCreateManyUsersInputEnvelope
    set?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    disconnect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    delete?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    connect?: Liked_ContentWhereUniqueInput | Liked_ContentWhereUniqueInput[]
    update?: Liked_ContentUpdateWithWhereUniqueWithoutUsersInput | Liked_ContentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Liked_ContentUpdateManyWithWhereWithoutUsersInput | Liked_ContentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Liked_ContentScalarWhereInput | Liked_ContentScalarWhereInput[]
  }

  export type MangaUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput> | MangaCreateWithoutUsersInput[] | MangaUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MangaCreateOrConnectWithoutUsersInput | MangaCreateOrConnectWithoutUsersInput[]
    upsert?: MangaUpsertWithWhereUniqueWithoutUsersInput | MangaUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MangaCreateManyUsersInputEnvelope
    set?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    disconnect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    delete?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    connect?: MangaWhereUniqueInput | MangaWhereUniqueInput[]
    update?: MangaUpdateWithWhereUniqueWithoutUsersInput | MangaUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MangaUpdateManyWithWhereWithoutUsersInput | MangaUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MangaScalarWhereInput | MangaScalarWhereInput[]
  }

  export type MoviesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput> | MoviesCreateWithoutUsersInput[] | MoviesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: MoviesCreateOrConnectWithoutUsersInput | MoviesCreateOrConnectWithoutUsersInput[]
    upsert?: MoviesUpsertWithWhereUniqueWithoutUsersInput | MoviesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: MoviesCreateManyUsersInputEnvelope
    set?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    disconnect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    delete?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    connect?: MoviesWhereUniqueInput | MoviesWhereUniqueInput[]
    update?: MoviesUpdateWithWhereUniqueWithoutUsersInput | MoviesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: MoviesUpdateManyWithWhereWithoutUsersInput | MoviesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: MoviesScalarWhereInput | MoviesScalarWhereInput[]
  }

  export type PollsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput> | PollsCreateWithoutUsersInput[] | PollsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PollsCreateOrConnectWithoutUsersInput | PollsCreateOrConnectWithoutUsersInput[]
    upsert?: PollsUpsertWithWhereUniqueWithoutUsersInput | PollsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PollsCreateManyUsersInputEnvelope
    set?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    disconnect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    delete?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    connect?: PollsWhereUniqueInput | PollsWhereUniqueInput[]
    update?: PollsUpdateWithWhereUniqueWithoutUsersInput | PollsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PollsUpdateManyWithWhereWithoutUsersInput | PollsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PollsScalarWhereInput | PollsScalarWhereInput[]
  }

  export type ReviewsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput> | ReviewsCreateWithoutUsersInput[] | ReviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ReviewsCreateOrConnectWithoutUsersInput | ReviewsCreateOrConnectWithoutUsersInput[]
    upsert?: ReviewsUpsertWithWhereUniqueWithoutUsersInput | ReviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ReviewsCreateManyUsersInputEnvelope
    set?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    disconnect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    delete?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    connect?: ReviewsWhereUniqueInput | ReviewsWhereUniqueInput[]
    update?: ReviewsUpdateWithWhereUniqueWithoutUsersInput | ReviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ReviewsUpdateManyWithWhereWithoutUsersInput | ReviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
  }

  export type Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput> | Shopping_CartCreateWithoutUsersInput[] | Shopping_CartUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: Shopping_CartCreateOrConnectWithoutUsersInput | Shopping_CartCreateOrConnectWithoutUsersInput[]
    upsert?: Shopping_CartUpsertWithWhereUniqueWithoutUsersInput | Shopping_CartUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: Shopping_CartCreateManyUsersInputEnvelope
    set?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    disconnect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    delete?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    connect?: Shopping_CartWhereUniqueInput | Shopping_CartWhereUniqueInput[]
    update?: Shopping_CartUpdateWithWhereUniqueWithoutUsersInput | Shopping_CartUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: Shopping_CartUpdateManyWithWhereWithoutUsersInput | Shopping_CartUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
  }

  export type StoreUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput> | StoreCreateWithoutUsersInput[] | StoreUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput | StoreCreateOrConnectWithoutUsersInput[]
    upsert?: StoreUpsertWithWhereUniqueWithoutUsersInput | StoreUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoreCreateManyUsersInputEnvelope
    set?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    disconnect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    delete?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    connect?: StoreWhereUniqueInput | StoreWhereUniqueInput[]
    update?: StoreUpdateWithWhereUniqueWithoutUsersInput | StoreUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoreUpdateManyWithWhereWithoutUsersInput | StoreUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoreScalarWhereInput | StoreScalarWhereInput[]
  }

  export type User_ActivityUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput> | User_ActivityCreateWithoutUsersInput[] | User_ActivityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_ActivityCreateOrConnectWithoutUsersInput | User_ActivityCreateOrConnectWithoutUsersInput[]
    upsert?: User_ActivityUpsertWithWhereUniqueWithoutUsersInput | User_ActivityUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_ActivityCreateManyUsersInputEnvelope
    set?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    disconnect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    delete?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    connect?: User_ActivityWhereUniqueInput | User_ActivityWhereUniqueInput[]
    update?: User_ActivityUpdateWithWhereUniqueWithoutUsersInput | User_ActivityUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_ActivityUpdateManyWithWhereWithoutUsersInput | User_ActivityUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_ActivityScalarWhereInput | User_ActivityScalarWhereInput[]
  }

  export type User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput> | User_BookmarksCreateWithoutUsersInput[] | User_BookmarksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_BookmarksCreateOrConnectWithoutUsersInput | User_BookmarksCreateOrConnectWithoutUsersInput[]
    upsert?: User_BookmarksUpsertWithWhereUniqueWithoutUsersInput | User_BookmarksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_BookmarksCreateManyUsersInputEnvelope
    set?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    disconnect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    delete?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    connect?: User_BookmarksWhereUniqueInput | User_BookmarksWhereUniqueInput[]
    update?: User_BookmarksUpdateWithWhereUniqueWithoutUsersInput | User_BookmarksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_BookmarksUpdateManyWithWhereWithoutUsersInput | User_BookmarksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_BookmarksScalarWhereInput | User_BookmarksScalarWhereInput[]
  }

  export type User_RatingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput> | User_RatingsCreateWithoutUsersInput[] | User_RatingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: User_RatingsCreateOrConnectWithoutUsersInput | User_RatingsCreateOrConnectWithoutUsersInput[]
    upsert?: User_RatingsUpsertWithWhereUniqueWithoutUsersInput | User_RatingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: User_RatingsCreateManyUsersInputEnvelope
    set?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    disconnect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    delete?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    connect?: User_RatingsWhereUniqueInput | User_RatingsWhereUniqueInput[]
    update?: User_RatingsUpdateWithWhereUniqueWithoutUsersInput | User_RatingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: User_RatingsUpdateManyWithWhereWithoutUsersInput | User_RatingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: User_RatingsScalarWhereInput | User_RatingsScalarWhereInput[]
  }

  export type VideosUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput> | VideosCreateWithoutUsersInput[] | VideosUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VideosCreateOrConnectWithoutUsersInput | VideosCreateOrConnectWithoutUsersInput[]
    upsert?: VideosUpsertWithWhereUniqueWithoutUsersInput | VideosUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VideosCreateManyUsersInputEnvelope
    set?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    disconnect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    delete?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    connect?: VideosWhereUniqueInput | VideosWhereUniqueInput[]
    update?: VideosUpdateWithWhereUniqueWithoutUsersInput | VideosUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VideosUpdateManyWithWhereWithoutUsersInput | VideosUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VideosScalarWhereInput | VideosScalarWhereInput[]
  }

  export type VideosCreateMediaGenreInput = {
    set: $Enums.MediaGenre[]
  }

  export type AnimeCreateNestedManyWithoutVideosInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput> | AnimeCreateWithoutVideosInput[] | AnimeUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput | AnimeCreateOrConnectWithoutVideosInput[]
    createMany?: AnimeCreateManyVideosInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type BookmarksCreateNestedManyWithoutVideosInput = {
    create?: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput> | BookmarksCreateWithoutVideosInput[] | BookmarksUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutVideosInput | BookmarksCreateOrConnectWithoutVideosInput[]
    createMany?: BookmarksCreateManyVideosInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutVideosInput = {
    create?: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput> | CommentsCreateWithoutVideosInput[] | CommentsUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutVideosInput | CommentsCreateOrConnectWithoutVideosInput[]
    createMany?: CommentsCreateManyVideosInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutVideosInput = {
    create?: XOR<UsersCreateWithoutVideosInput, UsersUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVideosInput
    connect?: UsersWhereUniqueInput
  }

  export type AnimeUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput> | AnimeCreateWithoutVideosInput[] | AnimeUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput | AnimeCreateOrConnectWithoutVideosInput[]
    createMany?: AnimeCreateManyVideosInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type BookmarksUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput> | BookmarksCreateWithoutVideosInput[] | BookmarksUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutVideosInput | BookmarksCreateOrConnectWithoutVideosInput[]
    createMany?: BookmarksCreateManyVideosInputEnvelope
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutVideosInput = {
    create?: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput> | CommentsCreateWithoutVideosInput[] | CommentsUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutVideosInput | CommentsCreateOrConnectWithoutVideosInput[]
    createMany?: CommentsCreateManyVideosInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type VideosUpdateMediaGenreInput = {
    set?: $Enums.MediaGenre[]
    push?: $Enums.MediaGenre | $Enums.MediaGenre[]
  }

  export type AnimeUpdateManyWithoutVideosNestedInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput> | AnimeCreateWithoutVideosInput[] | AnimeUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput | AnimeCreateOrConnectWithoutVideosInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutVideosInput | AnimeUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: AnimeCreateManyVideosInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutVideosInput | AnimeUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutVideosInput | AnimeUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type BookmarksUpdateManyWithoutVideosNestedInput = {
    create?: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput> | BookmarksCreateWithoutVideosInput[] | BookmarksUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutVideosInput | BookmarksCreateOrConnectWithoutVideosInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutVideosInput | BookmarksUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: BookmarksCreateManyVideosInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutVideosInput | BookmarksUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutVideosInput | BookmarksUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutVideosNestedInput = {
    create?: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput> | CommentsCreateWithoutVideosInput[] | CommentsUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutVideosInput | CommentsCreateOrConnectWithoutVideosInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutVideosInput | CommentsUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: CommentsCreateManyVideosInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutVideosInput | CommentsUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutVideosInput | CommentsUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<UsersCreateWithoutVideosInput, UsersUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UsersCreateOrConnectWithoutVideosInput
    upsert?: UsersUpsertWithoutVideosInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutVideosInput, UsersUpdateWithoutVideosInput>, UsersUncheckedUpdateWithoutVideosInput>
  }

  export type AnimeUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput> | AnimeCreateWithoutVideosInput[] | AnimeUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput | AnimeCreateOrConnectWithoutVideosInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutVideosInput | AnimeUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: AnimeCreateManyVideosInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutVideosInput | AnimeUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutVideosInput | AnimeUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type BookmarksUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput> | BookmarksCreateWithoutVideosInput[] | BookmarksUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: BookmarksCreateOrConnectWithoutVideosInput | BookmarksCreateOrConnectWithoutVideosInput[]
    upsert?: BookmarksUpsertWithWhereUniqueWithoutVideosInput | BookmarksUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: BookmarksCreateManyVideosInputEnvelope
    set?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    disconnect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    delete?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    connect?: BookmarksWhereUniqueInput | BookmarksWhereUniqueInput[]
    update?: BookmarksUpdateWithWhereUniqueWithoutVideosInput | BookmarksUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: BookmarksUpdateManyWithWhereWithoutVideosInput | BookmarksUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutVideosNestedInput = {
    create?: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput> | CommentsCreateWithoutVideosInput[] | CommentsUncheckedCreateWithoutVideosInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutVideosInput | CommentsCreateOrConnectWithoutVideosInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutVideosInput | CommentsUpsertWithWhereUniqueWithoutVideosInput[]
    createMany?: CommentsCreateManyVideosInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutVideosInput | CommentsUpdateWithWhereUniqueWithoutVideosInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutVideosInput | CommentsUpdateManyWithWhereWithoutVideosInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type Website_VariablesCreatefooter_itemsInput = {
    set: string[]
  }

  export type Website_VariablesCreateloggedin_nav_itemsInput = {
    set: $Enums.MediaType[]
  }

  export type Website_VariablesCreateloggedout_nav_itemsInput = {
    set: $Enums.MediaType[]
  }

  export type Website_VariablesUpdatefooter_itemsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Website_VariablesUpdateloggedin_nav_itemsInput = {
    set?: $Enums.MediaType[]
    push?: $Enums.MediaType | $Enums.MediaType[]
  }

  export type Website_VariablesUpdateloggedout_nav_itemsInput = {
    set?: $Enums.MediaType[]
    push?: $Enums.MediaType | $Enums.MediaType[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAgeRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingFilter<$PrismaModel> | $Enums.AgeRating
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgeRating[] | ListEnumAgeRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumAgeRatingWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type MangaCreateWithoutAnimeInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksCreateNestedManyWithoutMangaInput
    Users: UsersCreateNestedOneWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMangaInput
  }

  export type MangaUncheckedCreateWithoutAnimeInput = {
    mangaid?: string
    authorid: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMangaInput
  }

  export type MangaCreateOrConnectWithoutAnimeInput = {
    where: MangaWhereUniqueInput
    create: XOR<MangaCreateWithoutAnimeInput, MangaUncheckedCreateWithoutAnimeInput>
  }

  export type VideosCreateWithoutAnimeInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Bookmarks?: BookmarksCreateNestedManyWithoutVideosInput
    Comments?: CommentsCreateNestedManyWithoutVideosInput
    Users: UsersCreateNestedOneWithoutVideosInput
  }

  export type VideosUncheckedCreateWithoutAnimeInput = {
    videoid?: string
    title: string
    authorid: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutVideosInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideosCreateOrConnectWithoutAnimeInput = {
    where: VideosWhereUniqueInput
    create: XOR<VideosCreateWithoutAnimeInput, VideosUncheckedCreateWithoutAnimeInput>
  }

  export type UsersCreateWithoutAnimeInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutAnimeInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutAnimeInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAnimeInput, UsersUncheckedCreateWithoutAnimeInput>
  }

  export type Anime_AuthorsCreateWithoutAnimeInput = {
    Users: UsersCreateNestedOneWithoutAnime_AuthorsInput
  }

  export type Anime_AuthorsUncheckedCreateWithoutAnimeInput = {
    authorid: string
  }

  export type Anime_AuthorsCreateOrConnectWithoutAnimeInput = {
    where: Anime_AuthorsWhereUniqueInput
    create: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput>
  }

  export type Anime_AuthorsCreateManyAnimeInputEnvelope = {
    data: Anime_AuthorsCreateManyAnimeInput | Anime_AuthorsCreateManyAnimeInput[]
    skipDuplicates?: boolean
  }

  export type BookmarksCreateWithoutAnimeInput = {
    mediatype: $Enums.MediaType
    Manga: MangaCreateNestedOneWithoutBookmarksInput
    Movies: MoviesCreateNestedOneWithoutBookmarksInput
    Videos: VideosCreateNestedOneWithoutBookmarksInput
    Users: UsersCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateWithoutAnimeInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksCreateOrConnectWithoutAnimeInput = {
    where: BookmarksWhereUniqueInput
    create: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput>
  }

  export type BookmarksCreateManyAnimeInputEnvelope = {
    data: BookmarksCreateManyAnimeInput | BookmarksCreateManyAnimeInput[]
    skipDuplicates?: boolean
  }

  export type ContentGroupMediaCreateWithoutAnimeInput = {
    id?: string
    mediatype: $Enums.MediaType
    Manga?: MangaCreateNestedOneWithoutContentGroupLinksInput
    Movies?: MoviesCreateNestedOneWithoutContentGroupLinksInput
    ContentGroup: ContentGroupCreateNestedOneWithoutContentGroupLinksInput
    ContentUnits?: ContentUnitCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUncheckedCreateWithoutAnimeInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaCreateOrConnectWithoutAnimeInput = {
    where: ContentGroupMediaWhereUniqueInput
    create: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput>
  }

  export type ContentGroupMediaCreateManyAnimeInputEnvelope = {
    data: ContentGroupMediaCreateManyAnimeInput | ContentGroupMediaCreateManyAnimeInput[]
    skipDuplicates?: boolean
  }

  export type MangaUpsertWithoutAnimeInput = {
    update: XOR<MangaUpdateWithoutAnimeInput, MangaUncheckedUpdateWithoutAnimeInput>
    create: XOR<MangaCreateWithoutAnimeInput, MangaUncheckedCreateWithoutAnimeInput>
    where?: MangaWhereInput
  }

  export type MangaUpdateToOneWithWhereWithoutAnimeInput = {
    where?: MangaWhereInput
    data: XOR<MangaUpdateWithoutAnimeInput, MangaUncheckedUpdateWithoutAnimeInput>
  }

  export type MangaUpdateWithoutAnimeInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUpdateManyWithoutMangaNestedInput
    Users?: UsersUpdateOneRequiredWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateWithoutAnimeInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMangaNestedInput
  }

  export type VideosUpsertWithoutAnimeInput = {
    update: XOR<VideosUpdateWithoutAnimeInput, VideosUncheckedUpdateWithoutAnimeInput>
    create: XOR<VideosCreateWithoutAnimeInput, VideosUncheckedCreateWithoutAnimeInput>
    where?: VideosWhereInput
  }

  export type VideosUpdateToOneWithWhereWithoutAnimeInput = {
    where?: VideosWhereInput
    data: XOR<VideosUpdateWithoutAnimeInput, VideosUncheckedUpdateWithoutAnimeInput>
  }

  export type VideosUpdateWithoutAnimeInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Bookmarks?: BookmarksUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUpdateManyWithoutVideosNestedInput
    Users?: UsersUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateWithoutAnimeInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type UsersUpsertWithoutAnimeInput = {
    update: XOR<UsersUpdateWithoutAnimeInput, UsersUncheckedUpdateWithoutAnimeInput>
    create: XOR<UsersCreateWithoutAnimeInput, UsersUncheckedCreateWithoutAnimeInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAnimeInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAnimeInput, UsersUncheckedUpdateWithoutAnimeInput>
  }

  export type UsersUpdateWithoutAnimeInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutAnimeInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type Anime_AuthorsUpsertWithWhereUniqueWithoutAnimeInput = {
    where: Anime_AuthorsWhereUniqueInput
    update: XOR<Anime_AuthorsUpdateWithoutAnimeInput, Anime_AuthorsUncheckedUpdateWithoutAnimeInput>
    create: XOR<Anime_AuthorsCreateWithoutAnimeInput, Anime_AuthorsUncheckedCreateWithoutAnimeInput>
  }

  export type Anime_AuthorsUpdateWithWhereUniqueWithoutAnimeInput = {
    where: Anime_AuthorsWhereUniqueInput
    data: XOR<Anime_AuthorsUpdateWithoutAnimeInput, Anime_AuthorsUncheckedUpdateWithoutAnimeInput>
  }

  export type Anime_AuthorsUpdateManyWithWhereWithoutAnimeInput = {
    where: Anime_AuthorsScalarWhereInput
    data: XOR<Anime_AuthorsUpdateManyMutationInput, Anime_AuthorsUncheckedUpdateManyWithoutAnimeInput>
  }

  export type Anime_AuthorsScalarWhereInput = {
    AND?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
    OR?: Anime_AuthorsScalarWhereInput[]
    NOT?: Anime_AuthorsScalarWhereInput | Anime_AuthorsScalarWhereInput[]
    animeid?: StringFilter<"Anime_Authors"> | string
    authorid?: StringFilter<"Anime_Authors"> | string
  }

  export type BookmarksUpsertWithWhereUniqueWithoutAnimeInput = {
    where: BookmarksWhereUniqueInput
    update: XOR<BookmarksUpdateWithoutAnimeInput, BookmarksUncheckedUpdateWithoutAnimeInput>
    create: XOR<BookmarksCreateWithoutAnimeInput, BookmarksUncheckedCreateWithoutAnimeInput>
  }

  export type BookmarksUpdateWithWhereUniqueWithoutAnimeInput = {
    where: BookmarksWhereUniqueInput
    data: XOR<BookmarksUpdateWithoutAnimeInput, BookmarksUncheckedUpdateWithoutAnimeInput>
  }

  export type BookmarksUpdateManyWithWhereWithoutAnimeInput = {
    where: BookmarksScalarWhereInput
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyWithoutAnimeInput>
  }

  export type BookmarksScalarWhereInput = {
    AND?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
    OR?: BookmarksScalarWhereInput[]
    NOT?: BookmarksScalarWhereInput | BookmarksScalarWhereInput[]
    userid?: StringFilter<"Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"Bookmarks"> | string
  }

  export type ContentGroupMediaUpsertWithWhereUniqueWithoutAnimeInput = {
    where: ContentGroupMediaWhereUniqueInput
    update: XOR<ContentGroupMediaUpdateWithoutAnimeInput, ContentGroupMediaUncheckedUpdateWithoutAnimeInput>
    create: XOR<ContentGroupMediaCreateWithoutAnimeInput, ContentGroupMediaUncheckedCreateWithoutAnimeInput>
  }

  export type ContentGroupMediaUpdateWithWhereUniqueWithoutAnimeInput = {
    where: ContentGroupMediaWhereUniqueInput
    data: XOR<ContentGroupMediaUpdateWithoutAnimeInput, ContentGroupMediaUncheckedUpdateWithoutAnimeInput>
  }

  export type ContentGroupMediaUpdateManyWithWhereWithoutAnimeInput = {
    where: ContentGroupMediaScalarWhereInput
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyWithoutAnimeInput>
  }

  export type ContentGroupMediaScalarWhereInput = {
    AND?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
    OR?: ContentGroupMediaScalarWhereInput[]
    NOT?: ContentGroupMediaScalarWhereInput | ContentGroupMediaScalarWhereInput[]
    id?: StringFilter<"ContentGroupMedia"> | string
    seasonid?: StringFilter<"ContentGroupMedia"> | string
    mediaid?: StringFilter<"ContentGroupMedia"> | string
    mediatype?: EnumMediaTypeFilter<"ContentGroupMedia"> | $Enums.MediaType
  }

  export type AnimeCreateWithoutAnime_AuthorsInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutAnime_AuthorsInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutAnime_AuthorsInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutAnime_AuthorsInput, AnimeUncheckedCreateWithoutAnime_AuthorsInput>
  }

  export type UsersCreateWithoutAnime_AuthorsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutAnime_AuthorsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutAnime_AuthorsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAnime_AuthorsInput, UsersUncheckedCreateWithoutAnime_AuthorsInput>
  }

  export type AnimeUpsertWithoutAnime_AuthorsInput = {
    update: XOR<AnimeUpdateWithoutAnime_AuthorsInput, AnimeUncheckedUpdateWithoutAnime_AuthorsInput>
    create: XOR<AnimeCreateWithoutAnime_AuthorsInput, AnimeUncheckedCreateWithoutAnime_AuthorsInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutAnime_AuthorsInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutAnime_AuthorsInput, AnimeUncheckedUpdateWithoutAnime_AuthorsInput>
  }

  export type AnimeUpdateWithoutAnime_AuthorsInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutAnime_AuthorsInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type UsersUpsertWithoutAnime_AuthorsInput = {
    update: XOR<UsersUpdateWithoutAnime_AuthorsInput, UsersUncheckedUpdateWithoutAnime_AuthorsInput>
    create: XOR<UsersCreateWithoutAnime_AuthorsInput, UsersUncheckedCreateWithoutAnime_AuthorsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAnime_AuthorsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAnime_AuthorsInput, UsersUncheckedUpdateWithoutAnime_AuthorsInput>
  }

  export type UsersUpdateWithoutAnime_AuthorsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutAnime_AuthorsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AnimeCreateWithoutBookmarksInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutBookmarksInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutBookmarksInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutBookmarksInput, AnimeUncheckedCreateWithoutBookmarksInput>
  }

  export type MangaCreateWithoutBookmarksInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeCreateNestedManyWithoutMangaInput
    Users: UsersCreateNestedOneWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMangaInput
  }

  export type MangaUncheckedCreateWithoutBookmarksInput = {
    mangaid?: string
    authorid: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedCreateNestedManyWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMangaInput
  }

  export type MangaCreateOrConnectWithoutBookmarksInput = {
    where: MangaWhereUniqueInput
    create: XOR<MangaCreateWithoutBookmarksInput, MangaUncheckedCreateWithoutBookmarksInput>
  }

  export type MoviesCreateWithoutBookmarksInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Users: UsersCreateNestedOneWithoutMoviesInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMoviesInput
  }

  export type MoviesUncheckedCreateWithoutBookmarksInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    authorid: string
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMoviesInput
  }

  export type MoviesCreateOrConnectWithoutBookmarksInput = {
    where: MoviesWhereUniqueInput
    create: XOR<MoviesCreateWithoutBookmarksInput, MoviesUncheckedCreateWithoutBookmarksInput>
  }

  export type VideosCreateWithoutBookmarksInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeCreateNestedManyWithoutVideosInput
    Comments?: CommentsCreateNestedManyWithoutVideosInput
    Users: UsersCreateNestedOneWithoutVideosInput
  }

  export type VideosUncheckedCreateWithoutBookmarksInput = {
    videoid?: string
    title: string
    authorid: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeUncheckedCreateNestedManyWithoutVideosInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideosCreateOrConnectWithoutBookmarksInput = {
    where: VideosWhereUniqueInput
    create: XOR<VideosCreateWithoutBookmarksInput, VideosUncheckedCreateWithoutBookmarksInput>
  }

  export type UsersCreateWithoutBookmarksInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutBookmarksInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutBookmarksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBookmarksInput, UsersUncheckedCreateWithoutBookmarksInput>
  }

  export type AnimeUpsertWithoutBookmarksInput = {
    update: XOR<AnimeUpdateWithoutBookmarksInput, AnimeUncheckedUpdateWithoutBookmarksInput>
    create: XOR<AnimeCreateWithoutBookmarksInput, AnimeUncheckedCreateWithoutBookmarksInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutBookmarksInput, AnimeUncheckedUpdateWithoutBookmarksInput>
  }

  export type AnimeUpdateWithoutBookmarksInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutBookmarksInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type MangaUpsertWithoutBookmarksInput = {
    update: XOR<MangaUpdateWithoutBookmarksInput, MangaUncheckedUpdateWithoutBookmarksInput>
    create: XOR<MangaCreateWithoutBookmarksInput, MangaUncheckedCreateWithoutBookmarksInput>
    where?: MangaWhereInput
  }

  export type MangaUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: MangaWhereInput
    data: XOR<MangaUpdateWithoutBookmarksInput, MangaUncheckedUpdateWithoutBookmarksInput>
  }

  export type MangaUpdateWithoutBookmarksInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUpdateManyWithoutMangaNestedInput
    Users?: UsersUpdateOneRequiredWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateWithoutBookmarksInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedUpdateManyWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMangaNestedInput
  }

  export type MoviesUpsertWithoutBookmarksInput = {
    update: XOR<MoviesUpdateWithoutBookmarksInput, MoviesUncheckedUpdateWithoutBookmarksInput>
    create: XOR<MoviesCreateWithoutBookmarksInput, MoviesUncheckedCreateWithoutBookmarksInput>
    where?: MoviesWhereInput
  }

  export type MoviesUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: MoviesWhereInput
    data: XOR<MoviesUpdateWithoutBookmarksInput, MoviesUncheckedUpdateWithoutBookmarksInput>
  }

  export type MoviesUpdateWithoutBookmarksInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Users?: UsersUpdateOneRequiredWithoutMoviesNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMoviesNestedInput
  }

  export type MoviesUncheckedUpdateWithoutBookmarksInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    authorid?: StringFieldUpdateOperationsInput | string
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMoviesNestedInput
  }

  export type VideosUpsertWithoutBookmarksInput = {
    update: XOR<VideosUpdateWithoutBookmarksInput, VideosUncheckedUpdateWithoutBookmarksInput>
    create: XOR<VideosCreateWithoutBookmarksInput, VideosUncheckedCreateWithoutBookmarksInput>
    where?: VideosWhereInput
  }

  export type VideosUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: VideosWhereInput
    data: XOR<VideosUpdateWithoutBookmarksInput, VideosUncheckedUpdateWithoutBookmarksInput>
  }

  export type VideosUpdateWithoutBookmarksInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUpdateManyWithoutVideosNestedInput
    Users?: UsersUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateWithoutBookmarksInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUncheckedUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type UsersUpsertWithoutBookmarksInput = {
    update: XOR<UsersUpdateWithoutBookmarksInput, UsersUncheckedUpdateWithoutBookmarksInput>
    create: XOR<UsersCreateWithoutBookmarksInput, UsersUncheckedCreateWithoutBookmarksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutBookmarksInput, UsersUncheckedUpdateWithoutBookmarksInput>
  }

  export type UsersUpdateWithoutBookmarksInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutBookmarksInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContentUnitCreateWithoutCommentsInput = {
    episodeid?: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
    ContentGroupMedia: ContentGroupMediaCreateNestedOneWithoutContentUnitsInput
  }

  export type ContentUnitUncheckedCreateWithoutCommentsInput = {
    episodeid?: string
    contentgroupid: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
  }

  export type ContentUnitCreateOrConnectWithoutCommentsInput = {
    where: ContentUnitWhereUniqueInput
    create: XOR<ContentUnitCreateWithoutCommentsInput, ContentUnitUncheckedCreateWithoutCommentsInput>
  }

  export type VideosCreateWithoutCommentsInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksCreateNestedManyWithoutVideosInput
    Users: UsersCreateNestedOneWithoutVideosInput
  }

  export type VideosUncheckedCreateWithoutCommentsInput = {
    videoid?: string
    title: string
    authorid: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeUncheckedCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideosCreateOrConnectWithoutCommentsInput = {
    where: VideosWhereUniqueInput
    create: XOR<VideosCreateWithoutCommentsInput, VideosUncheckedCreateWithoutCommentsInput>
  }

  export type UsersCreateWithoutCommentsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCommentsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCommentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
  }

  export type ContentUnitUpsertWithoutCommentsInput = {
    update: XOR<ContentUnitUpdateWithoutCommentsInput, ContentUnitUncheckedUpdateWithoutCommentsInput>
    create: XOR<ContentUnitCreateWithoutCommentsInput, ContentUnitUncheckedCreateWithoutCommentsInput>
    where?: ContentUnitWhereInput
  }

  export type ContentUnitUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ContentUnitWhereInput
    data: XOR<ContentUnitUpdateWithoutCommentsInput, ContentUnitUncheckedUpdateWithoutCommentsInput>
  }

  export type ContentUnitUpdateWithoutCommentsInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    ContentGroupMedia?: ContentGroupMediaUpdateOneRequiredWithoutContentUnitsNestedInput
  }

  export type ContentUnitUncheckedUpdateWithoutCommentsInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    contentgroupid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
  }

  export type VideosUpsertWithoutCommentsInput = {
    update: XOR<VideosUpdateWithoutCommentsInput, VideosUncheckedUpdateWithoutCommentsInput>
    create: XOR<VideosCreateWithoutCommentsInput, VideosUncheckedCreateWithoutCommentsInput>
    where?: VideosWhereInput
  }

  export type VideosUpdateToOneWithWhereWithoutCommentsInput = {
    where?: VideosWhereInput
    data: XOR<VideosUpdateWithoutCommentsInput, VideosUncheckedUpdateWithoutCommentsInput>
  }

  export type VideosUpdateWithoutCommentsInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutVideosNestedInput
    Users?: UsersUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateWithoutCommentsInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUncheckedUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type UsersUpsertWithoutCommentsInput = {
    update: XOR<UsersUpdateWithoutCommentsInput, UsersUncheckedUpdateWithoutCommentsInput>
    create: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCommentsInput, UsersUncheckedUpdateWithoutCommentsInput>
  }

  export type UsersUpdateWithoutCommentsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCommentsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContentGroupMediaCreateWithoutContentGroupInput = {
    id?: string
    mediatype: $Enums.MediaType
    Anime?: AnimeCreateNestedOneWithoutContentGroupLinksInput
    Manga?: MangaCreateNestedOneWithoutContentGroupLinksInput
    Movies?: MoviesCreateNestedOneWithoutContentGroupLinksInput
    ContentUnits?: ContentUnitCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUncheckedCreateWithoutContentGroupInput = {
    id?: string
    mediaid: string
    mediatype: $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaCreateOrConnectWithoutContentGroupInput = {
    where: ContentGroupMediaWhereUniqueInput
    create: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput>
  }

  export type ContentGroupMediaCreateManyContentGroupInputEnvelope = {
    data: ContentGroupMediaCreateManyContentGroupInput | ContentGroupMediaCreateManyContentGroupInput[]
    skipDuplicates?: boolean
  }

  export type ContentGroupMediaUpsertWithWhereUniqueWithoutContentGroupInput = {
    where: ContentGroupMediaWhereUniqueInput
    update: XOR<ContentGroupMediaUpdateWithoutContentGroupInput, ContentGroupMediaUncheckedUpdateWithoutContentGroupInput>
    create: XOR<ContentGroupMediaCreateWithoutContentGroupInput, ContentGroupMediaUncheckedCreateWithoutContentGroupInput>
  }

  export type ContentGroupMediaUpdateWithWhereUniqueWithoutContentGroupInput = {
    where: ContentGroupMediaWhereUniqueInput
    data: XOR<ContentGroupMediaUpdateWithoutContentGroupInput, ContentGroupMediaUncheckedUpdateWithoutContentGroupInput>
  }

  export type ContentGroupMediaUpdateManyWithWhereWithoutContentGroupInput = {
    where: ContentGroupMediaScalarWhereInput
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyWithoutContentGroupInput>
  }

  export type AnimeCreateWithoutContentGroupLinksInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutContentGroupLinksInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutContentGroupLinksInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutContentGroupLinksInput, AnimeUncheckedCreateWithoutContentGroupLinksInput>
  }

  export type MangaCreateWithoutContentGroupLinksInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksCreateNestedManyWithoutMangaInput
    Users: UsersCreateNestedOneWithoutMangaInput
  }

  export type MangaUncheckedCreateWithoutContentGroupLinksInput = {
    mangaid?: string
    authorid: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMangaInput
  }

  export type MangaCreateOrConnectWithoutContentGroupLinksInput = {
    where: MangaWhereUniqueInput
    create: XOR<MangaCreateWithoutContentGroupLinksInput, MangaUncheckedCreateWithoutContentGroupLinksInput>
  }

  export type MoviesCreateWithoutContentGroupLinksInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksCreateNestedManyWithoutMoviesInput
    Users: UsersCreateNestedOneWithoutMoviesInput
  }

  export type MoviesUncheckedCreateWithoutContentGroupLinksInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    authorid: string
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMoviesInput
  }

  export type MoviesCreateOrConnectWithoutContentGroupLinksInput = {
    where: MoviesWhereUniqueInput
    create: XOR<MoviesCreateWithoutContentGroupLinksInput, MoviesUncheckedCreateWithoutContentGroupLinksInput>
  }

  export type ContentGroupCreateWithoutContentGroupLinksInput = {
    seasonid?: string
    season_number: number
    release_date?: Date | string
    visible?: boolean
    season_path?: string
  }

  export type ContentGroupUncheckedCreateWithoutContentGroupLinksInput = {
    seasonid?: string
    season_number: number
    release_date?: Date | string
    visible?: boolean
    season_path?: string
  }

  export type ContentGroupCreateOrConnectWithoutContentGroupLinksInput = {
    where: ContentGroupWhereUniqueInput
    create: XOR<ContentGroupCreateWithoutContentGroupLinksInput, ContentGroupUncheckedCreateWithoutContentGroupLinksInput>
  }

  export type ContentUnitCreateWithoutContentGroupMediaInput = {
    episodeid?: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
    Comments?: CommentsCreateNestedManyWithoutContentUnitInput
  }

  export type ContentUnitUncheckedCreateWithoutContentGroupMediaInput = {
    episodeid?: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
    Comments?: CommentsUncheckedCreateNestedManyWithoutContentUnitInput
  }

  export type ContentUnitCreateOrConnectWithoutContentGroupMediaInput = {
    where: ContentUnitWhereUniqueInput
    create: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput>
  }

  export type ContentUnitCreateManyContentGroupMediaInputEnvelope = {
    data: ContentUnitCreateManyContentGroupMediaInput | ContentUnitCreateManyContentGroupMediaInput[]
    skipDuplicates?: boolean
  }

  export type AnimeUpsertWithoutContentGroupLinksInput = {
    update: XOR<AnimeUpdateWithoutContentGroupLinksInput, AnimeUncheckedUpdateWithoutContentGroupLinksInput>
    create: XOR<AnimeCreateWithoutContentGroupLinksInput, AnimeUncheckedCreateWithoutContentGroupLinksInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutContentGroupLinksInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutContentGroupLinksInput, AnimeUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type AnimeUpdateWithoutContentGroupLinksInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutContentGroupLinksInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type MangaUpsertWithoutContentGroupLinksInput = {
    update: XOR<MangaUpdateWithoutContentGroupLinksInput, MangaUncheckedUpdateWithoutContentGroupLinksInput>
    create: XOR<MangaCreateWithoutContentGroupLinksInput, MangaUncheckedCreateWithoutContentGroupLinksInput>
    where?: MangaWhereInput
  }

  export type MangaUpdateToOneWithWhereWithoutContentGroupLinksInput = {
    where?: MangaWhereInput
    data: XOR<MangaUpdateWithoutContentGroupLinksInput, MangaUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type MangaUpdateWithoutContentGroupLinksInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutMangaNestedInput
    Users?: UsersUpdateOneRequiredWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateWithoutContentGroupLinksInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    authorid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMangaNestedInput
  }

  export type MoviesUpsertWithoutContentGroupLinksInput = {
    update: XOR<MoviesUpdateWithoutContentGroupLinksInput, MoviesUncheckedUpdateWithoutContentGroupLinksInput>
    create: XOR<MoviesCreateWithoutContentGroupLinksInput, MoviesUncheckedCreateWithoutContentGroupLinksInput>
    where?: MoviesWhereInput
  }

  export type MoviesUpdateToOneWithWhereWithoutContentGroupLinksInput = {
    where?: MoviesWhereInput
    data: XOR<MoviesUpdateWithoutContentGroupLinksInput, MoviesUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type MoviesUpdateWithoutContentGroupLinksInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUpdateManyWithoutMoviesNestedInput
    Users?: UsersUpdateOneRequiredWithoutMoviesNestedInput
  }

  export type MoviesUncheckedUpdateWithoutContentGroupLinksInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    authorid?: StringFieldUpdateOperationsInput | string
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMoviesNestedInput
  }

  export type ContentGroupUpsertWithoutContentGroupLinksInput = {
    update: XOR<ContentGroupUpdateWithoutContentGroupLinksInput, ContentGroupUncheckedUpdateWithoutContentGroupLinksInput>
    create: XOR<ContentGroupCreateWithoutContentGroupLinksInput, ContentGroupUncheckedCreateWithoutContentGroupLinksInput>
    where?: ContentGroupWhereInput
  }

  export type ContentGroupUpdateToOneWithWhereWithoutContentGroupLinksInput = {
    where?: ContentGroupWhereInput
    data: XOR<ContentGroupUpdateWithoutContentGroupLinksInput, ContentGroupUncheckedUpdateWithoutContentGroupLinksInput>
  }

  export type ContentGroupUpdateWithoutContentGroupLinksInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
  }

  export type ContentGroupUncheckedUpdateWithoutContentGroupLinksInput = {
    seasonid?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    season_path?: StringFieldUpdateOperationsInput | string
  }

  export type ContentUnitUpsertWithWhereUniqueWithoutContentGroupMediaInput = {
    where: ContentUnitWhereUniqueInput
    update: XOR<ContentUnitUpdateWithoutContentGroupMediaInput, ContentUnitUncheckedUpdateWithoutContentGroupMediaInput>
    create: XOR<ContentUnitCreateWithoutContentGroupMediaInput, ContentUnitUncheckedCreateWithoutContentGroupMediaInput>
  }

  export type ContentUnitUpdateWithWhereUniqueWithoutContentGroupMediaInput = {
    where: ContentUnitWhereUniqueInput
    data: XOR<ContentUnitUpdateWithoutContentGroupMediaInput, ContentUnitUncheckedUpdateWithoutContentGroupMediaInput>
  }

  export type ContentUnitUpdateManyWithWhereWithoutContentGroupMediaInput = {
    where: ContentUnitScalarWhereInput
    data: XOR<ContentUnitUpdateManyMutationInput, ContentUnitUncheckedUpdateManyWithoutContentGroupMediaInput>
  }

  export type ContentUnitScalarWhereInput = {
    AND?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
    OR?: ContentUnitScalarWhereInput[]
    NOT?: ContentUnitScalarWhereInput | ContentUnitScalarWhereInput[]
    episodeid?: StringFilter<"ContentUnit"> | string
    contentgroupid?: StringFilter<"ContentUnit"> | string
    title?: StringFilter<"ContentUnit"> | string
    description?: StringFilter<"ContentUnit"> | string
    release_date?: DateTimeNullableFilter<"ContentUnit"> | Date | string | null
    likes?: BigIntFilter<"ContentUnit"> | bigint | number
    dislikes?: BigIntFilter<"ContentUnit"> | bigint | number
    visible?: BoolFilter<"ContentUnit"> | boolean
    episode_number?: FloatFilter<"ContentUnit"> | number
    views?: IntFilter<"ContentUnit"> | number
    duration?: IntFilter<"ContentUnit"> | number
    episode_path?: StringFilter<"ContentUnit"> | string
    thumbnail?: StringFilter<"ContentUnit"> | string
  }

  export type CommentsCreateWithoutContentUnitInput = {
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    Videos: VideosCreateNestedOneWithoutCommentsInput
    Users: UsersCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutContentUnitInput = {
    commentid?: number
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsCreateOrConnectWithoutContentUnitInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput>
  }

  export type CommentsCreateManyContentUnitInputEnvelope = {
    data: CommentsCreateManyContentUnitInput | CommentsCreateManyContentUnitInput[]
    skipDuplicates?: boolean
  }

  export type ContentGroupMediaCreateWithoutContentUnitsInput = {
    id?: string
    mediatype: $Enums.MediaType
    Anime?: AnimeCreateNestedOneWithoutContentGroupLinksInput
    Manga?: MangaCreateNestedOneWithoutContentGroupLinksInput
    Movies?: MoviesCreateNestedOneWithoutContentGroupLinksInput
    ContentGroup: ContentGroupCreateNestedOneWithoutContentGroupLinksInput
  }

  export type ContentGroupMediaUncheckedCreateWithoutContentUnitsInput = {
    id?: string
    seasonid: string
    mediaid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaCreateOrConnectWithoutContentUnitsInput = {
    where: ContentGroupMediaWhereUniqueInput
    create: XOR<ContentGroupMediaCreateWithoutContentUnitsInput, ContentGroupMediaUncheckedCreateWithoutContentUnitsInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutContentUnitInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutContentUnitInput, CommentsUncheckedUpdateWithoutContentUnitInput>
    create: XOR<CommentsCreateWithoutContentUnitInput, CommentsUncheckedCreateWithoutContentUnitInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutContentUnitInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutContentUnitInput, CommentsUncheckedUpdateWithoutContentUnitInput>
  }

  export type CommentsUpdateManyWithWhereWithoutContentUnitInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutContentUnitInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    OR?: CommentsScalarWhereInput[]
    NOT?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    commentid?: IntFilter<"Comments"> | number
    parentid?: StringFilter<"Comments"> | string
    mediatype?: EnumMediaTypeFilter<"Comments"> | $Enums.MediaType
    mediatime?: IntFilter<"Comments"> | number
    userid?: StringFilter<"Comments"> | string
    comment_text?: StringFilter<"Comments"> | string
    comment_date?: DateTimeFilter<"Comments"> | Date | string
    parent_comment_id?: IntNullableFilter<"Comments"> | number | null
    likes?: BigIntFilter<"Comments"> | bigint | number
    dislikes?: BigIntFilter<"Comments"> | bigint | number
  }

  export type ContentGroupMediaUpsertWithoutContentUnitsInput = {
    update: XOR<ContentGroupMediaUpdateWithoutContentUnitsInput, ContentGroupMediaUncheckedUpdateWithoutContentUnitsInput>
    create: XOR<ContentGroupMediaCreateWithoutContentUnitsInput, ContentGroupMediaUncheckedCreateWithoutContentUnitsInput>
    where?: ContentGroupMediaWhereInput
  }

  export type ContentGroupMediaUpdateToOneWithWhereWithoutContentUnitsInput = {
    where?: ContentGroupMediaWhereInput
    data: XOR<ContentGroupMediaUpdateWithoutContentUnitsInput, ContentGroupMediaUncheckedUpdateWithoutContentUnitsInput>
  }

  export type ContentGroupMediaUpdateWithoutContentUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneWithoutContentGroupLinksNestedInput
    Manga?: MangaUpdateOneWithoutContentGroupLinksNestedInput
    Movies?: MoviesUpdateOneWithoutContentGroupLinksNestedInput
    ContentGroup?: ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateWithoutContentUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediaid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type UsersCreateWithoutDisliked_ContentInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutDisliked_ContentInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutDisliked_ContentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutDisliked_ContentInput, UsersUncheckedCreateWithoutDisliked_ContentInput>
  }

  export type UsersUpsertWithoutDisliked_ContentInput = {
    update: XOR<UsersUpdateWithoutDisliked_ContentInput, UsersUncheckedUpdateWithoutDisliked_ContentInput>
    create: XOR<UsersCreateWithoutDisliked_ContentInput, UsersUncheckedCreateWithoutDisliked_ContentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutDisliked_ContentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutDisliked_ContentInput, UsersUncheckedUpdateWithoutDisliked_ContentInput>
  }

  export type UsersUpdateWithoutDisliked_ContentInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutDisliked_ContentInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FolderCreateWithoutFileInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    Users: UsersCreateNestedOneWithoutFolderInput
    Folder?: FolderCreateNestedOneWithoutOther_FolderInput
    other_Folder?: FolderCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutFileInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    ownerId: string
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    other_Folder?: FolderUncheckedCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutFileInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFileInput, FolderUncheckedCreateWithoutFileInput>
  }

  export type UsersCreateWithoutFileInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFileInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFileInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFileInput, UsersUncheckedCreateWithoutFileInput>
  }

  export type FileSharesCreateWithoutFileInput = {
    accessLevel?: $Enums.AccessLevel
    Users: UsersCreateNestedOneWithoutFileSharesInput
  }

  export type FileSharesUncheckedCreateWithoutFileInput = {
    userId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileSharesCreateOrConnectWithoutFileInput = {
    where: FileSharesWhereUniqueInput
    create: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput>
  }

  export type FileSharesCreateManyFileInputEnvelope = {
    data: FileSharesCreateManyFileInput | FileSharesCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type FolderUpsertWithoutFileInput = {
    update: XOR<FolderUpdateWithoutFileInput, FolderUncheckedUpdateWithoutFileInput>
    create: XOR<FolderCreateWithoutFileInput, FolderUncheckedCreateWithoutFileInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutFileInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutFileInput, FolderUncheckedUpdateWithoutFileInput>
  }

  export type FolderUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Users?: UsersUpdateOneRequiredWithoutFolderNestedInput
    Folder?: FolderUpdateOneWithoutOther_FolderNestedInput
    other_Folder?: FolderUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    other_Folder?: FolderUncheckedUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type UsersUpsertWithoutFileInput = {
    update: XOR<UsersUpdateWithoutFileInput, UsersUncheckedUpdateWithoutFileInput>
    create: XOR<UsersCreateWithoutFileInput, UsersUncheckedCreateWithoutFileInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFileInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFileInput, UsersUncheckedUpdateWithoutFileInput>
  }

  export type UsersUpdateWithoutFileInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFileInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FileSharesUpsertWithWhereUniqueWithoutFileInput = {
    where: FileSharesWhereUniqueInput
    update: XOR<FileSharesUpdateWithoutFileInput, FileSharesUncheckedUpdateWithoutFileInput>
    create: XOR<FileSharesCreateWithoutFileInput, FileSharesUncheckedCreateWithoutFileInput>
  }

  export type FileSharesUpdateWithWhereUniqueWithoutFileInput = {
    where: FileSharesWhereUniqueInput
    data: XOR<FileSharesUpdateWithoutFileInput, FileSharesUncheckedUpdateWithoutFileInput>
  }

  export type FileSharesUpdateManyWithWhereWithoutFileInput = {
    where: FileSharesScalarWhereInput
    data: XOR<FileSharesUpdateManyMutationInput, FileSharesUncheckedUpdateManyWithoutFileInput>
  }

  export type FileSharesScalarWhereInput = {
    AND?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
    OR?: FileSharesScalarWhereInput[]
    NOT?: FileSharesScalarWhereInput | FileSharesScalarWhereInput[]
    userId?: StringFilter<"FileShares"> | string
    fileId?: StringFilter<"FileShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FileShares"> | $Enums.AccessLevel
  }

  export type FileCreateWithoutFileSharesInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    Folder?: FolderCreateNestedOneWithoutFileInput
    Users: UsersCreateNestedOneWithoutFileInput
  }

  export type FileUncheckedCreateWithoutFileSharesInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    folderId?: string | null
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    ownerId: string
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FileCreateOrConnectWithoutFileSharesInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFileSharesInput, FileUncheckedCreateWithoutFileSharesInput>
  }

  export type UsersCreateWithoutFileSharesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFileSharesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFileSharesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFileSharesInput, UsersUncheckedCreateWithoutFileSharesInput>
  }

  export type FileUpsertWithoutFileSharesInput = {
    update: XOR<FileUpdateWithoutFileSharesInput, FileUncheckedUpdateWithoutFileSharesInput>
    create: XOR<FileCreateWithoutFileSharesInput, FileUncheckedCreateWithoutFileSharesInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutFileSharesInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutFileSharesInput, FileUncheckedUpdateWithoutFileSharesInput>
  }

  export type FileUpdateWithoutFileSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Folder?: FolderUpdateOneWithoutFileNestedInput
    Users?: UsersUpdateOneRequiredWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutFileSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type UsersUpsertWithoutFileSharesInput = {
    update: XOR<UsersUpdateWithoutFileSharesInput, UsersUncheckedUpdateWithoutFileSharesInput>
    create: XOR<UsersCreateWithoutFileSharesInput, UsersUncheckedCreateWithoutFileSharesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFileSharesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFileSharesInput, UsersUncheckedUpdateWithoutFileSharesInput>
  }

  export type UsersUpdateWithoutFileSharesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFileSharesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FileCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    Users: UsersCreateNestedOneWithoutFileInput
    FileShares?: FileSharesCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    ownerId: string
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutFolderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileCreateManyFolderInputEnvelope = {
    data: FileCreateManyFolderInput | FileCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutFolderInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFolderInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFolderInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFolderInput, UsersUncheckedCreateWithoutFolderInput>
  }

  export type FolderCreateWithoutOther_FolderInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileCreateNestedManyWithoutFolderInput
    Users: UsersCreateNestedOneWithoutFolderInput
    Folder?: FolderCreateNestedOneWithoutOther_FolderInput
    FolderShares?: FolderSharesCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutOther_FolderInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    ownerId: string
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileUncheckedCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutOther_FolderInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutOther_FolderInput, FolderUncheckedCreateWithoutOther_FolderInput>
  }

  export type FolderCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileCreateNestedManyWithoutFolderInput
    Users: UsersCreateNestedOneWithoutFolderInput
    other_Folder?: FolderCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileUncheckedCreateNestedManyWithoutFolderInput
    other_Folder?: FolderUncheckedCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutFolderInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput>
  }

  export type FolderCreateManyFolderInputEnvelope = {
    data: FolderCreateManyFolderInput | FolderCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FolderSharesCreateWithoutFolderInput = {
    accessLevel?: $Enums.AccessLevel
    Users: UsersCreateNestedOneWithoutFolderSharesInput
  }

  export type FolderSharesUncheckedCreateWithoutFolderInput = {
    userId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FolderSharesCreateOrConnectWithoutFolderInput = {
    where: FolderSharesWhereUniqueInput
    create: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput>
  }

  export type FolderSharesCreateManyFolderInputEnvelope = {
    data: FolderSharesCreateManyFolderInput | FolderSharesCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FileUpsertWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
    create: XOR<FileCreateWithoutFolderInput, FileUncheckedCreateWithoutFolderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutFolderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutFolderInput, FileUncheckedUpdateWithoutFolderInput>
  }

  export type FileUpdateManyWithWhereWithoutFolderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFolderInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    description?: StringNullableFilter<"File"> | string | null
    path?: StringFilter<"File"> | string
    extension?: StringFilter<"File"> | string
    folderId?: StringNullableFilter<"File"> | string | null
    size?: BigIntFilter<"File"> | bigint | number
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"File"> | Date | string | null
    isShared?: BoolFilter<"File"> | boolean
    ownerId?: StringFilter<"File"> | string
    tags?: StringNullableListFilter<"File">
    checksum?: StringNullableFilter<"File"> | string | null
    downloadCount?: IntFilter<"File"> | number
    previewEnabled?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    filetype?: EnumFileTypeFilter<"File"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
  }

  export type UsersUpsertWithoutFolderInput = {
    update: XOR<UsersUpdateWithoutFolderInput, UsersUncheckedUpdateWithoutFolderInput>
    create: XOR<UsersCreateWithoutFolderInput, UsersUncheckedCreateWithoutFolderInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFolderInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFolderInput, UsersUncheckedUpdateWithoutFolderInput>
  }

  export type UsersUpdateWithoutFolderInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFolderInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FolderUpsertWithoutOther_FolderInput = {
    update: XOR<FolderUpdateWithoutOther_FolderInput, FolderUncheckedUpdateWithoutOther_FolderInput>
    create: XOR<FolderCreateWithoutOther_FolderInput, FolderUncheckedCreateWithoutOther_FolderInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutOther_FolderInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutOther_FolderInput, FolderUncheckedUpdateWithoutOther_FolderInput>
  }

  export type FolderUpdateWithoutOther_FolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUpdateManyWithoutFolderNestedInput
    Users?: UsersUpdateOneRequiredWithoutFolderNestedInput
    Folder?: FolderUpdateOneWithoutOther_FolderNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutOther_FolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUncheckedUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUpsertWithWhereUniqueWithoutFolderInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutFolderInput, FolderUncheckedUpdateWithoutFolderInput>
    create: XOR<FolderCreateWithoutFolderInput, FolderUncheckedCreateWithoutFolderInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutFolderInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutFolderInput, FolderUncheckedUpdateWithoutFolderInput>
  }

  export type FolderUpdateManyWithWhereWithoutFolderInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutFolderInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Folder"> | Date | string | null
    lastAccessed?: DateTimeNullableFilter<"Folder"> | Date | string | null
    ownerId?: StringFilter<"Folder"> | string
    tags?: StringNullableListFilter<"Folder">
    accessCount?: IntFilter<"Folder"> | number
    totalSize?: IntFilter<"Folder"> | number
    parentFolderId?: StringNullableFilter<"Folder"> | string | null
    filetype?: EnumFileTypeFilter<"Folder"> | $Enums.FileType
    location?: EnumMediaTypeFilter<"Folder"> | $Enums.MediaType
  }

  export type FolderSharesUpsertWithWhereUniqueWithoutFolderInput = {
    where: FolderSharesWhereUniqueInput
    update: XOR<FolderSharesUpdateWithoutFolderInput, FolderSharesUncheckedUpdateWithoutFolderInput>
    create: XOR<FolderSharesCreateWithoutFolderInput, FolderSharesUncheckedCreateWithoutFolderInput>
  }

  export type FolderSharesUpdateWithWhereUniqueWithoutFolderInput = {
    where: FolderSharesWhereUniqueInput
    data: XOR<FolderSharesUpdateWithoutFolderInput, FolderSharesUncheckedUpdateWithoutFolderInput>
  }

  export type FolderSharesUpdateManyWithWhereWithoutFolderInput = {
    where: FolderSharesScalarWhereInput
    data: XOR<FolderSharesUpdateManyMutationInput, FolderSharesUncheckedUpdateManyWithoutFolderInput>
  }

  export type FolderSharesScalarWhereInput = {
    AND?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
    OR?: FolderSharesScalarWhereInput[]
    NOT?: FolderSharesScalarWhereInput | FolderSharesScalarWhereInput[]
    userId?: StringFilter<"FolderShares"> | string
    folderId?: StringFilter<"FolderShares"> | string
    accessLevel?: EnumAccessLevelFilter<"FolderShares"> | $Enums.AccessLevel
  }

  export type FolderCreateWithoutFolderSharesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileCreateNestedManyWithoutFolderInput
    Users: UsersCreateNestedOneWithoutFolderInput
    Folder?: FolderCreateNestedOneWithoutOther_FolderInput
    other_Folder?: FolderCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutFolderSharesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    ownerId: string
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileUncheckedCreateNestedManyWithoutFolderInput
    other_Folder?: FolderUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutFolderSharesInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFolderSharesInput, FolderUncheckedCreateWithoutFolderSharesInput>
  }

  export type UsersCreateWithoutFolderSharesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFolderSharesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFolderSharesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFolderSharesInput, UsersUncheckedCreateWithoutFolderSharesInput>
  }

  export type FolderUpsertWithoutFolderSharesInput = {
    update: XOR<FolderUpdateWithoutFolderSharesInput, FolderUncheckedUpdateWithoutFolderSharesInput>
    create: XOR<FolderCreateWithoutFolderSharesInput, FolderUncheckedCreateWithoutFolderSharesInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutFolderSharesInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutFolderSharesInput, FolderUncheckedUpdateWithoutFolderSharesInput>
  }

  export type FolderUpdateWithoutFolderSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUpdateManyWithoutFolderNestedInput
    Users?: UsersUpdateOneRequiredWithoutFolderNestedInput
    Folder?: FolderUpdateOneWithoutOther_FolderNestedInput
    other_Folder?: FolderUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutFolderSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUncheckedUpdateManyWithoutFolderNestedInput
    other_Folder?: FolderUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type UsersUpsertWithoutFolderSharesInput = {
    update: XOR<UsersUpdateWithoutFolderSharesInput, UsersUncheckedUpdateWithoutFolderSharesInput>
    create: XOR<UsersCreateWithoutFolderSharesInput, UsersUncheckedCreateWithoutFolderSharesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFolderSharesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFolderSharesInput, UsersUncheckedUpdateWithoutFolderSharesInput>
  }

  export type UsersUpdateWithoutFolderSharesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFolderSharesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutLiked_ContentInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutLiked_ContentInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutLiked_ContentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLiked_ContentInput, UsersUncheckedCreateWithoutLiked_ContentInput>
  }

  export type UsersUpsertWithoutLiked_ContentInput = {
    update: XOR<UsersUpdateWithoutLiked_ContentInput, UsersUncheckedUpdateWithoutLiked_ContentInput>
    create: XOR<UsersCreateWithoutLiked_ContentInput, UsersUncheckedCreateWithoutLiked_ContentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutLiked_ContentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutLiked_ContentInput, UsersUncheckedUpdateWithoutLiked_ContentInput>
  }

  export type UsersUpdateWithoutLiked_ContentInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutLiked_ContentInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AnimeCreateWithoutMangaInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutMangaInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutMangaInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput>
  }

  export type AnimeCreateManyMangaInputEnvelope = {
    data: AnimeCreateManyMangaInput | AnimeCreateManyMangaInput[]
    skipDuplicates?: boolean
  }

  export type BookmarksCreateWithoutMangaInput = {
    mediatype: $Enums.MediaType
    Anime: AnimeCreateNestedOneWithoutBookmarksInput
    Movies: MoviesCreateNestedOneWithoutBookmarksInput
    Videos: VideosCreateNestedOneWithoutBookmarksInput
    Users: UsersCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateWithoutMangaInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksCreateOrConnectWithoutMangaInput = {
    where: BookmarksWhereUniqueInput
    create: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput>
  }

  export type BookmarksCreateManyMangaInputEnvelope = {
    data: BookmarksCreateManyMangaInput | BookmarksCreateManyMangaInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutMangaInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMangaInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMangaInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMangaInput, UsersUncheckedCreateWithoutMangaInput>
  }

  export type ContentGroupMediaCreateWithoutMangaInput = {
    id?: string
    mediatype: $Enums.MediaType
    Anime?: AnimeCreateNestedOneWithoutContentGroupLinksInput
    Movies?: MoviesCreateNestedOneWithoutContentGroupLinksInput
    ContentGroup: ContentGroupCreateNestedOneWithoutContentGroupLinksInput
    ContentUnits?: ContentUnitCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUncheckedCreateWithoutMangaInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaCreateOrConnectWithoutMangaInput = {
    where: ContentGroupMediaWhereUniqueInput
    create: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput>
  }

  export type ContentGroupMediaCreateManyMangaInputEnvelope = {
    data: ContentGroupMediaCreateManyMangaInput | ContentGroupMediaCreateManyMangaInput[]
    skipDuplicates?: boolean
  }

  export type AnimeUpsertWithWhereUniqueWithoutMangaInput = {
    where: AnimeWhereUniqueInput
    update: XOR<AnimeUpdateWithoutMangaInput, AnimeUncheckedUpdateWithoutMangaInput>
    create: XOR<AnimeCreateWithoutMangaInput, AnimeUncheckedCreateWithoutMangaInput>
  }

  export type AnimeUpdateWithWhereUniqueWithoutMangaInput = {
    where: AnimeWhereUniqueInput
    data: XOR<AnimeUpdateWithoutMangaInput, AnimeUncheckedUpdateWithoutMangaInput>
  }

  export type AnimeUpdateManyWithWhereWithoutMangaInput = {
    where: AnimeScalarWhereInput
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyWithoutMangaInput>
  }

  export type AnimeScalarWhereInput = {
    AND?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
    OR?: AnimeScalarWhereInput[]
    NOT?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
    animeid?: StringFilter<"Anime"> | string
    description?: StringNullableFilter<"Anime"> | string | null
    trailerid?: StringNullableFilter<"Anime"> | string | null
    upload_date?: DateTimeNullableFilter<"Anime"> | Date | string | null
    release_date?: DateTimeFilter<"Anime"> | Date | string
    likes?: BigIntFilter<"Anime"> | bigint | number
    dislikes?: BigIntFilter<"Anime"> | bigint | number
    activity?: IntFilter<"Anime"> | number
    authorid?: StringFilter<"Anime"> | string
    average_rating?: FloatFilter<"Anime"> | number
    anime_ratings?: IntFilter<"Anime"> | number
    age_rating?: EnumAgeRatingFilter<"Anime"> | $Enums.AgeRating
    mangaid?: StringNullableFilter<"Anime"> | string | null
    title?: StringFilter<"Anime"> | string
    type?: EnumMediaTypeFilter<"Anime"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Anime">
    anime_key_visual?: StringNullableFilter<"Anime"> | string | null
    visible?: BoolFilter<"Anime"> | boolean
  }

  export type BookmarksUpsertWithWhereUniqueWithoutMangaInput = {
    where: BookmarksWhereUniqueInput
    update: XOR<BookmarksUpdateWithoutMangaInput, BookmarksUncheckedUpdateWithoutMangaInput>
    create: XOR<BookmarksCreateWithoutMangaInput, BookmarksUncheckedCreateWithoutMangaInput>
  }

  export type BookmarksUpdateWithWhereUniqueWithoutMangaInput = {
    where: BookmarksWhereUniqueInput
    data: XOR<BookmarksUpdateWithoutMangaInput, BookmarksUncheckedUpdateWithoutMangaInput>
  }

  export type BookmarksUpdateManyWithWhereWithoutMangaInput = {
    where: BookmarksScalarWhereInput
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyWithoutMangaInput>
  }

  export type UsersUpsertWithoutMangaInput = {
    update: XOR<UsersUpdateWithoutMangaInput, UsersUncheckedUpdateWithoutMangaInput>
    create: XOR<UsersCreateWithoutMangaInput, UsersUncheckedCreateWithoutMangaInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMangaInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMangaInput, UsersUncheckedUpdateWithoutMangaInput>
  }

  export type UsersUpdateWithoutMangaInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMangaInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContentGroupMediaUpsertWithWhereUniqueWithoutMangaInput = {
    where: ContentGroupMediaWhereUniqueInput
    update: XOR<ContentGroupMediaUpdateWithoutMangaInput, ContentGroupMediaUncheckedUpdateWithoutMangaInput>
    create: XOR<ContentGroupMediaCreateWithoutMangaInput, ContentGroupMediaUncheckedCreateWithoutMangaInput>
  }

  export type ContentGroupMediaUpdateWithWhereUniqueWithoutMangaInput = {
    where: ContentGroupMediaWhereUniqueInput
    data: XOR<ContentGroupMediaUpdateWithoutMangaInput, ContentGroupMediaUncheckedUpdateWithoutMangaInput>
  }

  export type ContentGroupMediaUpdateManyWithWhereWithoutMangaInput = {
    where: ContentGroupMediaScalarWhereInput
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyWithoutMangaInput>
  }

  export type BookmarksCreateWithoutMoviesInput = {
    mediatype: $Enums.MediaType
    Anime: AnimeCreateNestedOneWithoutBookmarksInput
    Manga: MangaCreateNestedOneWithoutBookmarksInput
    Videos: VideosCreateNestedOneWithoutBookmarksInput
    Users: UsersCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateWithoutMoviesInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksCreateOrConnectWithoutMoviesInput = {
    where: BookmarksWhereUniqueInput
    create: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput>
  }

  export type BookmarksCreateManyMoviesInputEnvelope = {
    data: BookmarksCreateManyMoviesInput | BookmarksCreateManyMoviesInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutMoviesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMoviesInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMoviesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMoviesInput, UsersUncheckedCreateWithoutMoviesInput>
  }

  export type ContentGroupMediaCreateWithoutMoviesInput = {
    id?: string
    mediatype: $Enums.MediaType
    Anime?: AnimeCreateNestedOneWithoutContentGroupLinksInput
    Manga?: MangaCreateNestedOneWithoutContentGroupLinksInput
    ContentGroup: ContentGroupCreateNestedOneWithoutContentGroupLinksInput
    ContentUnits?: ContentUnitCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaUncheckedCreateWithoutMoviesInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedCreateNestedManyWithoutContentGroupMediaInput
  }

  export type ContentGroupMediaCreateOrConnectWithoutMoviesInput = {
    where: ContentGroupMediaWhereUniqueInput
    create: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput>
  }

  export type ContentGroupMediaCreateManyMoviesInputEnvelope = {
    data: ContentGroupMediaCreateManyMoviesInput | ContentGroupMediaCreateManyMoviesInput[]
    skipDuplicates?: boolean
  }

  export type BookmarksUpsertWithWhereUniqueWithoutMoviesInput = {
    where: BookmarksWhereUniqueInput
    update: XOR<BookmarksUpdateWithoutMoviesInput, BookmarksUncheckedUpdateWithoutMoviesInput>
    create: XOR<BookmarksCreateWithoutMoviesInput, BookmarksUncheckedCreateWithoutMoviesInput>
  }

  export type BookmarksUpdateWithWhereUniqueWithoutMoviesInput = {
    where: BookmarksWhereUniqueInput
    data: XOR<BookmarksUpdateWithoutMoviesInput, BookmarksUncheckedUpdateWithoutMoviesInput>
  }

  export type BookmarksUpdateManyWithWhereWithoutMoviesInput = {
    where: BookmarksScalarWhereInput
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyWithoutMoviesInput>
  }

  export type UsersUpsertWithoutMoviesInput = {
    update: XOR<UsersUpdateWithoutMoviesInput, UsersUncheckedUpdateWithoutMoviesInput>
    create: XOR<UsersCreateWithoutMoviesInput, UsersUncheckedCreateWithoutMoviesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMoviesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMoviesInput, UsersUncheckedUpdateWithoutMoviesInput>
  }

  export type UsersUpdateWithoutMoviesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMoviesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContentGroupMediaUpsertWithWhereUniqueWithoutMoviesInput = {
    where: ContentGroupMediaWhereUniqueInput
    update: XOR<ContentGroupMediaUpdateWithoutMoviesInput, ContentGroupMediaUncheckedUpdateWithoutMoviesInput>
    create: XOR<ContentGroupMediaCreateWithoutMoviesInput, ContentGroupMediaUncheckedCreateWithoutMoviesInput>
  }

  export type ContentGroupMediaUpdateWithWhereUniqueWithoutMoviesInput = {
    where: ContentGroupMediaWhereUniqueInput
    data: XOR<ContentGroupMediaUpdateWithoutMoviesInput, ContentGroupMediaUncheckedUpdateWithoutMoviesInput>
  }

  export type ContentGroupMediaUpdateManyWithWhereWithoutMoviesInput = {
    where: ContentGroupMediaScalarWhereInput
    data: XOR<ContentGroupMediaUpdateManyMutationInput, ContentGroupMediaUncheckedUpdateManyWithoutMoviesInput>
  }

  export type UsersCreateWithoutPollsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPollsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPollsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPollsInput, UsersUncheckedCreateWithoutPollsInput>
  }

  export type UsersUpsertWithoutPollsInput = {
    update: XOR<UsersUpdateWithoutPollsInput, UsersUncheckedUpdateWithoutPollsInput>
    create: XOR<UsersCreateWithoutPollsInput, UsersUncheckedCreateWithoutPollsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPollsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPollsInput, UsersUncheckedUpdateWithoutPollsInput>
  }

  export type UsersUpdateWithoutPollsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPollsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutReviewsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutReviewsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutReviewsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
  }

  export type UsersUpsertWithoutReviewsInput = {
    update: XOR<UsersUpdateWithoutReviewsInput, UsersUncheckedUpdateWithoutReviewsInput>
    create: XOR<UsersCreateWithoutReviewsInput, UsersUncheckedCreateWithoutReviewsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReviewsInput, UsersUncheckedUpdateWithoutReviewsInput>
  }

  export type UsersUpdateWithoutReviewsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutReviewsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type StoreCreateWithoutShopping_CartInput = {
    storeid?: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
    Users: UsersCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutShopping_CartInput = {
    storeid?: string
    sellerid: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type StoreCreateOrConnectWithoutShopping_CartInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutShopping_CartInput, StoreUncheckedCreateWithoutShopping_CartInput>
  }

  export type UsersCreateWithoutShopping_CartInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutShopping_CartInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutShopping_CartInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutShopping_CartInput, UsersUncheckedCreateWithoutShopping_CartInput>
  }

  export type StoreUpsertWithoutShopping_CartInput = {
    update: XOR<StoreUpdateWithoutShopping_CartInput, StoreUncheckedUpdateWithoutShopping_CartInput>
    create: XOR<StoreCreateWithoutShopping_CartInput, StoreUncheckedCreateWithoutShopping_CartInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutShopping_CartInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutShopping_CartInput, StoreUncheckedUpdateWithoutShopping_CartInput>
  }

  export type StoreUpdateWithoutShopping_CartInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
    Users?: UsersUpdateOneRequiredWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutShopping_CartInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    sellerid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type UsersUpsertWithoutShopping_CartInput = {
    update: XOR<UsersUpdateWithoutShopping_CartInput, UsersUncheckedUpdateWithoutShopping_CartInput>
    create: XOR<UsersCreateWithoutShopping_CartInput, UsersUncheckedCreateWithoutShopping_CartInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutShopping_CartInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutShopping_CartInput, UsersUncheckedUpdateWithoutShopping_CartInput>
  }

  export type UsersUpdateWithoutShopping_CartInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutShopping_CartInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type Shopping_CartCreateWithoutStoreInput = {
    quantity?: number | null
    Users: UsersCreateNestedOneWithoutShopping_CartInput
  }

  export type Shopping_CartUncheckedCreateWithoutStoreInput = {
    userid: string
    quantity?: number | null
  }

  export type Shopping_CartCreateOrConnectWithoutStoreInput = {
    where: Shopping_CartWhereUniqueInput
    create: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput>
  }

  export type Shopping_CartCreateManyStoreInputEnvelope = {
    data: Shopping_CartCreateManyStoreInput | Shopping_CartCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutStoreInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutStoreInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutStoreInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutStoreInput, UsersUncheckedCreateWithoutStoreInput>
  }

  export type Shopping_CartUpsertWithWhereUniqueWithoutStoreInput = {
    where: Shopping_CartWhereUniqueInput
    update: XOR<Shopping_CartUpdateWithoutStoreInput, Shopping_CartUncheckedUpdateWithoutStoreInput>
    create: XOR<Shopping_CartCreateWithoutStoreInput, Shopping_CartUncheckedCreateWithoutStoreInput>
  }

  export type Shopping_CartUpdateWithWhereUniqueWithoutStoreInput = {
    where: Shopping_CartWhereUniqueInput
    data: XOR<Shopping_CartUpdateWithoutStoreInput, Shopping_CartUncheckedUpdateWithoutStoreInput>
  }

  export type Shopping_CartUpdateManyWithWhereWithoutStoreInput = {
    where: Shopping_CartScalarWhereInput
    data: XOR<Shopping_CartUpdateManyMutationInput, Shopping_CartUncheckedUpdateManyWithoutStoreInput>
  }

  export type Shopping_CartScalarWhereInput = {
    AND?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
    OR?: Shopping_CartScalarWhereInput[]
    NOT?: Shopping_CartScalarWhereInput | Shopping_CartScalarWhereInput[]
    userid?: StringFilter<"Shopping_Cart"> | string
    storeid?: StringFilter<"Shopping_Cart"> | string
    quantity?: IntNullableFilter<"Shopping_Cart"> | number | null
  }

  export type UsersUpsertWithoutStoreInput = {
    update: XOR<UsersUpdateWithoutStoreInput, UsersUncheckedUpdateWithoutStoreInput>
    create: XOR<UsersCreateWithoutStoreInput, UsersUncheckedCreateWithoutStoreInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutStoreInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutStoreInput, UsersUncheckedUpdateWithoutStoreInput>
  }

  export type UsersUpdateWithoutStoreInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutStoreInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutSubscription_tierInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutSubscription_tierInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutSubscription_tierInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput>
  }

  export type UsersCreateManySubscription_tierInputEnvelope = {
    data: UsersCreateManySubscription_tierInput | UsersCreateManySubscription_tierInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutSubscription_tierInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutSubscription_tierInput, UsersUncheckedUpdateWithoutSubscription_tierInput>
    create: XOR<UsersCreateWithoutSubscription_tierInput, UsersUncheckedCreateWithoutSubscription_tierInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutSubscription_tierInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutSubscription_tierInput, UsersUncheckedUpdateWithoutSubscription_tierInput>
  }

  export type UsersUpdateManyWithWhereWithoutSubscription_tierInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutSubscription_tierInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    userid?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password_hash?: StringFilter<"Users"> | string
    date_joined?: DateTimeFilter<"Users"> | Date | string
    num_of_friends?: IntNullableFilter<"Users"> | number | null
    num_of_followers?: IntNullableFilter<"Users"> | number | null
    profile_picture?: StringNullableFilter<"Users"> | string | null
    user_bio?: StringNullableFilter<"Users"> | string | null
    two_factor?: BoolFilter<"Users"> | boolean
    email_notifications?: BoolFilter<"Users"> | boolean
    push_notifications?: BoolFilter<"Users"> | boolean
    subscriptionTierId?: IntNullableFilter<"Users"> | number | null
    usedstorage?: BigIntFilter<"Users"> | bigint | number
    accountType?: EnumAccountTypeFilter<"Users"> | $Enums.AccountType
  }

  export type UsersCreateWithoutUser_ActivityInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUser_ActivityInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUser_ActivityInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUser_ActivityInput, UsersUncheckedCreateWithoutUser_ActivityInput>
  }

  export type UsersUpsertWithoutUser_ActivityInput = {
    update: XOR<UsersUpdateWithoutUser_ActivityInput, UsersUncheckedUpdateWithoutUser_ActivityInput>
    create: XOR<UsersCreateWithoutUser_ActivityInput, UsersUncheckedCreateWithoutUser_ActivityInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUser_ActivityInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUser_ActivityInput, UsersUncheckedUpdateWithoutUser_ActivityInput>
  }

  export type UsersUpdateWithoutUser_ActivityInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUser_ActivityInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutUser_BookmarksInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUser_BookmarksInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUser_BookmarksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUser_BookmarksInput, UsersUncheckedCreateWithoutUser_BookmarksInput>
  }

  export type UsersUpsertWithoutUser_BookmarksInput = {
    update: XOR<UsersUpdateWithoutUser_BookmarksInput, UsersUncheckedUpdateWithoutUser_BookmarksInput>
    create: XOR<UsersCreateWithoutUser_BookmarksInput, UsersUncheckedCreateWithoutUser_BookmarksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUser_BookmarksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUser_BookmarksInput, UsersUncheckedUpdateWithoutUser_BookmarksInput>
  }

  export type UsersUpdateWithoutUser_BookmarksInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUser_BookmarksInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutUser_RatingsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    Videos?: VideosCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUser_RatingsInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Videos?: VideosUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUser_RatingsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUser_RatingsInput, UsersUncheckedCreateWithoutUser_RatingsInput>
  }

  export type UsersUpsertWithoutUser_RatingsInput = {
    update: XOR<UsersUpdateWithoutUser_RatingsInput, UsersUncheckedUpdateWithoutUser_RatingsInput>
    create: XOR<UsersCreateWithoutUser_RatingsInput, UsersUncheckedCreateWithoutUser_RatingsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUser_RatingsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUser_RatingsInput, UsersUncheckedUpdateWithoutUser_RatingsInput>
  }

  export type UsersUpdateWithoutUser_RatingsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUser_RatingsInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type Subscription_TiersCreateWithoutUsersInput = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon?: string | null
    store_discount?: number
    game_discount?: number
    permissions?: Subscription_TiersCreatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersCreatefeaturesInput | string[]
    userid?: string | null
  }

  export type Subscription_TiersUncheckedCreateWithoutUsersInput = {
    tierid: number
    name: string
    price: number
    votepower: number
    cloudlimit: number
    icon?: string | null
    store_discount?: number
    game_discount?: number
    permissions?: Subscription_TiersCreatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersCreatefeaturesInput | string[]
    userid?: string | null
  }

  export type Subscription_TiersCreateOrConnectWithoutUsersInput = {
    where: Subscription_TiersWhereUniqueInput
    create: XOR<Subscription_TiersCreateWithoutUsersInput, Subscription_TiersUncheckedCreateWithoutUsersInput>
  }

  export type AnimeCreateWithoutUsersInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Videos?: VideosCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutUsersInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutUsersInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput>
  }

  export type AnimeCreateManyUsersInputEnvelope = {
    data: AnimeCreateManyUsersInput | AnimeCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type Anime_AuthorsCreateWithoutUsersInput = {
    Anime: AnimeCreateNestedOneWithoutAnime_AuthorsInput
  }

  export type Anime_AuthorsUncheckedCreateWithoutUsersInput = {
    animeid: string
  }

  export type Anime_AuthorsCreateOrConnectWithoutUsersInput = {
    where: Anime_AuthorsWhereUniqueInput
    create: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput>
  }

  export type Anime_AuthorsCreateManyUsersInputEnvelope = {
    data: Anime_AuthorsCreateManyUsersInput | Anime_AuthorsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type BookmarksCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    Anime: AnimeCreateNestedOneWithoutBookmarksInput
    Manga: MangaCreateNestedOneWithoutBookmarksInput
    Movies: MoviesCreateNestedOneWithoutBookmarksInput
    Videos: VideosCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type BookmarksCreateOrConnectWithoutUsersInput = {
    where: BookmarksWhereUniqueInput
    create: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput>
  }

  export type BookmarksCreateManyUsersInputEnvelope = {
    data: BookmarksCreateManyUsersInput | BookmarksCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    ContentUnit: ContentUnitCreateNestedOneWithoutCommentsInput
    Videos: VideosCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutUsersInput = {
    commentid?: number
    parentid: string
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsCreateOrConnectWithoutUsersInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput>
  }

  export type CommentsCreateManyUsersInputEnvelope = {
    data: CommentsCreateManyUsersInput | CommentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type Disliked_ContentCreateWithoutUsersInput = {
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Disliked_ContentUncheckedCreateWithoutUsersInput = {
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type Disliked_ContentCreateOrConnectWithoutUsersInput = {
    where: Disliked_ContentWhereUniqueInput
    create: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput>
  }

  export type Disliked_ContentCreateManyUsersInputEnvelope = {
    data: Disliked_ContentCreateManyUsersInput | Disliked_ContentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    Folder?: FolderCreateNestedOneWithoutFileInput
    FileShares?: FileSharesCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    folderId?: string | null
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutUsersInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput>
  }

  export type FileCreateManyUsersInputEnvelope = {
    data: FileCreateManyUsersInput | FileCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FileSharesCreateWithoutUsersInput = {
    accessLevel?: $Enums.AccessLevel
    File: FileCreateNestedOneWithoutFileSharesInput
  }

  export type FileSharesUncheckedCreateWithoutUsersInput = {
    fileId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileSharesCreateOrConnectWithoutUsersInput = {
    where: FileSharesWhereUniqueInput
    create: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput>
  }

  export type FileSharesCreateManyUsersInputEnvelope = {
    data: FileSharesCreateManyUsersInput | FileSharesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FolderCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileCreateNestedManyWithoutFolderInput
    Folder?: FolderCreateNestedOneWithoutOther_FolderInput
    other_Folder?: FolderCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
    File?: FileUncheckedCreateNestedManyWithoutFolderInput
    other_Folder?: FolderUncheckedCreateNestedManyWithoutFolderInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutUsersInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput>
  }

  export type FolderCreateManyUsersInputEnvelope = {
    data: FolderCreateManyUsersInput | FolderCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FolderSharesCreateWithoutUsersInput = {
    accessLevel?: $Enums.AccessLevel
    Folder: FolderCreateNestedOneWithoutFolderSharesInput
  }

  export type FolderSharesUncheckedCreateWithoutUsersInput = {
    folderId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FolderSharesCreateOrConnectWithoutUsersInput = {
    where: FolderSharesWhereUniqueInput
    create: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput>
  }

  export type FolderSharesCreateManyUsersInputEnvelope = {
    data: FolderSharesCreateManyUsersInput | FolderSharesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type Liked_ContentCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    contentid: number
  }

  export type Liked_ContentUncheckedCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    contentid: number
  }

  export type Liked_ContentCreateOrConnectWithoutUsersInput = {
    where: Liked_ContentWhereUniqueInput
    create: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput>
  }

  export type Liked_ContentCreateManyUsersInputEnvelope = {
    data: Liked_ContentCreateManyUsersInput | Liked_ContentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MangaCreateWithoutUsersInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksCreateNestedManyWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMangaInput
  }

  export type MangaUncheckedCreateWithoutUsersInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedCreateNestedManyWithoutMangaInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMangaInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMangaInput
  }

  export type MangaCreateOrConnectWithoutUsersInput = {
    where: MangaWhereUniqueInput
    create: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput>
  }

  export type MangaCreateManyUsersInputEnvelope = {
    data: MangaCreateManyUsersInput | MangaCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MoviesCreateWithoutUsersInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksCreateNestedManyWithoutMoviesInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutMoviesInput
  }

  export type MoviesUncheckedCreateWithoutUsersInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutMoviesInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutMoviesInput
  }

  export type MoviesCreateOrConnectWithoutUsersInput = {
    where: MoviesWhereUniqueInput
    create: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput>
  }

  export type MoviesCreateManyUsersInputEnvelope = {
    data: MoviesCreateManyUsersInput | MoviesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PollsCreateWithoutUsersInput = {
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
  }

  export type PollsUncheckedCreateWithoutUsersInput = {
    pollid?: number
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
  }

  export type PollsCreateOrConnectWithoutUsersInput = {
    where: PollsWhereUniqueInput
    create: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput>
  }

  export type PollsCreateManyUsersInputEnvelope = {
    data: PollsCreateManyUsersInput | PollsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ReviewsCreateWithoutUsersInput = {
    parentid: string
    mediatype: $Enums.MediaType
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type ReviewsUncheckedCreateWithoutUsersInput = {
    reviewid?: number
    parentid: string
    mediatype: $Enums.MediaType
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type ReviewsCreateOrConnectWithoutUsersInput = {
    where: ReviewsWhereUniqueInput
    create: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput>
  }

  export type ReviewsCreateManyUsersInputEnvelope = {
    data: ReviewsCreateManyUsersInput | ReviewsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type Shopping_CartCreateWithoutUsersInput = {
    quantity?: number | null
    Store: StoreCreateNestedOneWithoutShopping_CartInput
  }

  export type Shopping_CartUncheckedCreateWithoutUsersInput = {
    storeid: string
    quantity?: number | null
  }

  export type Shopping_CartCreateOrConnectWithoutUsersInput = {
    where: Shopping_CartWhereUniqueInput
    create: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput>
  }

  export type Shopping_CartCreateManyUsersInputEnvelope = {
    data: Shopping_CartCreateManyUsersInput | Shopping_CartCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutUsersInput = {
    storeid?: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutUsersInput = {
    storeid?: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutUsersInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
  }

  export type StoreCreateManyUsersInputEnvelope = {
    data: StoreCreateManyUsersInput | StoreCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type User_ActivityCreateWithoutUsersInput = {
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
  }

  export type User_ActivityUncheckedCreateWithoutUsersInput = {
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
  }

  export type User_ActivityCreateOrConnectWithoutUsersInput = {
    where: User_ActivityWhereUniqueInput
    create: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput>
  }

  export type User_ActivityCreateManyUsersInputEnvelope = {
    data: User_ActivityCreateManyUsersInput | User_ActivityCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type User_BookmarksCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type User_BookmarksUncheckedCreateWithoutUsersInput = {
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type User_BookmarksCreateOrConnectWithoutUsersInput = {
    where: User_BookmarksWhereUniqueInput
    create: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput>
  }

  export type User_BookmarksCreateManyUsersInputEnvelope = {
    data: User_BookmarksCreateManyUsersInput | User_BookmarksCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type User_RatingsCreateWithoutUsersInput = {
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
  }

  export type User_RatingsUncheckedCreateWithoutUsersInput = {
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
  }

  export type User_RatingsCreateOrConnectWithoutUsersInput = {
    where: User_RatingsWhereUniqueInput
    create: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput>
  }

  export type User_RatingsCreateManyUsersInputEnvelope = {
    data: User_RatingsCreateManyUsersInput | User_RatingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type VideosCreateWithoutUsersInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksCreateNestedManyWithoutVideosInput
    Comments?: CommentsCreateNestedManyWithoutVideosInput
  }

  export type VideosUncheckedCreateWithoutUsersInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
    Anime?: AnimeUncheckedCreateNestedManyWithoutVideosInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutVideosInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutVideosInput
  }

  export type VideosCreateOrConnectWithoutUsersInput = {
    where: VideosWhereUniqueInput
    create: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput>
  }

  export type VideosCreateManyUsersInputEnvelope = {
    data: VideosCreateManyUsersInput | VideosCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type Subscription_TiersUpsertWithoutUsersInput = {
    update: XOR<Subscription_TiersUpdateWithoutUsersInput, Subscription_TiersUncheckedUpdateWithoutUsersInput>
    create: XOR<Subscription_TiersCreateWithoutUsersInput, Subscription_TiersUncheckedCreateWithoutUsersInput>
    where?: Subscription_TiersWhereInput
  }

  export type Subscription_TiersUpdateToOneWithWhereWithoutUsersInput = {
    where?: Subscription_TiersWhereInput
    data: XOR<Subscription_TiersUpdateWithoutUsersInput, Subscription_TiersUncheckedUpdateWithoutUsersInput>
  }

  export type Subscription_TiersUpdateWithoutUsersInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Subscription_TiersUncheckedUpdateWithoutUsersInput = {
    tierid?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    votepower?: IntFieldUpdateOperationsInput | number
    cloudlimit?: IntFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    store_discount?: IntFieldUpdateOperationsInput | number
    game_discount?: IntFieldUpdateOperationsInput | number
    permissions?: Subscription_TiersUpdatepermissionsInput | $Enums.navItems[]
    features?: Subscription_TiersUpdatefeaturesInput | string[]
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnimeUpsertWithWhereUniqueWithoutUsersInput = {
    where: AnimeWhereUniqueInput
    update: XOR<AnimeUpdateWithoutUsersInput, AnimeUncheckedUpdateWithoutUsersInput>
    create: XOR<AnimeCreateWithoutUsersInput, AnimeUncheckedCreateWithoutUsersInput>
  }

  export type AnimeUpdateWithWhereUniqueWithoutUsersInput = {
    where: AnimeWhereUniqueInput
    data: XOR<AnimeUpdateWithoutUsersInput, AnimeUncheckedUpdateWithoutUsersInput>
  }

  export type AnimeUpdateManyWithWhereWithoutUsersInput = {
    where: AnimeScalarWhereInput
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyWithoutUsersInput>
  }

  export type Anime_AuthorsUpsertWithWhereUniqueWithoutUsersInput = {
    where: Anime_AuthorsWhereUniqueInput
    update: XOR<Anime_AuthorsUpdateWithoutUsersInput, Anime_AuthorsUncheckedUpdateWithoutUsersInput>
    create: XOR<Anime_AuthorsCreateWithoutUsersInput, Anime_AuthorsUncheckedCreateWithoutUsersInput>
  }

  export type Anime_AuthorsUpdateWithWhereUniqueWithoutUsersInput = {
    where: Anime_AuthorsWhereUniqueInput
    data: XOR<Anime_AuthorsUpdateWithoutUsersInput, Anime_AuthorsUncheckedUpdateWithoutUsersInput>
  }

  export type Anime_AuthorsUpdateManyWithWhereWithoutUsersInput = {
    where: Anime_AuthorsScalarWhereInput
    data: XOR<Anime_AuthorsUpdateManyMutationInput, Anime_AuthorsUncheckedUpdateManyWithoutUsersInput>
  }

  export type BookmarksUpsertWithWhereUniqueWithoutUsersInput = {
    where: BookmarksWhereUniqueInput
    update: XOR<BookmarksUpdateWithoutUsersInput, BookmarksUncheckedUpdateWithoutUsersInput>
    create: XOR<BookmarksCreateWithoutUsersInput, BookmarksUncheckedCreateWithoutUsersInput>
  }

  export type BookmarksUpdateWithWhereUniqueWithoutUsersInput = {
    where: BookmarksWhereUniqueInput
    data: XOR<BookmarksUpdateWithoutUsersInput, BookmarksUncheckedUpdateWithoutUsersInput>
  }

  export type BookmarksUpdateManyWithWhereWithoutUsersInput = {
    where: BookmarksScalarWhereInput
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyWithoutUsersInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutUsersInput, CommentsUncheckedUpdateWithoutUsersInput>
    create: XOR<CommentsCreateWithoutUsersInput, CommentsUncheckedCreateWithoutUsersInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutUsersInput, CommentsUncheckedUpdateWithoutUsersInput>
  }

  export type CommentsUpdateManyWithWhereWithoutUsersInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type Disliked_ContentUpsertWithWhereUniqueWithoutUsersInput = {
    where: Disliked_ContentWhereUniqueInput
    update: XOR<Disliked_ContentUpdateWithoutUsersInput, Disliked_ContentUncheckedUpdateWithoutUsersInput>
    create: XOR<Disliked_ContentCreateWithoutUsersInput, Disliked_ContentUncheckedCreateWithoutUsersInput>
  }

  export type Disliked_ContentUpdateWithWhereUniqueWithoutUsersInput = {
    where: Disliked_ContentWhereUniqueInput
    data: XOR<Disliked_ContentUpdateWithoutUsersInput, Disliked_ContentUncheckedUpdateWithoutUsersInput>
  }

  export type Disliked_ContentUpdateManyWithWhereWithoutUsersInput = {
    where: Disliked_ContentScalarWhereInput
    data: XOR<Disliked_ContentUpdateManyMutationInput, Disliked_ContentUncheckedUpdateManyWithoutUsersInput>
  }

  export type Disliked_ContentScalarWhereInput = {
    AND?: Disliked_ContentScalarWhereInput | Disliked_ContentScalarWhereInput[]
    OR?: Disliked_ContentScalarWhereInput[]
    NOT?: Disliked_ContentScalarWhereInput | Disliked_ContentScalarWhereInput[]
    userid?: StringFilter<"Disliked_Content"> | string
    contentid?: IntFilter<"Disliked_Content"> | number
    mediatype?: EnumMediaTypeFilter<"Disliked_Content"> | $Enums.MediaType
  }

  export type FileUpsertWithWhereUniqueWithoutUsersInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUsersInput, FileUncheckedUpdateWithoutUsersInput>
    create: XOR<FileCreateWithoutUsersInput, FileUncheckedCreateWithoutUsersInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUsersInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUsersInput, FileUncheckedUpdateWithoutUsersInput>
  }

  export type FileUpdateManyWithWhereWithoutUsersInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUsersInput>
  }

  export type FileSharesUpsertWithWhereUniqueWithoutUsersInput = {
    where: FileSharesWhereUniqueInput
    update: XOR<FileSharesUpdateWithoutUsersInput, FileSharesUncheckedUpdateWithoutUsersInput>
    create: XOR<FileSharesCreateWithoutUsersInput, FileSharesUncheckedCreateWithoutUsersInput>
  }

  export type FileSharesUpdateWithWhereUniqueWithoutUsersInput = {
    where: FileSharesWhereUniqueInput
    data: XOR<FileSharesUpdateWithoutUsersInput, FileSharesUncheckedUpdateWithoutUsersInput>
  }

  export type FileSharesUpdateManyWithWhereWithoutUsersInput = {
    where: FileSharesScalarWhereInput
    data: XOR<FileSharesUpdateManyMutationInput, FileSharesUncheckedUpdateManyWithoutUsersInput>
  }

  export type FolderUpsertWithWhereUniqueWithoutUsersInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutUsersInput, FolderUncheckedUpdateWithoutUsersInput>
    create: XOR<FolderCreateWithoutUsersInput, FolderUncheckedCreateWithoutUsersInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutUsersInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutUsersInput, FolderUncheckedUpdateWithoutUsersInput>
  }

  export type FolderUpdateManyWithWhereWithoutUsersInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutUsersInput>
  }

  export type FolderSharesUpsertWithWhereUniqueWithoutUsersInput = {
    where: FolderSharesWhereUniqueInput
    update: XOR<FolderSharesUpdateWithoutUsersInput, FolderSharesUncheckedUpdateWithoutUsersInput>
    create: XOR<FolderSharesCreateWithoutUsersInput, FolderSharesUncheckedCreateWithoutUsersInput>
  }

  export type FolderSharesUpdateWithWhereUniqueWithoutUsersInput = {
    where: FolderSharesWhereUniqueInput
    data: XOR<FolderSharesUpdateWithoutUsersInput, FolderSharesUncheckedUpdateWithoutUsersInput>
  }

  export type FolderSharesUpdateManyWithWhereWithoutUsersInput = {
    where: FolderSharesScalarWhereInput
    data: XOR<FolderSharesUpdateManyMutationInput, FolderSharesUncheckedUpdateManyWithoutUsersInput>
  }

  export type Liked_ContentUpsertWithWhereUniqueWithoutUsersInput = {
    where: Liked_ContentWhereUniqueInput
    update: XOR<Liked_ContentUpdateWithoutUsersInput, Liked_ContentUncheckedUpdateWithoutUsersInput>
    create: XOR<Liked_ContentCreateWithoutUsersInput, Liked_ContentUncheckedCreateWithoutUsersInput>
  }

  export type Liked_ContentUpdateWithWhereUniqueWithoutUsersInput = {
    where: Liked_ContentWhereUniqueInput
    data: XOR<Liked_ContentUpdateWithoutUsersInput, Liked_ContentUncheckedUpdateWithoutUsersInput>
  }

  export type Liked_ContentUpdateManyWithWhereWithoutUsersInput = {
    where: Liked_ContentScalarWhereInput
    data: XOR<Liked_ContentUpdateManyMutationInput, Liked_ContentUncheckedUpdateManyWithoutUsersInput>
  }

  export type Liked_ContentScalarWhereInput = {
    AND?: Liked_ContentScalarWhereInput | Liked_ContentScalarWhereInput[]
    OR?: Liked_ContentScalarWhereInput[]
    NOT?: Liked_ContentScalarWhereInput | Liked_ContentScalarWhereInput[]
    userid?: StringFilter<"Liked_Content"> | string
    mediatype?: EnumMediaTypeFilter<"Liked_Content"> | $Enums.MediaType
    contentid?: IntFilter<"Liked_Content"> | number
  }

  export type MangaUpsertWithWhereUniqueWithoutUsersInput = {
    where: MangaWhereUniqueInput
    update: XOR<MangaUpdateWithoutUsersInput, MangaUncheckedUpdateWithoutUsersInput>
    create: XOR<MangaCreateWithoutUsersInput, MangaUncheckedCreateWithoutUsersInput>
  }

  export type MangaUpdateWithWhereUniqueWithoutUsersInput = {
    where: MangaWhereUniqueInput
    data: XOR<MangaUpdateWithoutUsersInput, MangaUncheckedUpdateWithoutUsersInput>
  }

  export type MangaUpdateManyWithWhereWithoutUsersInput = {
    where: MangaScalarWhereInput
    data: XOR<MangaUpdateManyMutationInput, MangaUncheckedUpdateManyWithoutUsersInput>
  }

  export type MangaScalarWhereInput = {
    AND?: MangaScalarWhereInput | MangaScalarWhereInput[]
    OR?: MangaScalarWhereInput[]
    NOT?: MangaScalarWhereInput | MangaScalarWhereInput[]
    mangaid?: StringFilter<"Manga"> | string
    authorid?: StringFilter<"Manga"> | string
    title?: StringFilter<"Manga"> | string
    description?: StringNullableFilter<"Manga"> | string | null
    release_date?: DateTimeNullableFilter<"Manga"> | Date | string | null
    cover_iamge?: StringNullableFilter<"Manga"> | string | null
    likes?: BigIntFilter<"Manga"> | bigint | number
    dislikes?: BigIntFilter<"Manga"> | bigint | number
    age_rating?: EnumAgeRatingFilter<"Manga"> | $Enums.AgeRating
    MediaGenre?: EnumMediaGenreNullableListFilter<"Manga">
  }

  export type MoviesUpsertWithWhereUniqueWithoutUsersInput = {
    where: MoviesWhereUniqueInput
    update: XOR<MoviesUpdateWithoutUsersInput, MoviesUncheckedUpdateWithoutUsersInput>
    create: XOR<MoviesCreateWithoutUsersInput, MoviesUncheckedCreateWithoutUsersInput>
  }

  export type MoviesUpdateWithWhereUniqueWithoutUsersInput = {
    where: MoviesWhereUniqueInput
    data: XOR<MoviesUpdateWithoutUsersInput, MoviesUncheckedUpdateWithoutUsersInput>
  }

  export type MoviesUpdateManyWithWhereWithoutUsersInput = {
    where: MoviesScalarWhereInput
    data: XOR<MoviesUpdateManyMutationInput, MoviesUncheckedUpdateManyWithoutUsersInput>
  }

  export type MoviesScalarWhereInput = {
    AND?: MoviesScalarWhereInput | MoviesScalarWhereInput[]
    OR?: MoviesScalarWhereInput[]
    NOT?: MoviesScalarWhereInput | MoviesScalarWhereInput[]
    movieid?: StringFilter<"Movies"> | string
    title?: StringFilter<"Movies"> | string
    description?: StringNullableFilter<"Movies"> | string | null
    release_date?: DateTimeNullableFilter<"Movies"> | Date | string | null
    media_id_reference?: IntNullableFilter<"Movies"> | number | null
    likes?: BigIntFilter<"Movies"> | bigint | number
    dislikes?: BigIntFilter<"Movies"> | bigint | number
    showbanner?: StringNullableFilter<"Movies"> | string | null
    age_rating?: EnumAgeRatingFilter<"Movies"> | $Enums.AgeRating
    authorid?: StringFilter<"Movies"> | string
    media_reference_type?: EnumMediaTypeFilter<"Movies"> | $Enums.MediaType
    MediaGenre?: EnumMediaGenreNullableListFilter<"Movies">
  }

  export type PollsUpsertWithWhereUniqueWithoutUsersInput = {
    where: PollsWhereUniqueInput
    update: XOR<PollsUpdateWithoutUsersInput, PollsUncheckedUpdateWithoutUsersInput>
    create: XOR<PollsCreateWithoutUsersInput, PollsUncheckedCreateWithoutUsersInput>
  }

  export type PollsUpdateWithWhereUniqueWithoutUsersInput = {
    where: PollsWhereUniqueInput
    data: XOR<PollsUpdateWithoutUsersInput, PollsUncheckedUpdateWithoutUsersInput>
  }

  export type PollsUpdateManyWithWhereWithoutUsersInput = {
    where: PollsScalarWhereInput
    data: XOR<PollsUpdateManyMutationInput, PollsUncheckedUpdateManyWithoutUsersInput>
  }

  export type PollsScalarWhereInput = {
    AND?: PollsScalarWhereInput | PollsScalarWhereInput[]
    OR?: PollsScalarWhereInput[]
    NOT?: PollsScalarWhereInput | PollsScalarWhereInput[]
    pollid?: IntFilter<"Polls"> | number
    author?: StringFilter<"Polls"> | string
    title?: StringFilter<"Polls"> | string
    description?: StringFilter<"Polls"> | string
    likes?: BigIntFilter<"Polls"> | bigint | number
    dislikes?: BigIntFilter<"Polls"> | bigint | number
    date?: DateTimeNullableFilter<"Polls"> | Date | string | null
    category?: StringFilter<"Polls"> | string
    status?: StringFilter<"Polls"> | string
    progress?: StringNullableFilter<"Polls"> | string | null
    views?: IntFilter<"Polls"> | number
  }

  export type ReviewsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ReviewsWhereUniqueInput
    update: XOR<ReviewsUpdateWithoutUsersInput, ReviewsUncheckedUpdateWithoutUsersInput>
    create: XOR<ReviewsCreateWithoutUsersInput, ReviewsUncheckedCreateWithoutUsersInput>
  }

  export type ReviewsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ReviewsWhereUniqueInput
    data: XOR<ReviewsUpdateWithoutUsersInput, ReviewsUncheckedUpdateWithoutUsersInput>
  }

  export type ReviewsUpdateManyWithWhereWithoutUsersInput = {
    where: ReviewsScalarWhereInput
    data: XOR<ReviewsUpdateManyMutationInput, ReviewsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ReviewsScalarWhereInput = {
    AND?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    OR?: ReviewsScalarWhereInput[]
    NOT?: ReviewsScalarWhereInput | ReviewsScalarWhereInput[]
    reviewid?: IntFilter<"Reviews"> | number
    parentid?: StringFilter<"Reviews"> | string
    mediatype?: EnumMediaTypeFilter<"Reviews"> | $Enums.MediaType
    userid?: StringFilter<"Reviews"> | string
    review_text?: StringFilter<"Reviews"> | string
    review_date?: DateTimeFilter<"Reviews"> | Date | string
    likes?: BigIntFilter<"Reviews"> | bigint | number
    dislikes?: BigIntFilter<"Reviews"> | bigint | number
  }

  export type Shopping_CartUpsertWithWhereUniqueWithoutUsersInput = {
    where: Shopping_CartWhereUniqueInput
    update: XOR<Shopping_CartUpdateWithoutUsersInput, Shopping_CartUncheckedUpdateWithoutUsersInput>
    create: XOR<Shopping_CartCreateWithoutUsersInput, Shopping_CartUncheckedCreateWithoutUsersInput>
  }

  export type Shopping_CartUpdateWithWhereUniqueWithoutUsersInput = {
    where: Shopping_CartWhereUniqueInput
    data: XOR<Shopping_CartUpdateWithoutUsersInput, Shopping_CartUncheckedUpdateWithoutUsersInput>
  }

  export type Shopping_CartUpdateManyWithWhereWithoutUsersInput = {
    where: Shopping_CartScalarWhereInput
    data: XOR<Shopping_CartUpdateManyMutationInput, Shopping_CartUncheckedUpdateManyWithoutUsersInput>
  }

  export type StoreUpsertWithWhereUniqueWithoutUsersInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutUsersInput, StoreUncheckedUpdateWithoutUsersInput>
    create: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutUsersInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutUsersInput, StoreUncheckedUpdateWithoutUsersInput>
  }

  export type StoreUpdateManyWithWhereWithoutUsersInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutUsersInput>
  }

  export type StoreScalarWhereInput = {
    AND?: StoreScalarWhereInput | StoreScalarWhereInput[]
    OR?: StoreScalarWhereInput[]
    NOT?: StoreScalarWhereInput | StoreScalarWhereInput[]
    storeid?: StringFilter<"Store"> | string
    sellerid?: StringFilter<"Store"> | string
    title?: StringFilter<"Store"> | string
    num_in_stock?: IntFilter<"Store"> | number
    release_date?: DateTimeNullableFilter<"Store"> | Date | string | null
    original_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFilter<"Store"> | number
    shipping_price?: DecimalFilter<"Store"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"Store"> | string
    num_of_carts?: IntFilter<"Store"> | number
    images?: StringNullableFilter<"Store"> | string | null
    media_id_reference?: IntNullableFilter<"Store"> | number | null
    sales?: IntFilter<"Store"> | number
    reference_media_type?: StringNullableFilter<"Store"> | string | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Store">
  }

  export type User_ActivityUpsertWithWhereUniqueWithoutUsersInput = {
    where: User_ActivityWhereUniqueInput
    update: XOR<User_ActivityUpdateWithoutUsersInput, User_ActivityUncheckedUpdateWithoutUsersInput>
    create: XOR<User_ActivityCreateWithoutUsersInput, User_ActivityUncheckedCreateWithoutUsersInput>
  }

  export type User_ActivityUpdateWithWhereUniqueWithoutUsersInput = {
    where: User_ActivityWhereUniqueInput
    data: XOR<User_ActivityUpdateWithoutUsersInput, User_ActivityUncheckedUpdateWithoutUsersInput>
  }

  export type User_ActivityUpdateManyWithWhereWithoutUsersInput = {
    where: User_ActivityScalarWhereInput
    data: XOR<User_ActivityUpdateManyMutationInput, User_ActivityUncheckedUpdateManyWithoutUsersInput>
  }

  export type User_ActivityScalarWhereInput = {
    AND?: User_ActivityScalarWhereInput | User_ActivityScalarWhereInput[]
    OR?: User_ActivityScalarWhereInput[]
    NOT?: User_ActivityScalarWhereInput | User_ActivityScalarWhereInput[]
    userid?: StringFilter<"User_Activity"> | string
    child_content?: StringFilter<"User_Activity"> | string
    parent_content?: StringFilter<"User_Activity"> | string
    mediatype?: EnumMediaTypeFilter<"User_Activity"> | $Enums.MediaType
    stopping_point?: IntFilter<"User_Activity"> | number
    date_watched?: DateTimeFilter<"User_Activity"> | Date | string
  }

  export type User_BookmarksUpsertWithWhereUniqueWithoutUsersInput = {
    where: User_BookmarksWhereUniqueInput
    update: XOR<User_BookmarksUpdateWithoutUsersInput, User_BookmarksUncheckedUpdateWithoutUsersInput>
    create: XOR<User_BookmarksCreateWithoutUsersInput, User_BookmarksUncheckedCreateWithoutUsersInput>
  }

  export type User_BookmarksUpdateWithWhereUniqueWithoutUsersInput = {
    where: User_BookmarksWhereUniqueInput
    data: XOR<User_BookmarksUpdateWithoutUsersInput, User_BookmarksUncheckedUpdateWithoutUsersInput>
  }

  export type User_BookmarksUpdateManyWithWhereWithoutUsersInput = {
    where: User_BookmarksScalarWhereInput
    data: XOR<User_BookmarksUpdateManyMutationInput, User_BookmarksUncheckedUpdateManyWithoutUsersInput>
  }

  export type User_BookmarksScalarWhereInput = {
    AND?: User_BookmarksScalarWhereInput | User_BookmarksScalarWhereInput[]
    OR?: User_BookmarksScalarWhereInput[]
    NOT?: User_BookmarksScalarWhereInput | User_BookmarksScalarWhereInput[]
    userid?: StringFilter<"User_Bookmarks"> | string
    mediatype?: EnumMediaTypeFilter<"User_Bookmarks"> | $Enums.MediaType
    parentid?: StringFilter<"User_Bookmarks"> | string
  }

  export type User_RatingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: User_RatingsWhereUniqueInput
    update: XOR<User_RatingsUpdateWithoutUsersInput, User_RatingsUncheckedUpdateWithoutUsersInput>
    create: XOR<User_RatingsCreateWithoutUsersInput, User_RatingsUncheckedCreateWithoutUsersInput>
  }

  export type User_RatingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: User_RatingsWhereUniqueInput
    data: XOR<User_RatingsUpdateWithoutUsersInput, User_RatingsUncheckedUpdateWithoutUsersInput>
  }

  export type User_RatingsUpdateManyWithWhereWithoutUsersInput = {
    where: User_RatingsScalarWhereInput
    data: XOR<User_RatingsUpdateManyMutationInput, User_RatingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type User_RatingsScalarWhereInput = {
    AND?: User_RatingsScalarWhereInput | User_RatingsScalarWhereInput[]
    OR?: User_RatingsScalarWhereInput[]
    NOT?: User_RatingsScalarWhereInput | User_RatingsScalarWhereInput[]
    userid?: StringFilter<"User_Ratings"> | string
    parentid?: StringFilter<"User_Ratings"> | string
    mediatype?: EnumMediaTypeFilter<"User_Ratings"> | $Enums.MediaType
    rating?: IntFilter<"User_Ratings"> | number
  }

  export type VideosUpsertWithWhereUniqueWithoutUsersInput = {
    where: VideosWhereUniqueInput
    update: XOR<VideosUpdateWithoutUsersInput, VideosUncheckedUpdateWithoutUsersInput>
    create: XOR<VideosCreateWithoutUsersInput, VideosUncheckedCreateWithoutUsersInput>
  }

  export type VideosUpdateWithWhereUniqueWithoutUsersInput = {
    where: VideosWhereUniqueInput
    data: XOR<VideosUpdateWithoutUsersInput, VideosUncheckedUpdateWithoutUsersInput>
  }

  export type VideosUpdateManyWithWhereWithoutUsersInput = {
    where: VideosScalarWhereInput
    data: XOR<VideosUpdateManyMutationInput, VideosUncheckedUpdateManyWithoutUsersInput>
  }

  export type VideosScalarWhereInput = {
    AND?: VideosScalarWhereInput | VideosScalarWhereInput[]
    OR?: VideosScalarWhereInput[]
    NOT?: VideosScalarWhereInput | VideosScalarWhereInput[]
    videoid?: StringFilter<"Videos"> | string
    title?: StringFilter<"Videos"> | string
    authorid?: StringFilter<"Videos"> | string
    description?: StringFilter<"Videos"> | string
    release_date?: DateTimeNullableFilter<"Videos"> | Date | string | null
    media_type?: EnumMediaTypeFilter<"Videos"> | $Enums.MediaType
    video_banner?: StringFilter<"Videos"> | string
    likes?: BigIntFilter<"Videos"> | bigint | number
    dislikes?: BigIntFilter<"Videos"> | bigint | number
    duration?: BigIntNullableFilter<"Videos"> | bigint | number | null
    MediaGenre?: EnumMediaGenreNullableListFilter<"Videos">
    thumbnail?: StringFilter<"Videos"> | string
    views?: IntFilter<"Videos"> | number
  }

  export type AnimeCreateWithoutVideosInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Manga?: MangaCreateNestedOneWithoutAnimeInput
    Users: UsersCreateNestedOneWithoutAnimeInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutVideosInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutAnimeInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutAnimeInput
    ContentGroupLinks?: ContentGroupMediaUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutVideosInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
  }

  export type AnimeCreateManyVideosInputEnvelope = {
    data: AnimeCreateManyVideosInput | AnimeCreateManyVideosInput[]
    skipDuplicates?: boolean
  }

  export type BookmarksCreateWithoutVideosInput = {
    mediatype: $Enums.MediaType
    Anime: AnimeCreateNestedOneWithoutBookmarksInput
    Manga: MangaCreateNestedOneWithoutBookmarksInput
    Movies: MoviesCreateNestedOneWithoutBookmarksInput
    Users: UsersCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarksUncheckedCreateWithoutVideosInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksCreateOrConnectWithoutVideosInput = {
    where: BookmarksWhereUniqueInput
    create: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput>
  }

  export type BookmarksCreateManyVideosInputEnvelope = {
    data: BookmarksCreateManyVideosInput | BookmarksCreateManyVideosInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutVideosInput = {
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    ContentUnit: ContentUnitCreateNestedOneWithoutCommentsInput
    Users: UsersCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutVideosInput = {
    commentid?: number
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsCreateOrConnectWithoutVideosInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput>
  }

  export type CommentsCreateManyVideosInputEnvelope = {
    data: CommentsCreateManyVideosInput | CommentsCreateManyVideosInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutVideosInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    subscription_tier?: Subscription_TiersCreateNestedOneWithoutUsersInput
    Anime?: AnimeCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksCreateNestedManyWithoutUsersInput
    Comments?: CommentsCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentCreateNestedManyWithoutUsersInput
    File?: FileCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesCreateNestedManyWithoutUsersInput
    Folder?: FolderCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentCreateNestedManyWithoutUsersInput
    Manga?: MangaCreateNestedManyWithoutUsersInput
    Movies?: MoviesCreateNestedManyWithoutUsersInput
    Polls?: PollsCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartCreateNestedManyWithoutUsersInput
    Store?: StoreCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutVideosInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    subscriptionTierId?: number | null
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
    Anime?: AnimeUncheckedCreateNestedManyWithoutUsersInput
    Anime_Authors?: Anime_AuthorsUncheckedCreateNestedManyWithoutUsersInput
    Bookmarks?: BookmarksUncheckedCreateNestedManyWithoutUsersInput
    Comments?: CommentsUncheckedCreateNestedManyWithoutUsersInput
    Disliked_Content?: Disliked_ContentUncheckedCreateNestedManyWithoutUsersInput
    File?: FileUncheckedCreateNestedManyWithoutUsersInput
    FileShares?: FileSharesUncheckedCreateNestedManyWithoutUsersInput
    Folder?: FolderUncheckedCreateNestedManyWithoutUsersInput
    FolderShares?: FolderSharesUncheckedCreateNestedManyWithoutUsersInput
    Liked_Content?: Liked_ContentUncheckedCreateNestedManyWithoutUsersInput
    Manga?: MangaUncheckedCreateNestedManyWithoutUsersInput
    Movies?: MoviesUncheckedCreateNestedManyWithoutUsersInput
    Polls?: PollsUncheckedCreateNestedManyWithoutUsersInput
    Reviews?: ReviewsUncheckedCreateNestedManyWithoutUsersInput
    Shopping_Cart?: Shopping_CartUncheckedCreateNestedManyWithoutUsersInput
    Store?: StoreUncheckedCreateNestedManyWithoutUsersInput
    User_Activity?: User_ActivityUncheckedCreateNestedManyWithoutUsersInput
    User_Bookmarks?: User_BookmarksUncheckedCreateNestedManyWithoutUsersInput
    User_Ratings?: User_RatingsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutVideosInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutVideosInput, UsersUncheckedCreateWithoutVideosInput>
  }

  export type AnimeUpsertWithWhereUniqueWithoutVideosInput = {
    where: AnimeWhereUniqueInput
    update: XOR<AnimeUpdateWithoutVideosInput, AnimeUncheckedUpdateWithoutVideosInput>
    create: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
  }

  export type AnimeUpdateWithWhereUniqueWithoutVideosInput = {
    where: AnimeWhereUniqueInput
    data: XOR<AnimeUpdateWithoutVideosInput, AnimeUncheckedUpdateWithoutVideosInput>
  }

  export type AnimeUpdateManyWithWhereWithoutVideosInput = {
    where: AnimeScalarWhereInput
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyWithoutVideosInput>
  }

  export type BookmarksUpsertWithWhereUniqueWithoutVideosInput = {
    where: BookmarksWhereUniqueInput
    update: XOR<BookmarksUpdateWithoutVideosInput, BookmarksUncheckedUpdateWithoutVideosInput>
    create: XOR<BookmarksCreateWithoutVideosInput, BookmarksUncheckedCreateWithoutVideosInput>
  }

  export type BookmarksUpdateWithWhereUniqueWithoutVideosInput = {
    where: BookmarksWhereUniqueInput
    data: XOR<BookmarksUpdateWithoutVideosInput, BookmarksUncheckedUpdateWithoutVideosInput>
  }

  export type BookmarksUpdateManyWithWhereWithoutVideosInput = {
    where: BookmarksScalarWhereInput
    data: XOR<BookmarksUpdateManyMutationInput, BookmarksUncheckedUpdateManyWithoutVideosInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutVideosInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutVideosInput, CommentsUncheckedUpdateWithoutVideosInput>
    create: XOR<CommentsCreateWithoutVideosInput, CommentsUncheckedCreateWithoutVideosInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutVideosInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutVideosInput, CommentsUncheckedUpdateWithoutVideosInput>
  }

  export type CommentsUpdateManyWithWhereWithoutVideosInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutVideosInput>
  }

  export type UsersUpsertWithoutVideosInput = {
    update: XOR<UsersUpdateWithoutVideosInput, UsersUncheckedUpdateWithoutVideosInput>
    create: XOR<UsersCreateWithoutVideosInput, UsersUncheckedCreateWithoutVideosInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutVideosInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutVideosInput, UsersUncheckedUpdateWithoutVideosInput>
  }

  export type UsersUpdateWithoutVideosInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    subscription_tier?: Subscription_TiersUpdateOneWithoutUsersNestedInput
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutVideosInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    subscriptionTierId?: NullableIntFieldUpdateOperationsInput | number | null
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type Anime_AuthorsCreateManyAnimeInput = {
    authorid: string
  }

  export type BookmarksCreateManyAnimeInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaCreateManyAnimeInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
  }

  export type Anime_AuthorsUpdateWithoutAnimeInput = {
    Users?: UsersUpdateOneRequiredWithoutAnime_AuthorsNestedInput
  }

  export type Anime_AuthorsUncheckedUpdateWithoutAnimeInput = {
    authorid?: StringFieldUpdateOperationsInput | string
  }

  export type Anime_AuthorsUncheckedUpdateManyWithoutAnimeInput = {
    authorid?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarksUpdateWithoutAnimeInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Manga?: MangaUpdateOneRequiredWithoutBookmarksNestedInput
    Movies?: MoviesUpdateOneRequiredWithoutBookmarksNestedInput
    Videos?: VideosUpdateOneRequiredWithoutBookmarksNestedInput
    Users?: UsersUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateWithoutAnimeInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksUncheckedUpdateManyWithoutAnimeInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentGroupMediaUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Manga?: MangaUpdateOneWithoutContentGroupLinksNestedInput
    Movies?: MoviesUpdateOneWithoutContentGroupLinksNestedInput
    ContentGroup?: ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput
    ContentUnits?: ContentUnitUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentGroupMediaCreateManyContentGroupInput = {
    id?: string
    mediaid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaUpdateWithoutContentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneWithoutContentGroupLinksNestedInput
    Manga?: MangaUpdateOneWithoutContentGroupLinksNestedInput
    Movies?: MoviesUpdateOneWithoutContentGroupLinksNestedInput
    ContentUnits?: ContentUnitUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateWithoutContentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutContentGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentUnitCreateManyContentGroupMediaInput = {
    episodeid?: string
    title?: string
    description?: string
    release_date?: Date | string | null
    likes?: bigint | number
    dislikes?: bigint | number
    visible?: boolean
    episode_number: number
    views?: number
    duration: number
    episode_path?: string
    thumbnail?: string
  }

  export type ContentUnitUpdateWithoutContentGroupMediaInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUpdateManyWithoutContentUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateWithoutContentGroupMediaInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    Comments?: CommentsUncheckedUpdateManyWithoutContentUnitNestedInput
  }

  export type ContentUnitUncheckedUpdateManyWithoutContentGroupMediaInput = {
    episodeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    visible?: BoolFieldUpdateOperationsInput | boolean
    episode_number?: FloatFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    episode_path?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsCreateManyContentUnitInput = {
    commentid?: number
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type CommentsUpdateWithoutContentUnitInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    Videos?: VideosUpdateOneRequiredWithoutCommentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateWithoutContentUnitInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommentsUncheckedUpdateManyWithoutContentUnitInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type FileSharesCreateManyFileInput = {
    userId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileSharesUpdateWithoutFileInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    Users?: UsersUpdateOneRequiredWithoutFileSharesNestedInput
  }

  export type FileSharesUncheckedUpdateWithoutFileInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FileSharesUncheckedUpdateManyWithoutFileInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FileCreateManyFolderInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    ownerId: string
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FolderCreateManyFolderInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FolderSharesCreateManyFolderInput = {
    userId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FileUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Users?: UsersUpdateOneRequiredWithoutFileNestedInput
    FileShares?: FileSharesUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    FileShares?: FileSharesUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: StringFieldUpdateOperationsInput | string
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FolderUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUpdateManyWithoutFolderNestedInput
    Users?: UsersUpdateOneRequiredWithoutFolderNestedInput
    other_Folder?: FolderUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUncheckedUpdateManyWithoutFolderNestedInput
    other_Folder?: FolderUncheckedUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FolderSharesUpdateWithoutFolderInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    Users?: UsersUpdateOneRequiredWithoutFolderSharesNestedInput
  }

  export type FolderSharesUncheckedUpdateWithoutFolderInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderSharesUncheckedUpdateManyWithoutFolderInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type AnimeCreateManyMangaInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
  }

  export type BookmarksCreateManyMangaInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaCreateManyMangaInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
  }

  export type AnimeUpdateWithoutMangaInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutMangaInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateManyWithoutMangaInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookmarksUpdateWithoutMangaInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneRequiredWithoutBookmarksNestedInput
    Movies?: MoviesUpdateOneRequiredWithoutBookmarksNestedInput
    Videos?: VideosUpdateOneRequiredWithoutBookmarksNestedInput
    Users?: UsersUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateWithoutMangaInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksUncheckedUpdateManyWithoutMangaInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentGroupMediaUpdateWithoutMangaInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneWithoutContentGroupLinksNestedInput
    Movies?: MoviesUpdateOneWithoutContentGroupLinksNestedInput
    ContentGroup?: ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput
    ContentUnits?: ContentUnitUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateWithoutMangaInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutMangaInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksCreateManyMoviesInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type ContentGroupMediaCreateManyMoviesInput = {
    id?: string
    seasonid: string
    mediatype: $Enums.MediaType
  }

  export type BookmarksUpdateWithoutMoviesInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneRequiredWithoutBookmarksNestedInput
    Manga?: MangaUpdateOneRequiredWithoutBookmarksNestedInput
    Videos?: VideosUpdateOneRequiredWithoutBookmarksNestedInput
    Users?: UsersUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateWithoutMoviesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksUncheckedUpdateManyWithoutMoviesInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type ContentGroupMediaUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneWithoutContentGroupLinksNestedInput
    Manga?: MangaUpdateOneWithoutContentGroupLinksNestedInput
    ContentGroup?: ContentGroupUpdateOneRequiredWithoutContentGroupLinksNestedInput
    ContentUnits?: ContentUnitUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    ContentUnits?: ContentUnitUncheckedUpdateManyWithoutContentGroupMediaNestedInput
  }

  export type ContentGroupMediaUncheckedUpdateManyWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type Shopping_CartCreateManyStoreInput = {
    userid: string
    quantity?: number | null
  }

  export type Shopping_CartUpdateWithoutStoreInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutShopping_CartNestedInput
  }

  export type Shopping_CartUncheckedUpdateWithoutStoreInput = {
    userid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Shopping_CartUncheckedUpdateManyWithoutStoreInput = {
    userid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsersCreateManySubscription_tierInput = {
    userid?: string
    username: string
    email: string
    password_hash: string
    date_joined?: Date | string
    num_of_friends?: number | null
    num_of_followers?: number | null
    profile_picture?: string | null
    user_bio?: string | null
    two_factor?: boolean
    email_notifications?: boolean
    push_notifications?: boolean
    usedstorage?: bigint | number
    accountType?: $Enums.AccountType
  }

  export type UsersUpdateWithoutSubscription_tierInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUpdateManyWithoutUsersNestedInput
    File?: FileUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUpdateManyWithoutUsersNestedInput
    Folder?: FolderUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUpdateManyWithoutUsersNestedInput
    Manga?: MangaUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUpdateManyWithoutUsersNestedInput
    Polls?: PollsUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUpdateManyWithoutUsersNestedInput
    Store?: StoreUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUpdateManyWithoutUsersNestedInput
    Videos?: VideosUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutSubscription_tierInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    Anime?: AnimeUncheckedUpdateManyWithoutUsersNestedInput
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutUsersNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutUsersNestedInput
    Disliked_Content?: Disliked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    File?: FileUncheckedUpdateManyWithoutUsersNestedInput
    FileShares?: FileSharesUncheckedUpdateManyWithoutUsersNestedInput
    Folder?: FolderUncheckedUpdateManyWithoutUsersNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutUsersNestedInput
    Liked_Content?: Liked_ContentUncheckedUpdateManyWithoutUsersNestedInput
    Manga?: MangaUncheckedUpdateManyWithoutUsersNestedInput
    Movies?: MoviesUncheckedUpdateManyWithoutUsersNestedInput
    Polls?: PollsUncheckedUpdateManyWithoutUsersNestedInput
    Reviews?: ReviewsUncheckedUpdateManyWithoutUsersNestedInput
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutUsersNestedInput
    Store?: StoreUncheckedUpdateManyWithoutUsersNestedInput
    User_Activity?: User_ActivityUncheckedUpdateManyWithoutUsersNestedInput
    User_Bookmarks?: User_BookmarksUncheckedUpdateManyWithoutUsersNestedInput
    User_Ratings?: User_RatingsUncheckedUpdateManyWithoutUsersNestedInput
    Videos?: VideosUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutSubscription_tierInput = {
    userid?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    num_of_friends?: NullableIntFieldUpdateOperationsInput | number | null
    num_of_followers?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor?: BoolFieldUpdateOperationsInput | boolean
    email_notifications?: BoolFieldUpdateOperationsInput | boolean
    push_notifications?: BoolFieldUpdateOperationsInput | boolean
    usedstorage?: BigIntFieldUpdateOperationsInput | bigint | number
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
  }

  export type AnimeCreateManyUsersInput = {
    animeid?: string
    description?: string | null
    trailerid?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
  }

  export type Anime_AuthorsCreateManyUsersInput = {
    animeid: string
  }

  export type BookmarksCreateManyUsersInput = {
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type CommentsCreateManyUsersInput = {
    commentid?: number
    parentid: string
    mediatype: $Enums.MediaType
    mediatime: number
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type Disliked_ContentCreateManyUsersInput = {
    contentid: number
    mediatype: $Enums.MediaType
  }

  export type FileCreateManyUsersInput = {
    id?: string
    name: string
    description?: string | null
    path?: string
    extension: string
    folderId?: string | null
    size: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    isShared?: boolean
    tags?: FileCreatetagsInput | string[]
    checksum?: string | null
    downloadCount?: number
    previewEnabled?: boolean
    isPublic?: boolean
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FileSharesCreateManyUsersInput = {
    fileId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type FolderCreateManyUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    lastAccessed?: Date | string | null
    tags?: FolderCreatetagsInput | string[]
    accessCount?: number
    totalSize?: number
    parentFolderId?: string | null
    filetype?: $Enums.FileType
    location?: $Enums.MediaType
  }

  export type FolderSharesCreateManyUsersInput = {
    folderId: string
    accessLevel?: $Enums.AccessLevel
  }

  export type Liked_ContentCreateManyUsersInput = {
    mediatype: $Enums.MediaType
    contentid: number
  }

  export type MangaCreateManyUsersInput = {
    mangaid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    cover_iamge?: string | null
    likes?: bigint | number
    dislikes?: bigint | number
    age_rating?: $Enums.AgeRating
    MediaGenre?: MangaCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MoviesCreateManyUsersInput = {
    movieid?: string
    title: string
    description?: string | null
    release_date?: Date | string | null
    media_id_reference?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
    showbanner?: string | null
    age_rating?: $Enums.AgeRating
    media_reference_type: $Enums.MediaType
    MediaGenre?: MoviesCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type PollsCreateManyUsersInput = {
    pollid?: number
    title: string
    description: string
    likes?: bigint | number
    dislikes?: bigint | number
    date?: Date | string | null
    category?: string
    status?: string
    progress?: string | null
    views?: number
  }

  export type ReviewsCreateManyUsersInput = {
    reviewid?: number
    parentid: string
    mediatype: $Enums.MediaType
    review_text?: string
    review_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type Shopping_CartCreateManyUsersInput = {
    storeid: string
    quantity?: number | null
  }

  export type StoreCreateManyUsersInput = {
    storeid?: string
    title: string
    num_in_stock?: number
    release_date?: Date | string | null
    original_price?: Decimal | DecimalJsLike | number | string
    discount_price?: Decimal | DecimalJsLike | number | string
    discount_percent?: number
    shipping_price?: Decimal | DecimalJsLike | number | string
    description?: string
    num_of_carts?: number
    images?: string | null
    media_id_reference?: number | null
    sales?: number
    reference_media_type?: string | null
    MediaGenre?: StoreCreateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type User_ActivityCreateManyUsersInput = {
    child_content: string
    parent_content: string
    mediatype: $Enums.MediaType
    stopping_point: number
    date_watched?: Date | string
  }

  export type User_BookmarksCreateManyUsersInput = {
    mediatype: $Enums.MediaType
    parentid: string
  }

  export type User_RatingsCreateManyUsersInput = {
    parentid: string
    mediatype: $Enums.MediaType
    rating: number
  }

  export type VideosCreateManyUsersInput = {
    videoid?: string
    title: string
    description?: string
    release_date?: Date | string | null
    media_type?: $Enums.MediaType
    video_banner?: string
    likes?: bigint | number
    dislikes?: bigint | number
    duration?: bigint | number | null
    MediaGenre?: VideosCreateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: string
    views?: number
  }

  export type AnimeUpdateWithoutUsersInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Videos?: VideosUpdateOneWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutUsersInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateManyWithoutUsersInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trailerid?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Anime_AuthorsUpdateWithoutUsersInput = {
    Anime?: AnimeUpdateOneRequiredWithoutAnime_AuthorsNestedInput
  }

  export type Anime_AuthorsUncheckedUpdateWithoutUsersInput = {
    animeid?: StringFieldUpdateOperationsInput | string
  }

  export type Anime_AuthorsUncheckedUpdateManyWithoutUsersInput = {
    animeid?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarksUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneRequiredWithoutBookmarksNestedInput
    Manga?: MangaUpdateOneRequiredWithoutBookmarksNestedInput
    Movies?: MoviesUpdateOneRequiredWithoutBookmarksNestedInput
    Videos?: VideosUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarksUncheckedUpdateManyWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    ContentUnit?: ContentUnitUpdateOneRequiredWithoutCommentsNestedInput
    Videos?: VideosUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateWithoutUsersInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommentsUncheckedUpdateManyWithoutUsersInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Disliked_ContentUpdateWithoutUsersInput = {
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type Disliked_ContentUncheckedUpdateWithoutUsersInput = {
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type Disliked_ContentUncheckedUpdateManyWithoutUsersInput = {
    contentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FileUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Folder?: FolderUpdateOneWithoutFileNestedInput
    FileShares?: FileSharesUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    FileShares?: FileSharesUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileUpdatetagsInput | string[]
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    previewEnabled?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FileSharesUpdateWithoutUsersInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    File?: FileUpdateOneRequiredWithoutFileSharesNestedInput
  }

  export type FileSharesUncheckedUpdateWithoutUsersInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FileSharesUncheckedUpdateManyWithoutUsersInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUpdateManyWithoutFolderNestedInput
    Folder?: FolderUpdateOneWithoutOther_FolderNestedInput
    other_Folder?: FolderUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    File?: FileUncheckedUpdateManyWithoutFolderNestedInput
    other_Folder?: FolderUncheckedUpdateManyWithoutFolderNestedInput
    FolderShares?: FolderSharesUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: FolderUpdatetagsInput | string[]
    accessCount?: IntFieldUpdateOperationsInput | number
    totalSize?: IntFieldUpdateOperationsInput | number
    parentFolderId?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    location?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type FolderSharesUpdateWithoutUsersInput = {
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    Folder?: FolderUpdateOneRequiredWithoutFolderSharesNestedInput
  }

  export type FolderSharesUncheckedUpdateWithoutUsersInput = {
    folderId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type FolderSharesUncheckedUpdateManyWithoutUsersInput = {
    folderId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
  }

  export type Liked_ContentUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type Liked_ContentUncheckedUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type Liked_ContentUncheckedUpdateManyWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    contentid?: IntFieldUpdateOperationsInput | number
  }

  export type MangaUpdateWithoutUsersInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateWithoutUsersInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
    Anime?: AnimeUncheckedUpdateManyWithoutMangaNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMangaNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMangaNestedInput
  }

  export type MangaUncheckedUpdateManyWithoutUsersInput = {
    mangaid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cover_iamge?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    MediaGenre?: MangaUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type MoviesUpdateWithoutUsersInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUpdateManyWithoutMoviesNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutMoviesNestedInput
  }

  export type MoviesUncheckedUpdateWithoutUsersInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutMoviesNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutMoviesNestedInput
  }

  export type MoviesUncheckedUpdateManyWithoutUsersInput = {
    movieid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    showbanner?: NullableStringFieldUpdateOperationsInput | string | null
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    media_reference_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: MoviesUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type PollsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type PollsUncheckedUpdateWithoutUsersInput = {
    pollid?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type PollsUncheckedUpdateManyWithoutUsersInput = {
    pollid?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewsUpdateWithoutUsersInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReviewsUncheckedUpdateWithoutUsersInput = {
    reviewid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ReviewsUncheckedUpdateManyWithoutUsersInput = {
    reviewid?: IntFieldUpdateOperationsInput | number
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    review_text?: StringFieldUpdateOperationsInput | string
    review_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type Shopping_CartUpdateWithoutUsersInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Store?: StoreUpdateOneRequiredWithoutShopping_CartNestedInput
  }

  export type Shopping_CartUncheckedUpdateWithoutUsersInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Shopping_CartUncheckedUpdateManyWithoutUsersInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreUpdateWithoutUsersInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutUsersInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
    Shopping_Cart?: Shopping_CartUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutUsersInput = {
    storeid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    num_in_stock?: IntFieldUpdateOperationsInput | number
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    original_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount_percent?: FloatFieldUpdateOperationsInput | number
    shipping_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    num_of_carts?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    media_id_reference?: NullableIntFieldUpdateOperationsInput | number | null
    sales?: IntFieldUpdateOperationsInput | number
    reference_media_type?: NullableStringFieldUpdateOperationsInput | string | null
    MediaGenre?: StoreUpdateMediaGenreInput | $Enums.MediaGenre[]
  }

  export type User_ActivityUpdateWithoutUsersInput = {
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_ActivityUncheckedUpdateWithoutUsersInput = {
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_ActivityUncheckedUpdateManyWithoutUsersInput = {
    child_content?: StringFieldUpdateOperationsInput | string
    parent_content?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    stopping_point?: IntFieldUpdateOperationsInput | number
    date_watched?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_BookmarksUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_BookmarksUncheckedUpdateWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_BookmarksUncheckedUpdateManyWithoutUsersInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    parentid?: StringFieldUpdateOperationsInput | string
  }

  export type User_RatingsUpdateWithoutUsersInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type User_RatingsUncheckedUpdateWithoutUsersInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type User_RatingsUncheckedUpdateManyWithoutUsersInput = {
    parentid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type VideosUpdateWithoutUsersInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUpdateManyWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateWithoutUsersInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    Anime?: AnimeUncheckedUpdateManyWithoutVideosNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutVideosNestedInput
    Comments?: CommentsUncheckedUpdateManyWithoutVideosNestedInput
  }

  export type VideosUncheckedUpdateManyWithoutUsersInput = {
    videoid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    release_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    media_type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    video_banner?: StringFieldUpdateOperationsInput | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    duration?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MediaGenre?: VideosUpdateMediaGenreInput | $Enums.MediaGenre[]
    thumbnail?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
  }

  export type AnimeCreateManyVideosInput = {
    animeid?: string
    description?: string | null
    upload_date?: Date | string | null
    release_date?: Date | string
    likes?: bigint | number
    dislikes?: bigint | number
    activity?: number
    authorid: string
    average_rating?: number
    anime_ratings?: number
    age_rating?: $Enums.AgeRating
    mangaid?: string | null
    title: string
    type?: $Enums.MediaType
    MediaGenre?: AnimeCreateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: string | null
    visible?: boolean
  }

  export type BookmarksCreateManyVideosInput = {
    userid: string
    mediatype: $Enums.MediaType
  }

  export type CommentsCreateManyVideosInput = {
    commentid?: number
    mediatype: $Enums.MediaType
    mediatime: number
    userid: string
    comment_text?: string
    comment_date?: Date | string
    parent_comment_id?: number | null
    likes?: bigint | number
    dislikes?: bigint | number
  }

  export type AnimeUpdateWithoutVideosInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Manga?: MangaUpdateOneWithoutAnimeNestedInput
    Users?: UsersUpdateOneRequiredWithoutAnimeNestedInput
    Anime_Authors?: Anime_AuthorsUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutVideosInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
    Anime_Authors?: Anime_AuthorsUncheckedUpdateManyWithoutAnimeNestedInput
    Bookmarks?: BookmarksUncheckedUpdateManyWithoutAnimeNestedInput
    ContentGroupLinks?: ContentGroupMediaUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateManyWithoutVideosInput = {
    animeid?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    upload_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    activity?: IntFieldUpdateOperationsInput | number
    authorid?: StringFieldUpdateOperationsInput | string
    average_rating?: FloatFieldUpdateOperationsInput | number
    anime_ratings?: IntFieldUpdateOperationsInput | number
    age_rating?: EnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating
    mangaid?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    MediaGenre?: AnimeUpdateMediaGenreInput | $Enums.MediaGenre[]
    anime_key_visual?: NullableStringFieldUpdateOperationsInput | string | null
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookmarksUpdateWithoutVideosInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    Anime?: AnimeUpdateOneRequiredWithoutBookmarksNestedInput
    Manga?: MangaUpdateOneRequiredWithoutBookmarksNestedInput
    Movies?: MoviesUpdateOneRequiredWithoutBookmarksNestedInput
    Users?: UsersUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarksUncheckedUpdateWithoutVideosInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type BookmarksUncheckedUpdateManyWithoutVideosInput = {
    userid?: StringFieldUpdateOperationsInput | string
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
  }

  export type CommentsUpdateWithoutVideosInput = {
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
    ContentUnit?: ContentUnitUpdateOneRequiredWithoutCommentsNestedInput
    Users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateWithoutVideosInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommentsUncheckedUpdateManyWithoutVideosInput = {
    commentid?: IntFieldUpdateOperationsInput | number
    mediatype?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    mediatime?: IntFieldUpdateOperationsInput | number
    userid?: StringFieldUpdateOperationsInput | string
    comment_text?: StringFieldUpdateOperationsInput | string
    comment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    likes?: BigIntFieldUpdateOperationsInput | bigint | number
    dislikes?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}